C++ 学习笔记 —— 模板

# typename
在 C++ 中，`typename` 是一个关键字，用于显式地告诉编译器某个标识符是一个类型。它通常用在模板编程中，特别是在依赖类型（dependent types）的上下文中。依赖类型是指那些依赖于模板参数的类型。

在模板编程中，当编译器解析模板代码时，它可能无法确定某个表达式是一个类型还是一个值。`typename` 用于明确告诉编译器某个表达式是一个类型。


```cpp
typename <type-expression>
```

- **`typename`**：关键字，用于声明后面的表达式是一个类型。
- **`<type-expression>`**：一个依赖于模板参数的类型表达式。

## 示例 1：依赖类型

假设有一个模板类 `ProtoSignal`，它使用了依赖类型：

```cpp
template<class Collector, class R, class... Args>
class ProtoSignal<R (Args...), Collector> : private CollectorInvocation<Collector, R (Args...)> {
protected:
  using CbFunction = std::function<R (Args...)>;
  using Result = typename CbFunction::result_type; // 使用 typename
  using CollectorResult = typename Collector::CollectorResult; // 使用 typename
};
```

在这里，`CbFunction::result_type` 和 `Collector::CollectorResult` 都是依赖类型，因为它们依赖于模板参数 `CbFunction` 和 `Collector`。为了明确告诉编译器这些表达式是类型，我们使用了 `typename`。

### **依赖类型**

在模板编程中，依赖类型是指那些依赖于模板参数的类型。例如：

```cpp
template <typename T>
struct MyStruct {
    using Type = typename T::value_type; // T::value_type 是一个依赖类型
};
```

- **`T::value_type`**：这是一个依赖类型，因为它依赖于模板参数 `T`。
- **`typename`**：用于明确告诉编译器 `T::value_type` 是一个类型。

### **非依赖类型**

非依赖类型是指那些不依赖于模板参数的类型。例如：

```cpp
using Type = int; // 非依赖类型，不需要 typename
```

- **`int`**：这是一个非依赖类型，因为它不依赖于模板参数。

## 模板模板参数

`typename` 也可以用于模板模板参数。例如：

```cpp
template <typename T, template <typename> typename Container>
void myFunction(Container<T> container) {
    // 使用 typename
}
```

- **`template <typename> typename Container`**：表示 `Container` 是一个模板模板参数，`typename` 用于明确告诉编译器 `Container` 是一个类型。