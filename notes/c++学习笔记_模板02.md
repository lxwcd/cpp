C++ 学习笔记 —— 模板

# typename
在 C++ 中，`typename` 是一个关键字，用于显式地告诉编译器某个标识符是一个类型。它通常用在模板编程中，特别是在依赖类型（dependent types）的上下文中。依赖类型是指那些依赖于模板参数的类型。

在模板编程中，当编译器解析模板代码时，它可能无法确定某个表达式是一个类型还是一个值。`typename` 用于明确告诉编译器某个表达式是一个类型。


```cpp
typename <type-expression>
```

- **`typename`**：关键字，用于声明后面的表达式是一个类型。
- **`<type-expression>`**：一个依赖于模板参数的类型表达式。

## 示例 1：依赖类型

假设有一个模板类 `ProtoSignal`，它使用了依赖类型：

```cpp
template<class Collector, class R, class... Args>
class ProtoSignal<R (Args...), Collector> : private CollectorInvocation<Collector, R (Args...)> {
protected:
  using CbFunction = std::function<R (Args...)>;
  using Result = typename CbFunction::result_type; // 使用 typename
  using CollectorResult = typename Collector::CollectorResult; // 使用 typename
};
```

在这里，`CbFunction::result_type` 和 `Collector::CollectorResult` 都是依赖类型，因为它们依赖于模板参数 `CbFunction` 和 `Collector`。为了明确告诉编译器这些表达式是类型，我们使用了 `typename`。

### **依赖类型**

在模板编程中，依赖类型是指那些依赖于模板参数的类型。例如：

```cpp
template <typename T>
struct MyStruct {
    using Type = typename T::value_type; // T::value_type 是一个依赖类型
};
```

- **`T::value_type`**：这是一个依赖类型，因为它依赖于模板参数 `T`。
- **`typename`**：用于明确告诉编译器 `T::value_type` 是一个类型。

### **非依赖类型**

非依赖类型是指那些不依赖于模板参数的类型。例如：

```cpp
using Type = int; // 非依赖类型，不需要 typename
```

- **`int`**：这是一个非依赖类型，因为它不依赖于模板参数。

## 模板模板参数

`typename` 也可以用于模板模板参数。例如：

```cpp
template <typename T, template <typename> typename Container>
void myFunction(Container<T> container) {
    // 使用 typename
}
```

- **`template <typename> typename Container`**：表示 `Container` 是一个模板模板参数，`typename` 用于明确告诉编译器 `Container` 是一个类型。

# 模板实例化

**模板函数（或类）在每个被使用的编译单元（通常是一个`.cpp`文件）中，针对每一组独特的模板参数组合，都会生成一个独立的实例（Instantiation）**。这个过程被称为“实例化”（Instantiation）。

但这并不完全等同于 `inline`，并且确实存在“占空间”的风险（称为“代码膨胀”），不过现代编译器有非常强大的手段来缓解这个问题。

## 模板的工作原理：两阶段编译

C++模板采用“两阶段查找”（Two-phase lookup）机制：
*   **阶段一（模板定义时）**：检查模板代码本身的基本语法错误，比如缺少分号、未知的变量名（不依赖于模板参数的）等。
*   **阶段二（模板实例化时）**：这是关键阶段。当编译器在代码中看到你实际使用了模板时（例如 `max<int>(a, b)`），它才会根据具体的模板参数（这里是 `int`）将模板“蓝图”生成真正的函数代码（或类代码）。这个生成的函数就是一个“实例”。

## 实例化发生在编译期

实例化发生在**编译期**，而不是链接期。这意味着：

*   **每个 `.cpp` 文件都是独立编译的**（称为一个“编译单元”）。
*   如果**多个 `.cpp` 文件**都使用了 `max<int>`，那么**每个`.cpp`文件在编译时**都会独立地生成一份 `max<int>` 的二进制代码。
*   最终，链接器（Linker）需要将这些多个编译单元合并成一个可执行文件。

## 与 `inline` 函数的对比

*   **`inline` 函数**：`inline` 只是一个建议给编译器的提示，希望将函数体直接嵌入调用处来避免函数调用的开销。编译器可以忽略它。**`inline` 函数为了能在多个编译单元中使用，其定义（函数体）必须放在头文件中。**
*   **模板函数**：出于同样的原因——**编译器必须在看到模板被使用的地方生成代码**，所以模板的**定义（实现）也必须几乎总是放在头文件中**。否则，在另一个`.cpp`文件里使用它时，编译器会找不到“蓝图”来生成实例。

所以，它们的**相似之处在于：定义都必须放在头文件里**。但它们的**目的不同**：`inline` 是为了优化执行速度（消除调用开销），而模板是为了实现泛型编程。

## 代码膨胀问题与解决方案

如果多个源文件都用了 `max<int>`，那目标文件里就有很多份一模一样的 `max<int>` 代码了？ 这称为 “模板代码膨胀”（Template Code Bloat）。

**a) 编译器的强大优化：重复代码消除**

这是最重要、最有效的缓解手段。现代编译器（如 GCC, Clang, MSVC）都非常智能。

*   当链接器将多个目标文件（`.obj`/`.o`）合并时，它会发现这些不同编译单元中生成的、完全相同的模板实例（例如 `max<int>`）。
*   链接器会**只保留一份`max<int>`的代码**，而丢弃所有重复的副本。
*   这个过程是自动的，你几乎不需要做任何事就能享受到这个优化。这意味着，虽然编译过程中可能生成了10份 `max<int>`，但最终的可执行文件里只有一份。

**b) 显式实例化（Explicit Instantiation）**

这是一种手动控制方式，用于在大型项目中有意减少编译时间或控制实例化位置。

*   **做法**：在一个`.cpp`文件中，显式地告诉编译器：“请在这里为我生成 `max<int>` 和 `max<double>` 的实例！”。
*   **效果**：在其他文件中使用 `max<int>` 时，编译器不会本地生成代码，而会等待链接器去找到你在那个特定`.cpp`文件中生成的实例。这强制实现了“一个实例”，彻底避免了重复编译和潜在的膨胀。

**示例：**
```cpp
// my_template.cpp
#include "my_template.h"

// 显式实例化：强制编译器在此生成 int 和 double 版本的代码
template int max<int>(int, int);
template double max<double>(double, double);

// main.cpp
#include "my_template.h"

int main() {
    int a = 1, b = 2;
    double x = 1.1, y = 2.2;
    max(a, b);   // 链接到 my_template.cpp 中的实例
    max(x, y);   // 链接到 my_template.cpp 中的实例
    // max(‘a‘, ‘z‘); // 错误！char 版本没有显式实例化，编译器也无法隐式实例化（因为定义不可见）
}
```
*   **优点**：精确控制，减少整体编译时间。
*   **缺点**：不灵活，你必须预先知道所有需要用到的类型，否则会导致链接错误。

**c) 使用公共基类或擦除类型**

对于可能导致严重膨胀的复杂模板（比如每个容器类型都实例化一个完整的算法），高级技巧是使用类型擦除（如 `std::function`）或将通用操作下放到非模板基类中，让模板代码只是薄薄的一层包装，这样大量代码就在基类中只存在一份。

# 类型擦除（Type Erasure）(?)

```
C语言 (void*) -> 基础多态 (继承) -> 泛型编程 (模板) -> 现代类型擦除 (std::function)
   |                 |                 |                     |
   |                 |                 |                     |
无类型安全       垂直类型安全      水平类型安全          通用类型安全
(手动管理)        (侵入式)         (编译期展开)        (非侵入式+运行时调度)
```

## 第一阶段：C语言的 `void*` - 最原始、最危险的“类型擦除”

在C语言中，如果你想写一个可以处理任何类型数据的函数，会用 `void*`。

**例子：C标准库的 `qsort` 函数**
```c
#include <stdlib.h>

// qsort 的函数原型
void qsort(void *base,    // 数组起始地址 (void* 擦除了数组元素类型)
           size_t nmemb,  // 元素个数
           size_t size,   // 每个元素的大小 (类型信息被丢弃，需要手动提供！)
           int (*compar)(const void *, const void *) // 比较函数指针
          );

// 我们必须自己编写比较函数，负责把 void* 转换回具体的类型
int compare_ints(const void *a, const void *b) {
    // 程序员必须自己知道这里比较的是 int
    const int *ia = (const int *)a; // 危险的转换！如果传错了就崩溃。
    const int *ib = (const int *)b;
    return *ia - *ib; 
}

int main() {
    int arr[] = {5, 2, 8, 1, 4};
    qsort(arr, 5, sizeof(int), compare_ints); // 必须正确提供 sizeof(int)
    // ... 排序后的数组
    return 0;
}
```

**分析：**
*   **擦除了什么？** `qsort` 完全不知道它要排序的数组是什么类型（`int[]`, `double[]`, `struct[]`），类型信息被抹去，只剩下原始的字节和地址（`void*`）。
*   **如何恢复？** 类型信息需要由**程序员手动提供**：
    1.  `size` 参数：告诉函数每个元素多长。
    2.  `compar` 函数：知道如何把 `void*` 转换回正确的类型并进行操作。
*   **巨大缺点**：
    *   **极不安全**：如果程序员把 `size` 算错，或者 `compar` 函数里转换的类型和数组实际类型不一致，会导致**未定义行为（Undefined Behavior）**，通常是程序崩溃。
    *   **容易出错**：全靠程序员自觉和仔细。

## 第二阶段：C++的基础多态（继承） - 类型安全的垂直抽象

C++引入了类和继承，提供了一种类型安全的抽象方式。它要求所有可用的类型必须继承自一个共同的基类。

**例子：重写 `qsort` 的思路为通用的 `Sorter`**
```cpp
#include <vector>
#include <memory>
#include <algorithm>

// 1. 定义统一的接口（抽象基类）
class Sortable {
public:
    virtual ~Sortable() = default;
    virtual bool lessThan(const Sortable* other) const = 0; // 纯虚函数
    // 注意：这里已经不需要 size 了，因为每个对象自己知道怎么比较
};

// 2. 定义具体类（必须继承自Sortable）
class SortableInt : public Sortable {
public:
    int value;
    SortableInt(int v) : value(v) {}
    
    // 实现接口
    bool lessThan(const Sortable* other) const override {
        // 安全的向下转换：我们知道other实际上是SortableInt吗？
        // 这其实是一个假设，但如果代码设计得好，这个假设成立。
        const SortableInt* otherInt = dynamic_cast<const SortableInt*>(other);
        // 更好的设计是在接口层就避免需要downcast，但这里为了举例先这样写。
        return value < otherInt->value;
    }
};

// 3. 一个通用的排序函数（现在它安全多了）
void sortVector(std::vector<std::unique_ptr<Sortable>>& vec) {
    std::sort(vec.begin(), vec.end(),
        [](const std::unique_ptr<Sortable>& a, const std::unique_ptr<Sortable>& b) {
            return a->lessThan(b.get());
        });
}

int main() {
    std::vector<std::unique_ptr<Sortable>> data;
    data.push_back(std::make_unique<SortableInt>(5));
    data.push_back(std::make_unique<SortableInt>(2));
    data.push_back(std::make_unique<SortableInt>(8));
    
    sortVector(data); // 安全地排序
    return 0;
}
```

**分析：**
*   **擦除了什么？** `sortVector` 函数不知道它排序的具体是 `SortableInt`、`SortableString` 还是其他什么，它只知道它们都是 `Sortable`。
*   **如何恢复？** 通过**虚函数表（vtable）** 机制。在运行时，调用 `lessThan` 方法会自动找到对象实际类型所对应的实现。**类型系统在保驾护航**。
*   **优点**：
    *   **类型安全**：编译器会保证你放入容器的对象都继承自 `Sortable`，并且正确实现了虚函数。不会出现 `void*` 那种灾难性的错误转换。
*   **缺点**：
    *   **侵入式（Intrusive）**：你想让一个类能被排序，**必须**修改它的定义，让它继承自 `Sortable`。对于第三方库的类（如 `std::string`, `int`）或者基本类型，你无法这样做。
    *   **垂直关系**：类型之间的关系是严格的“是一个（is-a）”继承关系。

**这就像：** 所有零件（`SortableInt`, `SortableString`）在生产时就必须打上“可排序”的统一标签（继承 `Sortable`）。分类员（`sortVector`）只看标签分拣，非常安全，但零件本身必须为这个系统量身定制。

---

## 第三阶段：现代C++类型擦除 - 非侵入式的通用抽象

现代C++类型擦除结合了**模板（编译期多态）** 和**继承（运行时多态）** 的优点。它不要求被管理的类型继承自特定基类，只要在**概念上（Conceptually）** 支持相同的操作即可。

**例子：实现一个通用的 `AnyDrawable` 类型**
假设有一些完全不相关的类，它们恰好都有 `draw()` 方法，但我们无法修改它们的源码（比如来自不同库）。

```cpp
// 来自第三方库的类，我们无法修改
class LegacyCircle {
public:
    void draw() const { std::cout << "Drawing a circle.\n"; }
};

class LegacySquare {
public:
    void draw() const { std::cout << "Drawing a square.\n"; }
};

// 我们自己的类
class Text {
public:
    void draw() const { std::cout << "Drawing text.\n"; }
};

// ------------------ 类型擦除包装器 ------------------
// 1. 定义对外接口
class DrawableConcept {
public:
    virtual ~DrawableConcept() = default;
    virtual void draw() const = 0;
};

// 2. 定义内部模板模型
template <typename T>
class DrawableModel : public DrawableConcept {
public:
    DrawableModel(T value) : data_(std::move(value)) {}
    void draw() const override { data_.draw(); } // 关键：调用具体类型的 draw()
private:
    T data_;
};

// 3. 定义非模板包装器
class AnyDrawable {
public:
    // 模板构造函数：可以接受任何具有 draw() 方法的类型 T
    template <typename T>
    AnyDrawable(T value) : object_(std::make_unique<DrawableModel<T>>(std::move(value))) {}

    // 统一对外的接口
    void draw() const { object_->draw(); }

private:
    std::unique_ptr<DrawableConcept> object_;
};

// ------------------ 使用 ------------------
int main() {
    std::vector<AnyDrawable> drawing_list;

    // 可以放入任何具有 draw() 方法的对象，无需公共基类！
    drawing_list.push_back(LegacyCircle{});
    drawing_list.push_back(LegacySquare{});
    drawing_list.push_back(Text{});

    // 统一调用
    for (const auto& item : drawing_list) {
        item.draw(); // 输出: Drawing a circle. Drawing a square. Drawing text.
    }
}
```

**分析：**
*   **擦除了什么？** `AnyDrawable` 和 `std::vector<AnyDrawable>` 完全不知道它们内部持有的具体是 `LegacyCircle`, `LegacySquare` 还是 `Text`。这些具体类型信息在编译时被“擦除”并封装起来。
*   **如何恢复？** 和第二阶段一样，通过**虚函数调用**。但关键在于，**“可绘制（Drawable）”这个约束不再是通过继承强制施加的，而是通过模板在编译期隐式验证的**。如果一个类型没有 `draw()` 方法，在编译 `DrawableModel<T>` 时就会报错。
*   **巨大优势**：
    *   **非侵入式（Non-intrusive）**：无需修改 `LegacyCircle` 等现有类的代码。只要它碰巧有 `draw()` 方法，就能用。
    *   **类型安全**：和第二阶段一样安全。
    *   **极其通用**：可以包装任何符合概念（Concept）的类型，实现了“鸭子类型”（Duck Typing）——如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。

**这就像：** 发明了一种**万能适配盒（AnyDrawable）**。任何零件，不管它原来是什么样，只要它能完成“绘制”这个动作（有 `draw()` 方法），就能被塞进这个盒子里。分类员现在只需要处理一种盒子，既安全又灵活。

## 总结对比

| 特性         | C语言 `void*`        | C++ 基础多态          | C++ 现代类型擦除                            |
| :----------- | :------------------- | :-------------------- | :------------------------------------------ |
| **机制**     | 原始内存操作         | 继承 + 虚函数         | 模板 + 继承 + 虚函数                        |
| **类型安全** | **无**，极易出错     | **有**，编译器保证    | **有**，编译器保证                          |
| **侵入性**   | 无                   | **高**，需修改类定义  | **无**，对现有类零修改                      |
| **灵活性**   | 理论上无限，实际危险 | 受限，需继承体系      | 极高，符合概念即可                          |
| **性能开销** | 无额外开销           | 虚函数调用            | 虚函数调用 + 动态内存分配                   |
| **典型代表** | `qsort`, `bsearch`   | 传统的GUI控件继承体系 | `std::function`, `std::any`, `std::variant` |

## “Concept + Model + Wrapper” 三明治结构

这种“三明治结构”**不是C++语言标准中的正式术语**，而是C++社区和专家们为了清晰描述类型擦除的实现模式而总结出来的一个**设计模式（Design Pattern）** 的昵称或形象化比喻。它非常准确地捕捉了这种技术的核心架构。

- **上面一片面包（Top Bread）**：`Wrapper` 类，是用户直接接触的接口。
- **中间的馅料（Filling）**：`Model` 模板类，负责承载具体类型并实现功能。
- **下面一片面包（Bottom Bread）**：`Concept` 抽象接口，定义了所有类型必须遵守的契约。

`Wrapper` 和 `Concept` 都是**非模板的、稳定的**，像两片面包一样把**高度可变的、模板化的** `Model` “馅料”包裹在中间，形成了一个完整、美味且实用的“三明治”。


---

### 1. Concept（概念/接口层）

这是结构的**基石**，定义了“要擦除成什么样子”。

**职责**：
- 声明一组**纯虚函数**，这些函数构成了需要被擦除的类型必须支持的**统一操作接口**。
- 通常包含一个**虚析构函数**，以确保通过基类指针删除派生类对象时行为正确。

**特点**：
- 是一个**非模板的抽象基类**。
- 它只知道接口，完全不知道将会有哪些具体类型来实现这个接口。
- 它的存在是为了实现**运行时多态**。

**代码体现**：
```cpp
// 概念层：定义“可绘制”必须做什么
class DrawableConcept {
public:
    virtual ~DrawableConcept() = default; // 基石中的基石
    virtual void draw() const = 0;        // 统一的操作接口
    // 可以扩展其他接口，如 virtual Box getBounds() const = 0;
};
```

### 2. Model（模型/实现层）

这是结构的**引擎**，负责“如何擦除”。

**职责**：
- 是一个**模板类**，继承自 `Concept` 接口。
- 保存一个具体类型 `T` 的实例。
- **实现 `Concept` 中声明的所有纯虚函数**。在每个实现中，它将调用**转发（forward）** 给其保存的 `T` 类型对象的相应方法。

**特点**：
- 是连接“抽象接口”和“具体类型”的**桥梁**。
- 因为它是模板，所以会为每一种被使用的类型 `T` **生成一份独立的代码**（实例化）。
- 它的存在利用了**编译期多态**来检查类型 `T` 是否满足概念约束（即有 `draw` 方法）。

**代码体现**：
```cpp
// 模型层：负责存储具体对象并实现接口
template <typename T>
class DrawableModel : public DrawableConcept { // 继承自接口
public:
    // 构造函数：接收一个具体类型的对象并存储它
    DrawableModel(T value) : data_(std::move(value)) {}
    
    // 实现接口：将虚函数调用转发给具体对象
    void draw() const override { data_.draw(); } // 要求 T 必须有 .draw() 方法

private:
    T data_; // 这里保存着被擦除的具体对象
};
```

### 3. Wrapper（包装器/外观层）

这是结构的**门面**，负责“提供擦除后的结果”。

**职责**：
- 是一个**非模板类**，为用户提供干净、统一的类型。
- 内部包含一个**指向 `Concept` 基类的智能指针**（通常是 `std::unique_ptr`）。
- 提供一个**模板构造函数**，可以接受任何符合概念的类型 `T`。在这个构造函数中，它会在堆上创建一个 `Model<T>` 对象，并用基类指针管理它。
- 提供与 `Concept` 接口相对应的**公共成员函数**。这些函数简单地将调用委托给内部的 `Concept` 指针。

**特点**：
- 对用户来说，它就是**一个具体的类型**（如 `AnyDrawable`），而不是模板。
- 隐藏了内部所有的模板复杂性和多态细节。
- **“类型擦除”这个魔术最后生效的地方**：构造函数接收模板参数 `T`，但存入成员变量时，类型 `T` 被“擦除”了，只留下了 `Concept*`。

**代码体现**：
```cpp
// 包装层：提供给用户的最终产品
class AnyDrawable {
public:
    // 模板构造函数：是类型擦除的入口
    template <typename T>
    AnyDrawable(T value)
        : object_(std::make_unique<DrawableModel<T>>(std::move(value))) // 关键！
    {}

    // 统一对外的公共API：直接映射Concept接口
    void draw() const {
        object_->draw(); // 委托调用，触发多态
    }

    // 规则-of-five：需要定义移动操作，但通常删除拷贝操作/实现克隆模式
    AnyDrawable(AnyDrawable&&) = default;
    AnyDrawable& operator=(AnyDrawable&&) = default;
    // AnyDrawable(const AnyDrawable&) = delete; // 或实现克隆

private:
    std::unique_ptr<DrawableConcept> object_; // 多态指针，指向Model<T>
};
```

---

### 整个工作流程（以 `AnyDrawable myDrawable = MyCircle{};` 为例）

1.  **用户构造**：用户创建 `AnyDrawable`，传入一个 `MyCircle` 对象。
2.  **构造转发**：`AnyDrawable` 的模板构造函数被实例化为 `AnyDrawable(MyCircle value)`。
3.  **模型创建**：在构造函数内，`std::make_unique<DrawableModel<MyCircle>>(std::move(value))` 被执行：
    - 编译器实例化 `DrawableModel<MyCircle>` 类（如果尚未实例化）。
    - 在堆上创建一个 `DrawableModel<MyCircle>` 对象，该对象内部存储着传入的 `MyCircle` 实例。
4.  **类型擦除**：创建的 `DrawableModel<MyCircle>*` 被赋值给 `std::unique_ptr<DrawableConcept> object_`。由于继承关系，这是合法的。**至此，`MyCircle` 的具体类型信息被“擦除”，只剩下 `DrawableConcept` 接口。**
5.  **用户调用**：用户调用 `myDrawable.draw()`。
6.  **委托和多态**：
    - `myDrawable.draw()` 调用 `object_->draw()`。
    - `object_` 实际指向一个 `DrawableModel<MyCircle>` 对象。
    - 通过虚函数表（vtable），调用被路由到 `DrawableModel<MyCircle>::draw()`。
    - `DrawableModel<MyCircle>::draw()` 调用其成员 `data_.draw()`，也就是 `MyCircle::draw()`。

---

### 总结

1.  **分离关注点（Separation of Concerns）**：每一层都有单一且明确的职责，代码结构清晰，易于维护和扩展。
2.  **非侵入性（Non-intrusive）**：被包装的类型（如 `MyCircle`）不需要修改自己的代码（如继承某个特定接口），只要在语法上满足要求即可（拥有同名方法）。这实现了**鸭子类型（Duck Typing）**。
3.  **类型安全（Type Safety）**：在编译时，通过 `Model<T>` 的实例化检查类型 `T` 是否支持所需操作。在运行时，通过虚函数接口保证调用正确。
4.  **实现异构集合（Heterogeneous Collections）**：可以创建像 `std::vector<AnyDrawable>` 这样的容器，其中每个元素在运行时可以持有不同类型的对象，但它们可以通过统一的接口被操作。

# SFINAE
