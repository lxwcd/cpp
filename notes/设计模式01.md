C++ 设计模式

# 单例模式
单例模式（Singleton Pattern）是一种设计模式，旨在确保一个类只有一个实例，并提供全局访问点。单例模式在C++中有多种实现方式，常见的有懒汉式（Lazy Initialization）和饿汉式（Eager Initialization）。

1. 私有化构造函数，防止外部实例化
2. 提供一个静态方法获取唯一实例
3. 线程安全（在多线程环境下）
4. 禁止拷贝和赋值

## 懒汉式单例模式（Lazy Initialization）—— 动态方式
懒汉式单例模式在第一次使用时才创建实例，适用于需要延迟加载的场景。

```cpp
#include <iostream>
#include <mutex>

class Singleton {

private:
    // 私有构造函数
    Singleton() {
        std::cout << "Singleton created" << std::endl;
    }

    // 私有析构函数，防止外部删除实例
    ~Singleton() {
        std::cout << "Singleton instance destroyed" << std::endl;
    }

    static Singleton* instance_;
    static std::mutex mutex_;

public:
    // 获取实例的静态方法
    static Singleton* getInstance() {
        if (instance_ == nullptr) { // 第一次检查，避免每次加锁
            std::lock_guard<std::mutex> lock(mutex_);
            if (instance_ == nullptr) { // 第二次检查，确保只有一个实例被创建
                instance_ = new Singleton();
            }
        }
        return instance_;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 供外界调用的示例方法
    void doSomething() {
        std::cout << "Doing something..." << std::endl;
    }

    // 显式删除实例的静态方法
    static void destroyInstance() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (instance_ != nullptr) {
            delete instance_;
            instance_ = nullptr;
        }
    }
};

// 初始化静态成员变量
Singleton* Singleton::instance_ = nullptr;
std::mutex Singleton::mutex_;

int main() {
    Singleton* s1 = Singleton::getInstance();
    s1->doSomething();

    Singleton* s2 = Singleton::getInstance();
    s2->doSomething();

    return 0;
}
```

### 使用静态成员函数获取实例
在懒汉模式中，获取实例的方法通常是一个静态成员函数。这是因为静态成员函数可以在没有实例的情况下被调用，而普通成员函数则需要通过类的实例来调用。

静态成员函数的特性：
- **无需实例**：静态成员函数属于类本身，而不是类的某个实例。因此，可以在没有创建任何实例的情况下调用静态成员函数。
- **全局访问**：静态成员函数可以通过类名直接调用，为全局访问点提供了便利。

在懒汉模式中，单例类的实例在第一次使用时才会被创建。如果获取实例的方法是普通成员函数，那么在调用该方法之前必须已经有一个实例存在，这就违背了单例模式的初衷。因此，获取实例的方法必须是静态成员函数。

静态成员函数：
- **无需实例**：静态成员函数可以通过类名直接调用，而不需要实例。
- **无法访问非静态成员**：静态成员函数不能访问类的非静态成员变量和非静态成员函数，因为它们没有 `this` 指针。
- **共享数据**：静态成员函数可以访问静态成员变量，这些变量在所有实例之间共享。

普通成员函数：
- **需要实例**：普通成员函数必须通过类的实例来调用。
- **可以访问所有成员**：普通成员函数可以访问类的所有成员变量和成员函数（包括静态和非静态）。
- **有 `this` 指针**：普通成员函数有一个隐含的 `this` 指针，指向调用该函数的实例。

静态函数：
- **全局作用域**：静态函数通常是指在文件作用域内的静态函数（使用 `static` 关键字修饰的函数），它们的作用范围仅限于定义它们的源文件。
- **文件内可见**：静态函数在定义它们的源文件之外不可见，通常用于实现文件内的辅助功能。

静态成员函数：
- **类作用域**：静态成员函数是类的成员函数，属于类本身，而不是某个实例。
- **类内可见**：静态成员函数可以在类的范围内访问，并且可以通过类名在全局范围内访问。

| 特性         | 静态函数 (Static Function)               | 普通函数 (Non-static Function)   |
| ------------ | ---------------------------------------- | -------------------------------- |
| **作用域**   | 文件作用域，只能在定义它们的源文件中调用 | 全局作用域，可以在多个文件中调用 |
| **链接类型** | 内部链接（internal linkage）             | 外部链接（external linkage）     |
| **可见性**   | 仅在定义它们的源文件中可见               | 可以在其他文件中声明并调用       |
| **用途**     | 文件内的辅助功能，避免命名冲突           | 全局功能，可以在多个文件中共享   |


```cpp
#include <iostream>

class MyClass {
public:
    // 静态成员函数
    static void staticMemberFunction() {
        std::cout << "Static member function called" << std::endl;
        // 无法访问非静态成员变量或非静态成员函数
        // std::cout << "Non-static member variable: " << nonStaticMember << std::endl; // 错误
    }

    // 普通成员函数
    void nonStaticMemberFunction() {
        std::cout << "Non-static member function called" << std::endl;
        std::cout << "Non-static member variable: " << nonStaticMember << std::endl;
    }

    // 静态成员变量
    static int staticMember;

    // 非静态成员变量
    int nonStaticMember;

    // 构造函数
    MyClass() : nonStaticMember(42) {}
};

// 静态成员变量定义
int MyClass::staticMember = 0;

// 静态函数（文件作用域）
static void staticFunction() {
    std::cout << "Static function called" << std::endl;
}

int main() {
    // 调用静态成员函数
    MyClass::staticMemberFunction();

    // 创建类的实例
    MyClass obj;

    // 调用普通成员函数
    obj.nonStaticMemberFunction();

    // 调用静态函数
    staticFunction();

    return 0;
}
```

输出结果：
```
Static member function called
Non-static member function called
Non-static member variable: 42
Static function called
```

### 多线程安全
在上面的单例模式中，`std::lock_guard<std::mutex>` 用于确保在多线程环境下对单例实例的访问是线程安全的。

在多线程环境中，如果多个线程同时调用 `getInstance` 方法，有可能会导致多个线程同时检测到 `instance_` 为 `nullptr`，从而创建多个实例。这违背了单例模式的初衷，即保证一个类只有一个实例。

`std::lock_guard` 是一个RAII（Resource Acquisition Is Initialization）类，用于在作用域内自动管理互斥锁的锁定和解锁。它的主要作用是确保在函数执行期间互斥锁被正确地锁定和解锁，以防止资源竞争和数据不一致。
1. **锁定互斥锁**：
   - 当 `std::lock_guard` 对象创建时，它会锁定传入的互斥锁，确保在 `getInstance` 方法执行期间，其他线程无法同时访问该方法。

2. **自动解锁**：
   - 当 `std::lock_guard` 对象超出作用域时（例如，函数返回时），它会自动解锁互斥锁，无需显式调用解锁操作。这减少了手动管理锁的复杂性和潜在的错误。

- **线程安全**：使用 `std::mutex` 确保线程安全。
- **延迟初始化**：实例在第一次调用 `getInstance` 时创建。
- **防止拷贝和赋值**：删除拷贝构造函数和赋值运算符。

## 懒汉式单例模式 —— 静态方式

```cpp
#include <iostream>

class Singleton {
public:
    // 获取实例的静态方法
    static Singleton& getInstance() {
        static Singleton instance; // 局部静态变量，第一次调用时初始化
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 供外界调用的示例方法
    void doSomething() {
        std::cout << "Doing something..." << std::endl;
    }

private:
    // 私有构造函数
    Singleton() {
        std::cout << "Singleton created" << std::endl;
    }
    // 析构函数
    ~Singleton() {
        std::cout << "Singleton destroyed" << std::endl;
    }

};

int main() {
    Singleton& s1 = Singleton::getInstance();
    s1.doSomething();

    Singleton& s2 = Singleton::getInstance();
    s2.doSomething();

    return 0;
}
```

- **线程安全**：使用 `static` 局部变量，C++11 及之后的标准保证其线程安全。
- **防止拷贝和赋值**：删除拷贝构造函数和赋值运算符。
- 单例会在程序结束时自动销毁，不需要手动管理其生命周期。

## 饿汉模式

饿汉模式是单例模式的另一种实现方式，与懒汉模式相反，它在程序启动时或类加载时就创建实例，而不是在第一次使用时才创建。

1. **提前初始化**：实例在程序启动时或类加载时就被创建
2. **线程安全**：由于实例在进入main函数前就已创建，不存在多线程竞争问题
3. **简单直接**：实现通常比懒汉模式更简单
4. **可能浪费资源**：如果实例最终没有被使用，会造成资源浪费

```cpp
#include <iostream>

class EagerSingleton {
public:
    // 获取单例实例的静态方法
    static EagerSingleton& getInstance() {
        return instance;
    }
    
    // 删除拷贝构造和赋值操作符
    EagerSingleton(const EagerSingleton&) = delete;
    EagerSingleton& operator=(const EagerSingleton&) = delete;
    
    void doSomething() {
        std::cout << "EagerSingleton doing something..." << std::endl;
    }

private:
    EagerSingleton() {
        std::cout << "EagerSingleton created at program start" << std::endl;
    }
    
    ~EagerSingleton() {
        std::cout << "EagerSingleton destroyed" << std::endl;
    }
    
    // 静态成员变量，在程序启动时初始化
    static EagerSingleton instance;
};

// 在类外定义并初始化静态成员
EagerSingleton EagerSingleton::instance;
```

**特点**：
- 实例作为静态成员变量，在程序启动时初始化
- 线程安全，无需同步机制
- 代码简单直接

优点
1. **线程安全**：实例在程序启动时创建，不存在多线程竞争问题
2. **实现简单**：无需复杂的同步机制
3. **性能良好**：没有运行时检查的开销
4. **确定性**：实例的创建时机是确定的（程序启动时）

缺点
1. **可能浪费资源**：如果实例最终没有被使用，会造成资源浪费
2. **启动时间可能较长**：如果实例初始化很耗时，会延长程序启动时间
3. **初始化顺序问题**：如果多个单例相互依赖，可能存在初始化顺序问题
4. **无法传递参数**：由于实例在程序启动时创建，无法在运行时传递初始化参数

饿汉模式适用于以下场景：

1. **实例较小且初始化简单**：不会显著影响程序启动时间
2. **实例一定会被使用**：避免资源浪费
3. **对性能要求较高**：希望避免运行时同步开销
4. **多线程环境**：希望避免复杂的同步逻辑
5. **初始化不依赖运行时参数**：所有初始化数据在编译时或启动时已知

# 工厂模式

工厂模式是创建型设计模式中最常用的一种，它提供了一种创建对象的最佳方式，而无需暴露对象创建的逻辑。在C++中，工厂模式主要有三种形式：简单工厂模式、工厂方法模式和抽象工厂模式。

## 简单工厂模式（Simple Factory）

简单工厂模式通过一个工厂类，根据传入的参数决定创建哪种产品类的实例。

```cpp
#include <iostream>
#include <memory>
#include <string>

// 产品接口
class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

// 具体产品类
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Circle" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Rectangle" << std::endl;
    }
};

class Triangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Triangle" << std::endl;
    }
};

// 简单工厂类
class ShapeFactory {
public:
    // 根据类型创建形状对象
    static std::unique_ptr<Shape> createShape(const std::string& type) {
        if (type == "Circle") {
            return std::make_unique<Circle>();
        } else if (type == "Rectangle") {
            return std::make_unique<Rectangle>();
        } else if (type == "Triangle") {
            return std::make_unique<Triangle>();
        } else {
            throw std::invalid_argument("Unknown shape type: " + type);
        }
    }
};

// 使用示例
int main() {
    try {
        auto circle = ShapeFactory::createShape("Circle");
        circle->draw();
        
        auto rectangle = ShapeFactory::createShape("Rectangle");
        rectangle->draw();
        
        auto triangle = ShapeFactory::createShape("Triangle");
        triangle->draw();
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

**优点**：
- 客户端与具体产品类解耦
- 客户端不需要知道具体产品的类名，只需要知道类型参数

**缺点**：
- 违反开闭原则（对扩展开放，对修改关闭）
- 添加新产品需要修改工厂类
- 工厂类职责过重，不易于扩展

## 工厂方法模式（Factory Method）

工厂方法模式其实就像一个**"代工厂"**的概念。

想象一下，开了一家比萨店的总公司，想要在不同城市开分店。每个地方的顾客口味不同：

- 纽约店：喜欢薄脆比萨
- 芝加哥店：喜欢厚底比萨
- 加州店：喜欢健康蔬菜比萨

如果没有工厂方法模式

```cpp
// 糟糕的做法：总店直接决定做什么比萨
class PizzaStore {
public:
    Pizza* orderPizza(string type) {
        Pizza* pizza;
        
        // 总店需要知道所有分店的具体做法
        if (type == "ny") {
            pizza = new NYStylePizza();
        } else if (type == "chicago") {
            pizza = new ChicagoStylePizza();
        } else if (type == "california") {
            pizza = new CaliforniaStylePizza();
        }
        // 每开一家新分店，这里就要修改代码！
        
        pizza->prepare();
        pizza->bake();
        pizza->cut();
        pizza->box();
        return pizza;
    }
};
```

**问题**：每次开新分店，总店都要修改代码，这很麻烦！

使用工厂方法模式

```cpp
// 总店只定义流程，让分店自己决定做什么比萨
class PizzaStore {
public:
    // 这就是工厂方法！每个分店自己实现
    virtual Pizza* createPizza(string type) = 0;
    
    // 总店统一流程
    Pizza* orderPizza(string type) {
        Pizza* pizza = createPizza(type); // 让分店自己做比萨
        pizza->prepare();
        pizza->bake();
        pizza->cut();
        pizza->box();
        return pizza;
    }
};

// 纽约分店：自己做薄脆比萨
class NYPizzaStore : public PizzaStore {
public:
    Pizza* createPizza(string type) override {
        if (type == "cheese") {
            return new NYStyleCheesePizza();
        } else if (type == "pepperoni") {
            return new NYStylePepperoniPizza();
        }
        // 纽约店自己决定做什么比萨
        return nullptr;
    }
};

// 芝加哥分店：自己做厚底比萨  
class ChicagoPizzaStore : public PizzaStore {
public:
    Pizza* createPizza(string type) override {
        if (type == "cheese") {
            return new ChicagoStyleCheesePizza();
        } else if (type == "veggie") {
            return new ChicagoStyleVeggiePizza();
        }
        // 芝加哥店自己决定做什么比萨
        return nullptr;
    }
};
```

### 工厂方法模式的核心思想

1. 分离"做什么"和"怎么做"
- **总店（父类）**：只知道"要做一个比萨"（做什么）
- **分店（子类）**：决定"具体怎么做这个比萨"（怎么做）

2. 依赖倒置原则
不要依赖具体实现，要依赖抽象接口。总店不关心具体是什么比萨，只关心它是比萨。

3. 开闭原则
对扩展开放，对修改关闭。开新分店时，只需要新增代码，不需要修改现有代码。

### 示例

```cpp
#include <iostream>
#include <string>
using namespace std;

// 产品接口：比萨
class Pizza {
public:
    virtual void prepare() = 0;
    virtual void bake() = 0;
    virtual void cut() = 0;
    virtual void box() = 0;
    virtual ~Pizza() {}
};

// 具体产品：纽约奶酪比萨
class NYStyleCheesePizza : public Pizza {
public:
    void prepare() override { cout << "准备纽约风格奶酪比萨" << endl; }
    void bake() override { cout << "烘烤纽约风格奶酪比萨" << endl; }
    void cut() override { cout << "切割纽约风格奶酪比萨" << endl; }
    void box() override { cout << "装盒纽约风格奶酪比萨" << endl; }
};

// 具体产品：芝加哥奶酪比萨
class ChicagoStyleCheesePizza : public Pizza {
public:
    void prepare() override { cout << "准备芝加哥风格奶酪比萨" << endl; }
    void bake() override { cout << "烘烤芝加哥风格奶酪比萨" << endl; }
    void cut() override { cout << "切割芝加哥风格奶酪比萨" << endl; }
    void box() override { cout << "装盒芝加哥风格奶酪比萨" << endl; }
};

// 创建者抽象类：比萨店
class PizzaStore {
public:
    // 工厂方法：让子类实现
    virtual Pizza* createPizza(string type) = 0;
    
    // 订单流程：父类定义
    Pizza* orderPizza(string type) {
        Pizza* pizza = createPizza(type);
        pizza->prepare();
        pizza->bake();
        pizza->cut();
        pizza->box();
        return pizza;
    }
    
    virtual ~PizzaStore() {}
};

// 具体创建者：纽约比萨店
class NYPizzaStore : public PizzaStore {
public:
    Pizza* createPizza(string type) override {
        if (type == "cheese") {
            return new NYStyleCheesePizza();
        }
        // 可以扩展其他类型的比萨
        return nullptr;
    }
};

// 具体创建者：芝加哥比萨店
class ChicagoPizzaStore : public PizzaStore {
public:
    Pizza* createPizza(string type) override {
        if (type == "cheese") {
            return new ChicagoStyleCheesePizza();
        }
        // 可以扩展其他类型的比萨
        return nullptr;
    }
};

// 使用示例
int main() {
    // 开一家纽约比萨店
    PizzaStore* nyStore = new NYPizzaStore();
    Pizza* nyPizza = nyStore->orderPizza("cheese");
    cout << " Ethan 订购了一个 " << endl;
    delete nyPizza;
    
    // 开一家芝加哥比萨店
    PizzaStore* chicagoStore = new ChicagoPizzaStore();
    Pizza* chicagoPizza = chicagoStore->orderPizza("cheese");
    cout << " Joel 订购了一个 " << endl;
    delete chicagoPizza;
    
    delete nyStore;
    delete chicagoStore;
    return 0;
}
```

### 现实生活中的例子

1. **快递公司**：总公司规定收件、运输、派送的流程，但每个地区的网点自己决定用什么车辆、走什么路线。

2. **连锁咖啡店**：总部规定制作咖啡的标准流程，但每家分店根据当地口味调整糖和牛奶的比例。

3. **游戏开发**：游戏引擎定义创建角色的流程，但每个游戏自己决定创建什么类型的角色。

### 优点

1. **解耦**：使用者不需要知道对象的具体创建细节
2. **扩展性好**：添加新产品很容易，不需要修改现有代码
3. **符合单一职责**：创建逻辑集中在工厂类中
4. **符合开闭原则**：对扩展开放，对修改关闭

## 工厂方法 vs 简单工厂

| 简单工厂                     | 工厂方法                         |
| ---------------------------- | -------------------------------- |
| 一个工厂类负责所有产品的创建 | 每个具体产品都有一个对应的工厂类 |
| 添加新产品需要修改工厂类     | 添加新产品只需添加新的工厂类     |
| 违反开闭原则                 | 符合开闭原则                     |
| 适合产品种类较少的情况       | 适合产品种类较多或可能扩展的情况 |

## 抽象工厂模式（Abstract Factory）

抽象工厂模式就像一个**"品牌旗舰店"**的概念。

想象一下，要买一套电子产品：手机、笔记本、耳机。你有两个选择：

1. **苹果旗舰店**：买 iPhone + MacBook + AirPods
2. **小米旗舰店**：买 小米手机 + 小米笔记本 + 小米耳机

每个品牌的产品都能很好地配合使用，但不同品牌的产品可能不太兼容。

```cpp
// 抽象产品：手机
class Phone {
public:
    virtual void makeCall() = 0;
    virtual ~Phone() {}
};

// 抽象产品：笔记本
class Laptop {
public:
    virtual void programming() = 0;
    virtual ~Laptop() {}
};

// 抽象产品：耳机
class Earphone {
public:
    virtual void listenMusic() = 0;
    virtual ~Earphone() {}
};

// 抽象工厂：电子产品工厂
class ElectronicsFactory {
public:
    virtual Phone* createPhone() = 0;
    virtual Laptop* createLaptop() = 0;
    virtual Earphone* createEarphone() = 0;
    virtual ~ElectronicsFactory() {}
};
```

1. 产品家族概念
抽象工厂创建的是**一整套相关的产品**，而不是单个产品。

2. 保证产品兼容性
同一个工厂创建的产品能够很好地协同工作。

3. 切换整个产品系列
只需更换工厂对象，就能切换整个产品系列。

### 代码结构

```
抽象工厂模式包含4个角色：
1. 抽象产品（Abstract Product）：定义产品的接口
2. 具体产品（Concrete Product）：实现具体的产品
3. 抽象工厂（Abstract Factory）：声明创建产品的方法
4. 具体工厂（Concrete Factory）：实现创建具体产品的方法
```

### 现实生活中的例子

1. **主题换肤**：一套蓝色主题（蓝色按钮、蓝色边框、蓝色背景） vs 一套红色主题

2. **游戏风格**：中世纪风格（骑士、城堡、剑） vs 科幻风格（宇航员、飞船、激光枪）

3. **跨平台开发**：Windows风格控件 vs Mac风格控件

### 优点

1. **保证产品兼容性**：同一家族的产品能完美配合
2. **切换方便**：只需更换工厂，就能切换整个产品系列
3. **符合开闭原则**：添加新产品族很容易
4. **符合单一职责**：每个工厂只负责创建相关产品

### 抽象工厂 vs 工厂方法

| 工厂方法           | 抽象工厂               |
| ------------------ | ---------------------- |
| 创建一种产品       | 创建一套相关产品       |
| 通过子类化创建对象 | 通过对象组合创建产品族 |
| 关注产品创建       | 关注产品家族创建       |
| 适合产品种类单一   | 适合产品系列切换       |

## 实际应用示例：游戏中的武器系统

```cpp
// 游戏中的武器家族：中世纪 vs 现代

// 抽象产品：武器
class Weapon {
public:
    virtual void attack() = 0;
    virtual ~Weapon() {}
};

// 抽象产品：防具
class Armor {
public:
    virtual void defend() = 0;
    virtual ~Armor() {}
};

// 抽象工厂：装备工厂
class EquipmentFactory {
public:
    virtual Weapon* createWeapon() = 0;
    virtual Armor* createArmor() = 0;
    virtual ~EquipmentFactory() {}
};

// 中世纪装备
class Sword : public Weapon {
public:
    void attack() override { cout << "⚔️ 用剑攻击" << endl; }
};

class Shield : public Armor {
public:
    void defend() override { cout << "🛡️ 用盾牌防御" << endl; }
};

class MedievalFactory : public EquipmentFactory {
public:
    Weapon* createWeapon() override { return new Sword(); }
    Armor* createArmor() override { return new Shield(); }
};

// 现代装备
class Gun : public Weapon {
public:
    void attack() override { cout << "🔫 用枪射击" << endl; }
};

class BulletproofVest : public Armor {
public:
    void defend() override { cout << "🧥 用防弹衣防御" << endl; }
};

class ModernFactory : public EquipmentFactory {
public:
    Weapon* createWeapon() override { return new Gun(); }
    Armor* createArmor() override { return new BulletproofVest(); }
};

// 游戏角色
class GameCharacter {
private:
    EquipmentFactory* factory;
    
public:
    GameCharacter(EquipmentFactory* factory) : factory(factory) {}
    
    void equip() {
        Weapon* weapon = factory->createWeapon();
        Armor* armor = factory->createArmor();
        
        cout << "角色装备了：" << endl;
        weapon->attack();
        armor->defend();
        
        delete weapon;
        delete armor;
    }
};

// 使用
int main() {
    // 创建中世纪风格角色
    EquipmentFactory* medievalFactory = new MedievalFactory();
    GameCharacter knight(medievalFactory);
    cout << "中世纪骑士：" << endl;
    knight.equip();
    
    cout << "\n-------------------\n" << endl;
    
    // 创建现代风格角色
    EquipmentFactory* modernFactory = new ModernFactory();
    GameCharacter soldier(modernFactory);
    cout << "现代士兵：" << endl;
    soldier.equip();
    
    delete medievalFactory;
    delete modernFactory;
    return 0;
}
```

## 抽象工厂模式 vs 工厂方法模式


场景：要开一家披萨店连锁企业

工厂方法模式：特许经营模式

**概念**：总部规定做披萨的流程，但每家分店自己决定做什么风味的披萨。

**特点**：
- 每家分店只做**一种产品**（披萨）
- 但可以做不同风味的披萨
- 总部控制流程，分店控制风味

---

抽象工厂模式：品牌旗舰店模式

**概念**：总部开设不同品牌的旗舰店，每个品牌店提供一整套配套产品。

**特点**：
- 每个品牌店提供**一整套产品**（披萨+饮料+甜点）
- 产品之间风格协调配套
- 切换品牌就切换了整个产品系列

---

工厂方法模式：**垂直 specialization**
```
总部 → 各个分店
    ├─ 纽约店：专做纽约风味披萨
    ├─ 芝加哥店：专做芝加哥风味披萨
    └─ 加州店：专做加州风味披萨
```
**关注点**：一种产品的不同风味变体

抽象工厂模式：**水平 integration**
```
总部 → 各个品牌店
    ├─ 意大利店：意式披萨 + 葡萄酒 + 提拉米苏
    ├─ 美式店：美式披萨 + 可乐 + 芝士蛋糕
    └─ 墨式店：墨西哥披萨 + 龙舌兰 + 巧克力
```
**关注点**：多款产品的配套组合

---

| 方面         | 工厂方法模式           | 抽象工厂模式     |
| ------------ | ---------------------- | ---------------- |
| **创建什么** | 一种产品               | 一套相关产品     |
| **关注点**   | 产品类型的扩展         | 产品家族的兼容   |
| **实现方式** | 继承（子类化）         | 组合（接口实现） |
| **修改影响** | 添加新产品类型         | 添加新产品家族   |
| **适用场景** | 需要多种风味的单一产品 | 需要多款配套产品 |

---

工厂方法模式像：**汽车4S店**
- 宝马4S店：卖各种宝马车型（3系、5系、7系）
- 奔驰4S店：卖各种奔驰车型（C级、E级、S级）
- **只卖一个品牌，但多种车型**

抽象工厂模式像：**家居商城**
- 宜家专区：宜家沙发 + 宜家茶几 + 宜家衣柜
- 红星美凯龙专区：红木沙发 + 红木茶几 + 红木衣柜
- **提供一整套风格匹配的产品**

---


**核心思想**：保证同一家族的产品能够协调工作，轻松切换整个产品系列。

**使用时机**：
- 系统需要一系列相关的产品对象
- 需要保证产品之间的兼容性
- 希望隐藏具体产品的创建细节
- 需要轻松切换不同的产品系列

抽象工厂模式让代码更加灵活，能够轻松应对产品家族的切换需求！


抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

```cpp
#include <iostream>
#include <memory>

// 抽象产品A：按钮
class Button {
public:
    virtual void paint() = 0;
    virtual ~Button() = default;
};

// 抽象产品B：滚动条
class ScrollBar {
public:
    virtual void paint() = 0;
    virtual ~ScrollBar() = default;
};

// 具体产品：Windows风格按钮
class WinButton : public Button {
public:
    void paint() override {
        std::cout << "Painting Windows style button" << std::endl;
    }
};

// 具体产品：Windows风格滚动条
class WinScrollBar : public ScrollBar {
public:
    void paint() override {
        std::cout << "Painting Windows style scrollbar" << std::endl;
    }
};

// 具体产品：Mac风格按钮
class MacButton : public Button {
public:
    void paint() override {
        std::cout << "Painting Mac style button" << std::endl;
    }
};

// 具体产品：Mac风格滚动条
class MacScrollBar : public ScrollBar {
public:
    void paint() override {
        std::cout << "Painting Mac style scrollbar" << std::endl;
    }
};

// 抽象工厂
class GUIFactory {
public:
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<ScrollBar> createScrollBar() = 0;
    virtual ~GUIFactory() = default;
};

// 具体工厂：Windows工厂
class WinFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WinButton>();
    }
    
    std::unique_ptr<ScrollBar> createScrollBar() override {
        return std::make_unique<WinScrollBar>();
    }
};

// 具体工厂：Mac工厂
class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }
    
    std::unique_ptr<ScrollBar> createScrollBar() override {
        return std::make_unique<MacScrollBar>();
    }
};

// 客户端代码
class Application {
public:
    Application(std::unique_ptr<GUIFactory> factory) : factory(std::move(factory)) {}
    
    void createUI() {
        button = factory->createButton();
        scrollBar = factory->createScrollBar();
    }
    
    void paint() {
        button->paint();
        scrollBar->paint();
    }

private:
    std::unique_ptr<GUIFactory> factory;
    std::unique_ptr<Button> button;
    std::unique_ptr<ScrollBar> scrollBar;
};

// 使用示例
int main() {
    // 创建Windows风格的UI
    auto winFactory = std::make_unique<WinFactory>();
    Application winApp(std::move(winFactory));
    winApp.createUI();
    winApp.paint();
    
    std::cout << "-------------------" << std::endl;
    
    // 创建Mac风格的UI
    auto macFactory = std::make_unique<MacFactory>();
    Application macApp(std::move(macFactory));
    macApp.createUI();
    macApp.paint();
    
    return 0;
}
```