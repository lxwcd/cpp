C++ 设计模式

# 代理模式

代理模式是一种结构型设计模式，它提供了一个代理对象来控制对另一个对象的访问。简单来说，代理就像是真实对象的"替身"或"中介"，可以在不改变原始对象的情况下，增加额外的功能或控制访问。

想象一下要租房，但不直接联系房东，而是通过房产中介：
- 中介（代理）代表房东（真实对象）
- 中介可以筛选客户、提供额外服务（如看房、签合同）
- 你最终还是租到了房东的房子，但通过中介这个中间人

```cpp
#include <iostream>
#include <string>
#include <memory>

// 1. 定义接口
class Image {
public:
    virtual void display() = 0;
    virtual ~Image() = default;
};

// 2. 真实对象 - 实际加载和显示图片的类
class RealImage : public Image {
private:
    std::string filename;
    
    void loadFromDisk() {
        std::cout << "加载图片: " << filename << std::endl;
    }
    
public:
    RealImage(const std::string& filename) : filename(filename) {
        loadFromDisk();
    }
    
    void display() override {
        std::cout << "显示图片: " << filename << std::endl;
    }
};

// 3. 代理 - 控制对真实对象的访问
class ProxyImage : public Image {
private:
    std::string filename;
    std::unique_ptr<RealImage> realImage;
    
public:
    ProxyImage(const std::string& filename) : filename(filename), realImage(nullptr) {}
    
    void display() override {
        // 延迟初始化：只有在需要时才创建真实对象
        if (realImage == nullptr) {
            realImage = std::make_unique<RealImage>(filename);
        }
        // 可以在这里添加额外功能，如访问控制、日志记录等
        std::cout << "代理: 正在处理显示请求..." << std::endl;
        realImage->display();
        std::cout << "代理: 显示完成" << std::endl;
    }
};

// 使用示例
int main() {
    std::cout << "=== 代理模式示例 ===\n" << std::endl;
    
    // 创建代理对象，此时不会加载图片
    ProxyImage proxy("photo.jpg");
    
    std::cout << "\n图片尚未加载..." << std::endl;
    
    // 只有当调用display()时，才会实际加载图片
    std::cout << "\n第一次调用display():" << std::endl;
    proxy.display();
    
    std::cout << "\n第二次调用display():" << std::endl;
    // 这次不会重新加载图片，因为已经加载过了
    proxy.display();
    
    return 0;
}
```

输出结果

```
=== 代理模式示例 ===

图片尚未加载...

第一次调用display():
代理: 正在处理显示请求...
加载图片: photo.jpg
显示图片: photo.jpg
代理: 显示完成

第二次调用display():
代理: 正在处理显示请求...
显示图片: photo.jpg
代理: 显示完成
```

## 代理模式的优势

1. **延迟初始化**：只有在需要时才创建昂贵的对象
2. **访问控制**：代理可以验证权限后再决定是否调用真实对象
3. **额外功能**：可以在调用真实对象前后添加日志、缓存等额外功能
4. **远程代理**：可以代表位于不同地址空间的对象

## 其他类型的代理

- **虚拟代理**：延迟创建昂贵对象（如上例）
- **保护代理**：控制对敏感对象的访问
- **远程代理**：代表远程对象（如网络服务）
- **智能引用**：在访问对象时添加额外操作（如引用计数）

# 策略模式

策略模式是一种行为设计模式，它允许定义一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端。

想象一下要出行，可以选择不同的交通方式：
- 开车（一种策略）
- 坐公交（另一种策略）
- 骑自行车（又一种策略）

每种策略都能带你到达目的地，但各有不同的优缺点（时间、成本、舒适度等）。可以根据具体情况（天气、距离、预算）选择最合适的策略。

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 1. 策略接口：定义所有支持的算法的公共接口
class TravelStrategy {
public:
    virtual void travel(const std::string& from, const std::string& to) = 0;
    virtual ~TravelStrategy() = default;
};

// 2. 具体策略：实现不同的算法
class CarTravel : public TravelStrategy {
public:
    void travel(const std::string& from, const std::string& to) override {
        std::cout << "开车从 " << from << " 到 " << to 
                  << " - 时间灵活，成本中等" << std::endl;
    }
};

class BusTravel : public TravelStrategy {
public:
    void travel(const std::string& from, const std::string& to) override {
        std::cout << "坐公交从 " << from << " 到 " << to 
                  << " - 成本低，但时间固定" << std::endl;
    }
};

class BikeTravel : public TravelStrategy {
public:
    void travel(const std::string& from, const std::string& to) override {
        std::cout << "骑自行车从 " << from << " 到 " << to 
                  << " - 环保健康，但受天气影响" << std::endl;
    }
};

// 3. 上下文类：维护一个策略对象的引用
class TravelPlanner {
private:
    std::unique_ptr<TravelStrategy> strategy;
    
public:
    // 设置策略
    void setStrategy(std::unique_ptr<TravelStrategy> newStrategy) {
        strategy = std::move(newStrategy);
    }
    
    // 执行策略
    void executeTravel(const std::string& from, const std::string& to) {
        if (strategy) {
            strategy->travel(from, to);
        } else {
            std::cout << "请先选择出行方式!" << std::endl;
        }
    }
};

// 使用示例
int main() {
    std::cout << "=== 策略模式示例：出行规划 ===" << std::endl;
    
    TravelPlanner planner;
    std::string from = "家";
    std::string to = "公司";
    
    // 选择不同的策略
    std::cout << "\n1. 晴天出行：" << std::endl;
    planner.setStrategy(std::make_unique<BikeTravel>());
    planner.executeTravel(from, to);
    
    std::cout << "\n2. 雨天出行：" << std::endl;
    planner.setStrategy(std::make_unique<CarTravel>());
    planner.executeTravel(from, to);
    
    std::cout << "\n3. 节省开支：" << std::endl;
    planner.setStrategy(std::make_unique<BusTravel>());
    planner.executeTravel(from, to);
    
    // 动态改变策略
    std::cout << "\n4. 动态改变策略：" << std::endl;
    std::cout << "开始骑自行车..." << std::endl;
    planner.setStrategy(std::make_unique<BikeTravel>());
    planner.executeTravel(from, "中途点");
    
    std::cout << "改为坐公交..." << std::endl;
    planner.setStrategy(std::make_unique<BusTravel>());
    planner.executeTravel("中途点", to);
    
    return 0;
}
```

输出结果

```
=== 策略模式示例：出行规划 ===

1. 晴天出行：
骑自行车从 家 到 公司 - 环保健康，但受天气影响

2. 雨天出行：
开车从 家 到 公司 - 时间灵活，成本中等

3. 节省开支：
坐公交从 家 到 公司 - 成本低，但时间固定

4. 动态改变策略：
开始骑自行车...
骑自行车从 家 到 中途点 - 环保健康，但受天气影响
改为坐公交...
坐公交从 中途点 到 公司 - 成本低，但时间固定
```

## 策略模式的优势

1. **开闭原则**：无需修改上下文就能引入新策略
2. **消除条件语句**：避免使用大量的条件判断语句（if-else或switch）
3. **代码复用**：可以在多个上下文中复用策略
4. **运行时切换**：可以在运行时动态改变对象的行为

## 适用场景

1. 当有多个类似的类，只在行为上有所不同时
2. 当一个类有多种行为变体，使用条件语句难以维护时
3. 当需要隔离算法的实现细节和使用逻辑时
4. 当类有多种行为，且这些行为在类的操作中频繁切换时

# 观察者模式

观察者模式是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象状态发生变化时，它会通知所有观察者对象，使它们能够自动更新。

想象一下报纸订阅服务：
- 报社（主题）出版报纸
- 订阅者（观察者）注册接收报纸
- 当新报纸出版时，所有订阅者会自动收到报纸
- 订阅者可以随时取消订阅，不再接收报纸

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <memory>

// 前向声明
class IObserver;

// 1. 主题接口
class ISubject {
public:
    virtual void attach(std::shared_ptr<IObserver> observer) = 0;
    virtual void detach(std::shared_ptr<IObserver> observer) = 0;
    virtual void notify() = 0;
    virtual ~ISubject() = default;
};

// 2. 观察者接口
class IObserver {
public:
    virtual void update(const std::string& message) = 0;
    virtual ~IObserver() = default;
};

// 3. 具体主题 - 新闻发布器
class NewsPublisher : public ISubject {
private:
    std::vector<std::shared_ptr<IObserver>> observers;
    std::string news;

public:
    void attach(std::shared_ptr<IObserver> observer) override {
        observers.push_back(observer);
    }

    void detach(std::shared_ptr<IObserver> observer) override {
        observers.erase(
            std::remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }

    void notify() override {
        for (auto& observer : observers) {
            observer->update(news);
        }
    }

    void setNews(const std::string& newNews) {
        news = newNews;
        std::cout << "新闻社: 发布了新新闻 - " << news << std::endl;
        notify(); // 通知所有观察者
    }
};

// 4. 具体观察者 - 新闻订阅者
class NewsSubscriber : public IObserver, public std::enable_shared_from_this<NewsSubscriber> {
private:
    std::string name;
    std::shared_ptr<ISubject> subject;

public:
    NewsSubscriber(const std::string& name, std::shared_ptr<ISubject> sub) 
        : name(name), subject(sub) {
        // 自动订阅
        subject->attach(shared_from_this());
        std::cout << name << " 订阅了新闻" << std::endl;
    }

    ~NewsSubscriber() {
        // 自动取消订阅
        if (subject) {
            subject->detach(shared_from_this());
            std::cout << name << " 取消订阅了新闻" << std::endl;
        }
    }

    void update(const std::string& message) override {
        std::cout << name << " 收到新闻: " << message << std::endl;
    }

    void unsubscribe() {
        subject.reset(); // 释放对主题的引用，触发取消订阅
    }
};

// 使用示例
int main() {
    std::cout << "=== 观察者模式示例：新闻订阅系统 ===\n" << std::endl;
    
    // 创建新闻发布器
    auto publisher = std::make_shared<NewsPublisher>();
    
    // 创建订阅者
    auto subscriber1 = std::make_shared<NewsSubscriber>("张三", publisher);
    auto subscriber2 = std::make_shared<NewsSubscriber>("李四", publisher);
    auto subscriber3 = std::make_shared<NewsSubscriber>("王五", publisher);
    
    std::cout << "\n--- 发布第一条新闻 ---" << std::endl;
    publisher->setNews("C++23新特性发布!");
    
    std::cout << "\n--- 发布第二条新闻 ---" << std::endl;
    publisher->setNews("人工智能新突破!");
    
    std::cout << "\n--- 李四取消订阅 ---" << std::endl;
    subscriber2->unsubscribe();
    
    std::cout << "\n--- 发布第三条新闻 ---" << std::endl;
    publisher->setNews("量子计算机新进展!");
    
    std::cout << "\n--- 程序结束，自动取消所有订阅 ---" << std::endl;
    return 0;
}
```

输出结果

```
=== 观察者模式示例：新闻订阅系统 ===

张三 订阅了新闻
李四 订阅了新闻
王五 订阅了新闻

--- 发布第一条新闻 ---
新闻社: 发布了新新闻 - C++23新特性发布!
张三 收到新闻: C++23新特性发布!
李四 收到新闻: C++23新特性发布!
王五 收到新闻: C++23新特性发布!

--- 发布第二条新闻 ---
新闻社: 发布了新新闻 - 人工智能新突破!
张三 收到新闻: 人工智能新突破!
李四 收到新闻: 人工智能新突破!
王五 收到新闻: 人工智能新突破!

--- 李四取消订阅 ---
李四 取消订阅了新闻

--- 发布第三条新闻 ---
新闻社: 发布了新新闻 - 量子计算机新进展!
张三 收到新闻: 量子计算机新进展!
王五 收到新闻: 量子计算机新进展!

--- 程序结束，自动取消所有订阅 ---
张三 取消订阅了新闻
王五 取消订阅了新闻
```

## 观察者模式的优势

1. **松耦合**：主题和观察者之间是松耦合的，主题不需要知道观察者的具体类
2. **动态关系**：可以在运行时动态添加和删除观察者
3. **广播通信**：主题的变化会自动通知所有观察者
4. **遵循开闭原则**：可以引入新的观察者类而不修改主题

## 适用场景

1. 当一个对象的状态变化需要通知其他对象，但又不知道这些对象是谁时
2. 当一个对象需要通知其他对象，但又希望与它们保持松耦合时
3. 当系统中有多个对象依赖于一个对象的状态时
4. 例如：GUI事件处理、消息队列、发布-订阅系统等

## 注意事项

1. 需要注意观察者的更新顺序，有时顺序很重要
2. 如果观察者处理时间过长，可能会影响主题的性能
3. 需要小心循环引用问题，特别是在使用智能指针时

# 桥接模式

桥接模式是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立变化。这种模式通过提供一个桥接结构来实现这种分离，而不是使用继承。

想象一下电视和遥控器的关系：
- 电视（实现部分）：提供基本功能（开机、关机、换台等）
- 遥控器（抽象部分）：提供用户接口，控制电视
- 不同的电视（索尼、三星、小米）可以用同一个遥控器接口控制
- 不同的遥控器（普通遥控器、语音遥控器、手机App）可以控制同一台电视

桥接模式就像是在电视和遥控器之间建立了一座"桥梁"，让它们可以独立发展和变化。

## 示例

```cpp
#include <iostream>
#include <memory>
#include <string>

// 1. 实现部分接口：电视功能
class TVImplementation {
public:
    virtual void on() = 0;
    virtual void off() = 0;
    virtual void tuneChannel(int channel) = 0;
    virtual ~TVImplementation() = default;
};

// 2. 具体实现：索尼电视
class SonyTV : public TVImplementation {
public:
    void on() override {
        std::cout << "索尼电视开机" << std::endl;
    }
    
    void off() override {
        std::cout << "索尼电视关机" << std::endl;
    }
    
    void tuneChannel(int channel) override {
        std::cout << "索尼电视切换到频道 " << channel << std::endl;
    }
};

// 3. 具体实现：三星电视
class SamsungTV : public TVImplementation {
public:
    void on() override {
        std::cout << "三星电视开机" << std::endl;
    }
    
    void off() override {
        std::cout << "三星电视关机" << std::endl;
    }
    
    void tuneChannel(int channel) override {
        std::cout << "三星电视切换到频道 " << channel << std::endl;
    }
};

// 4. 抽象部分：遥控器
class RemoteControl {
protected:
    std::shared_ptr<TVImplementation> tv;
    
public:
    RemoteControl(std::shared_ptr<TVImplementation> tvImpl) : tv(tvImpl) {}
    
    virtual void turnOn() {
        tv->on();
    }
    
    virtual void turnOff() {
        tv->off();
    }
    
    virtual void setChannel(int channel) {
        tv->tuneChannel(channel);
    }
    
    virtual ~RemoteControl() = default;
};

// 5. 扩展抽象：高级遥控器
class AdvancedRemoteControl : public RemoteControl {
public:
    AdvancedRemoteControl(std::shared_ptr<TVImplementation> tvImpl) 
        : RemoteControl(tvImpl) {}
    
    void mute() {
        std::cout << "高级功能：静音" << std::endl;
    }
    
    void setChannel(int channel) override {
        std::cout << "高级遥控器正在切换频道..." << std::endl;
        tv->tuneChannel(channel);
    }
};

// 6. 扩展抽象：语音遥控器
class VoiceRemoteControl : public RemoteControl {
public:
    VoiceRemoteControl(std::shared_ptr<TVImplementation> tvImpl) 
        : RemoteControl(tvImpl) {}
    
    void voiceCommand(const std::string& command) {
        std::cout << "语音命令: \"" << command << "\"" << std::endl;
        if (command.find("频道") != std::string::npos) {
            // 简单解析频道号
            int channel = 1; // 默认频道
            setChannel(channel);
        } else if (command.find("开机") != std::string::npos) {
            turnOn();
        } else if (command.find("关机") != std::string::npos) {
            turnOff();
        }
    }
};

// 使用示例
int main() {
    std::cout << "=== 桥接模式示例：电视遥控系统 ===\n" << std::endl;
    
    // 创建不同的电视（实现部分）
    auto sonyTV = std::make_shared<SonyTV>();
    auto samsungTV = std::make_shared<SamsungTV>();
    
    // 创建不同的遥控器（抽象部分）并连接到电视
    std::cout << "1. 普通遥控器控制索尼电视:" << std::endl;
    RemoteControl basicRemote(sonyTV);
    basicRemote.turnOn();
    basicRemote.setChannel(5);
    basicRemote.turnOff();
    
    std::cout << "\n2. 高级遥控器控制三星电视:" << std::endl;
    AdvancedRemoteControl advancedRemote(samsungTV);
    advancedRemote.turnOn();
    advancedRemote.setChannel(8);
    advancedRemote.mute();
    advancedRemote.turnOff();
    
    std::cout << "\n3. 语音遥控器控制索尼电视:" << std::endl;
    VoiceRemoteControl voiceRemote(sonyTV);
    voiceRemote.voiceCommand("开机");
    voiceRemote.voiceCommand("切换到频道3");
    voiceRemote.voiceCommand("关机");
    
    std::cout << "\n4. 切换电视:" << std::endl;
    std::cout << "将语音遥控器切换到三星电视:" << std::endl;
    // 注意：实际中可能需要重新设置tv引用，这里为了简单直接创建新对象
    VoiceRemoteControl voiceRemote2(samsungTV);
    voiceRemote2.voiceCommand("开机");
    
    return 0;
}
```

输出结果

```
=== 桥接模式示例：电视遥控系统 ===

1. 普通遥控器控制索尼电视:
索尼电视开机
索尼电视切换到频道 5
索尼电视关机

2. 高级遥控器控制三星电视:
三星电视开机
高级遥控器正在切换频道...
三星电视切换到频道 8
高级功能：静音
三星电视关机

3. 语音遥控器控制索尼电视:
语音命令: "开机"
索尼电视开机
语音命令: "切换到频道3"
索尼电视切换到频道 1
语音命令: "关机"
索尼电视关机

4. 切换电视:
将语音遥控器切换到三星电视:
语音命令: "开机"
三星电视开机
```

## 桥接模式的优势

1. **分离抽象和实现**：抽象和实现可以独立扩展，不会相互影响
2. **提高可扩展性**：可以独立地扩展抽象部分和实现部分
3. **减少子类数量**：避免了使用继承导致的类爆炸问题
4. **实现细节对客户透明**：客户端只需要与抽象接口交互

## 适用场景

1. 当一个类存在两个独立变化的维度，且这两个维度都需要扩展时
2. 当需要在多个对象之间共享实现时
3. 当需要运行时切换实现时
4. 当不希望使用继承导致类层次结构过于复杂时

## 桥接模式与适配器模式的区别

- **桥接模式**：设计之初就考虑将抽象和实现分离，让它们可以独立变化
- **适配器模式**：是在设计完成后，为了让不兼容的接口能够一起工作

# 组合

组合模式是一种结构型设计模式，它允许你将对象组合成树形结构来表示"部分-整体"的层次结构。组合模式使得客户端可以统一地处理单个对象和组合对象。

想象一下文件系统的结构：
- 文件（叶子节点）：不能再包含其他内容
- 文件夹（组合节点）：可以包含文件和其他文件夹
- 可以对单个文件执行操作，也可以对整个文件夹执行相同的操作（如计算大小、复制、删除）

组合模式就像是一个组织架构图，其中每个部分（员工）和整体（部门）都可以被统一对待。

## 示例

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <string>
#include <algorithm>

// 1. 组件接口：定义叶子和容器的共同操作
class FileSystemComponent {
public:
    virtual void display(int depth = 0) const = 0;
    virtual int getSize() const = 0;
    virtual void add(std::shared_ptr<FileSystemComponent> component) {
        // 默认实现，叶子节点会忽略这个操作
    }
    virtual void remove(std::shared_ptr<FileSystemComponent> component) {
        // 默认实现，叶子节点会忽略这个操作
    }
    virtual ~FileSystemComponent() = default;
};

// 2. 叶子节点：文件
class File : public FileSystemComponent {
private:
    std::string name;
    int size;
    
public:
    File(const std::string& name, int size) : name(name), size(size) {}
    
    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout << indent << "📄 " << name << " (" << size << " KB)" << std::endl;
    }
    
    int getSize() const override {
        return size;
    }
};

// 3. 组合节点：文件夹
class Folder : public FileSystemComponent {
private:
    std::string name;
    std::vector<std::shared_ptr<FileSystemComponent>> children;
    
public:
    Folder(const std::string& name) : name(name) {}
    
    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout << indent << "📁 " << name << " (" << getSize() << " KB)" << std::endl;
        
        // 递归显示所有子组件
        for (const auto& child : children) {
            child->display(depth + 1);
        }
    }
    
    int getSize() const override {
        int totalSize = 0;
        for (const auto& child : children) {
            totalSize += child->getSize();
        }
        return totalSize;
    }
    
    void add(std::shared_ptr<FileSystemComponent> component) override {
        children.push_back(component);
    }
    
    void remove(std::shared_ptr<FileSystemComponent> component) override {
        children.erase(
            std::remove(children.begin(), children.end(), component),
            children.end()
        );
    }
};

// 使用示例
int main() {
    std::cout << "=== 组合模式示例：文件系统 ===\n" << std::endl;
    
    // 创建文件（叶子节点）
    auto file1 = std::make_shared<File>("document.txt", 100);
    auto file2 = std::make_shared<File>("image.jpg", 500);
    auto file3 = std::make_shared<File>("video.mp4", 2000);
    auto file4 = std::make_shared<File>("readme.md", 5);
    auto file5 = std::make_shared<File>("code.cpp", 50);
    
    // 创建文件夹（组合节点）
    auto root = std::make_shared<Folder>("Root");
    auto documents = std::make_shared<Folder>("Documents");
    auto media = std::make_shared<Folder>("Media");
    auto videos = std::make_shared<Folder>("Videos");
    
    // 构建树形结构
    root->add(documents);
    root->add(media);
    
    documents->add(file1);
    documents->add(file4);
    documents->add(file5);
    
    media->add(file2);
    media->add(videos);
    
    videos->add(file3);
    
    // 显示整个文件系统
    std::cout << "文件系统结构:" << std::endl;
    root->display();
    
    std::cout << "\n--- 计算总大小 ---" << std::endl;
    std::cout << "根目录总大小: " << root->getSize() << " KB" << std::endl;
    std::cout << "文档文件夹大小: " << documents->getSize() << " KB" << std::endl;
    std::cout << "媒体文件夹大小: " << media->getSize() << " KB" << std::endl;
    std::cout << "视频文件夹大小: " << videos->getSize() << " KB" << std::endl;
    std::cout << "单个文件大小: " << file1->getSize() << " KB" << std::endl;
    
    // 添加新文件
    std::cout << "\n--- 添加新文件 ---" << std::endl;
    auto newFile = std::make_shared<File>("newfile.dat", 300);
    media->add(newFile);
    
    std::cout << "添加文件后媒体文件夹大小: " << media->getSize() << " KB" << std::endl;
    
    // 统一操作：删除所有组件
    std::cout << "\n--- 删除操作 ---" << std::endl;
    // 注意：实际应用中会有更复杂的删除逻辑
    // 这里只是演示组合模式的概念
    
    return 0;
}
```

输出结果

```
=== 组合模式示例：文件系统 ===

文件系统结构:
📁 Root (2655 KB)
  📁 Documents (155 KB)
    📄 document.txt (100 KB)
    📄 readme.md (5 KB)
    📄 code.cpp (50 KB)
  📁 Media (2500 KB)
    📄 image.jpg (500 KB)
    📁 Videos (2000 KB)
      📄 video.mp4 (2000 KB)

--- 计算总大小 ---
根目录总大小: 2655 KB
文档文件夹大小: 155 KB
媒体文件夹大小: 2500 KB
视频文件夹大小: 2000 KB
单个文件大小: 100 KB

--- 添加新文件 ---
添加文件后媒体文件夹大小: 2800 KB

--- 删除操作 ---
```

## 组合模式的优势

1. **统一处理**：客户端可以一致地处理单个对象和组合对象
2. **简化客户端代码**：客户端不需要知道处理的是单个对象还是组合对象
3. **易于扩展**：可以很容易地添加新的组件类型
4. **递归组合**：可以构建复杂的树形结构

## 适用场景

1. 当需要表示对象的部分-整体层次结构时
2. 当希望客户端忽略组合对象与单个对象的差异时
3. 当需要处理树形结构数据时
4. 例如：文件系统、GUI组件、组织架构、菜单系统等

## 组合模式的变体

1. **透明模式**：在组件接口中声明所有方法，叶子节点对不支持的方法提供空实现或抛出异常
2. **安全模式**：只在组合节点中声明管理子组件的方法，叶子节点不包含这些方法

## 注意事项

1. 设计组件接口时要小心，确保它适合所有类型的组件
2. 有时需要在组件中添加父节点的引用，以便向上遍历
3. 缓存组合对象的信息（如大小）可以提高性能，但需要确保数据的一致性t 