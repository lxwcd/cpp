C++ 学习笔记

# class
> [Classes - cppreference.com](https://en.cppreference.com/w/cpp/language/classes) 

## class declaration
> [Class declaration - cppreference.com](https://en.cppreference.com/w/cpp/language/class) 

## polymorphic
> [Object - cppreference.com](https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects) 

A class with at least one declared or inherited virtual member function is polymorphic. Objects of this type are polymorphic objects and have runtime type information stored as part of the object representation, which may be queried with dynamic_cast and typeid. Virtual member functions participate in dynamic binding.

在C++中，多态的关键在于虚函数的动态绑定。当一个虚函数在父类中被声明，并在子类中被重写时，通过基类指针或引用调用该函数时，会根据对象的实际类型来决定调用哪个版本的函数。这个决策是在运行时进行的，这个过程称为动态多态。

如果子类未实现某个虚函数，那么默认会使用父类的实现。但是，如果父类中的虚函数调用了另一个虚函数，而这个虚函数在子类中有实现，那么即使第一个虚函数是在父类中调用的，只要调用链中的最后一个函数在子类中有重写，那么就会调用子类的实现。

见下面是一个的示例：
```cpp
#include <iostream>

// 父类
class Base {
public:
    // 虚函数vfunc1
    virtual void vfunc1() {
        std::cout << "Base::vfunc1 called" << std::endl;
        vfunc2(); // 调用虚函数vfunc2
    }

    // 虚函数vfunc2
    virtual void vfunc2() {
        std::cout << "Base::vfunc2 called" << std::endl;
    }
};

// 子类
class Derived : public Base {
public:
    // 重写虚函数vfunc2
    void vfunc2() override {
        std::cout << "Derived::vfunc2 called" << std::endl;
    }
};

int main() {
    Base* b = new Derived(); // 基类指针指向派生类对象
    b->vfunc1(); // 调用vfunc1，会调用派生类的vfunc2
    delete b;
    return 0;
}
```

在这个示例中：

1. `Base`类有两个虚函数`vfunc1`和`vfunc2`。
2. `Derived`类继承自`Base`类，并重写了`vfunc2`函数。
3. 在`main`函数中，我们创建了一个`Derived`类型的对象，但是通过`Base`类型的指针`b`来访问它。
4. 当调用`b->vfunc1()`时，虽然`vfunc1`是在`Base`类中定义的，但是它会调用`vfunc2`。
5. 由于`vfunc2`在`Derived`类中有重写，即使`vfunc1`的调用是在`Base`类中发起的，`vfunc2`的调用也会使用`Derived`类的实现。

输出：
```cpp
Base::vfunc1 called
Derived::vfunc2 called
```

## constuctor
> [Constructors and member initializer lists - cppreference.com](https://en.cppreference.com/w/cpp/language/constructor) 

- Constructors have no names and cannot be called directly. 

### Member initializer list
> [Constructors and member initializer lists - cppreference.com](https://en.cppreference.com/w/cpp/language/constructor) 

### 成员变量的初始化
> [Default-initialization - cppreference.com](https://en.cppreference.com/w/cpp/language/default_initialization) 

类的非静态成员变量，在类定义时如果没有给初始化值，并且在构造函数初始化列表中也没有赋值，则会进行 default initialization。
对于基本数据类型，默认初始化是未定义的值。
如果是数组，则数组的每个元素都进行默认初始化，如果数组的元素为基本类型，如 int 等，默认初始化则其值是未定义的。

### 构造顺序
> [Constructors and member initializer lists - cppreference.com](https://en.cppreference.com/w/cpp/language/constructor#Initialization_order) 

The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:
1) If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists).
2) Then, direct bases are initialized in left-to-right order as they appear in this class's base-specifier list.
3) Then, non-static data member are initialized in order of declaration in the class definition.
4) Finally, the body of the constructor is executed.
(Note: if initialization order was controlled by the appearance in the member initializer lists of different constructors, then the destructor wouldn't be able to ensure that the order of destruction is the reverse of the order of construction.)

C++ 支持多重继承，即一个类可以同时继承多个基类。构造函数的调用顺序遵循以下规则：
1. 按照基类声明顺序调用构造函数
2. 按照成员变量声明顺序初始化成员
3. 最后执行派生类自身的构造函数

```cpp
#include <iostream>
#include <string>
using namespace std;

// 基类1
class Base1 {
public:
    Base1() {
        cout << "Base1 构造函数被调用" << endl;
    }
    
    ~Base1() {
        cout << "Base1 析构函数被调用" << endl;
    }
};

// 基类2
class Base2 {
public:
    Base2() {
        cout << "Base2 构造函数被调用" << endl;
    }
    
    ~Base2() {
        cout << "Base2 析构函数被调用" << endl;
    }
};

// 基类3
class Base3 {
public:
    Base3() {
        cout << "Base3 构造函数被调用" << endl;
    }
    
    ~Base3() {
        cout << "Base3 析构函数被调用" << endl;
    }
};

// 成员类
class Member {
public:
    Member(const string& name) : name(name) {
        cout << "Member " << name << " 构造函数被调用" << endl;
    }
    
    ~Member() {
        cout << "Member " << name << " 析构函数被调用" << endl;
    }
    
private:
    string name;
};

// 派生类，继承多个基类
class Derived : public Base2, public Base1, public Base3 {
public:
    Derived() : m3("3"), m1("1"), m2("2") {
        cout << "Derived 构造函数被调用" << endl;
    }
    
    ~Derived() {
        cout << "Derived 析构函数被调用" << endl;
    }
    
private:
    // 成员变量
    Member m1;
    Member m2;
    Member m3;
};

int main() {
    cout << "创建 Derived 对象..." << endl;
    Derived derived;
    
    cout << "\nDerived 对象即将离开作用域..." << endl;
    return 0;
}
```

1. **多重继承**：`Derived` 类同时继承 `Base2`、`Base1` 和 `Base3`
2. **构造函数顺序**：
   - 基类构造函数按照继承列表中声明的顺序调用（Base2 → Base1 → Base3）
   - 成员变量按照在类中声明的顺序初始化（m1 → m2 → m3）
   - 最后调用派生类自身的构造函数
3. **析构函数顺序**：与构造函数顺序相反

运行此程序将输出：
```
创建 Derived 对象...
Base2 构造函数被调用
Base1 构造函数被调用
Base3 构造函数被调用
Member 1 构造函数被调用
Member 2 构造函数被调用
Member 3 构造函数被调用
Derived 构造函数被调用

Derived 对象即将离开作用域...
Derived 析构函数被调用
Member 3 析构函数被调用
Member 2 析构函数被调用
Member 1 析构函数被调用
Base3 析构函数被调用
Base1 析构函数被调用
Base2 析构函数被调用
```

### explicit 
> [explicit specifier - cppreference.com](https://en.cppreference.com/w/cpp/language/explicit) 

在 C++ 中，`explicit` 关键字用于类中的构造函数，它阻止了编译器使用该构造函数进行类型转换。这可以防止编译器在某些情况下进行隐式转换，从而提高代码的清晰度和安全性。

1. **防止隐式转换**：当一个类的构造函数被标记为 `explicit` 时，它不能用于隐式转换。这意味着编译器不会自动将一个对象转换成该类型的实例，除非显式地进行转换。

2. **提高代码清晰度**：通过阻止隐式转换，`explicit` 关键字使得代码的意图更加明确，减少了因隐式转换引起的意外错误。

3. **增强类型安全**：`explicit` 关键字可以防止编译器在不适当的时候进行类型转换，从而增强了程序的类型安全性。

The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor or conversion function(since C++11) within its class definition.

1. **构造函数**：当有一个构造函数时，如果不希望它被用于隐式转换，可以将其标记为 `explicit`。

   ```cpp
   class MyClass {
   public:
       explicit MyClass(int value) : m_value(value) {}
   private:
       int m_value;
   };
   ```

   在这个例子中，`MyClass` 的构造函数是显式的，因此不能在需要 `MyClass` 类型的地方隐式地使用 `int` 类型的值。

2. **转换运算符**：如果不希望类提供隐式转换功能，可以将转换运算符声明为 `explicit`。

   ```cpp
   class MyClass {
   public:
       explicit operator bool() const { return m_value != 0; }
   private:
       int m_value;
   };
   ```

   在这个例子中，`MyClass` 类型的实例不能隐式地转换为 `bool` 类型。

#### 示例
```cpp
struct A
{
    A(int) {}      // converting constructor
    A(int, int) {} // converting constructor (C++11)
    operator bool() const { return true; }
};
 
struct B
{
    explicit B(int) {}
    explicit B(int, int) {}
    explicit operator bool() const { return true; }
};
 
int main()
{
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    if (a1) { }    // OK: A::operator bool()
    bool na1 = a1; // OK: copy-initialization selects A::operator bool()
    bool na2 = static_cast<bool>(a1); // OK: static_cast performs direct-initialization
 
//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)
    B b2(2);       // OK: direct-initialization selects B::B(int)
    B b3 {4, 5};   // OK: direct-list-initialization selects B::B(int, int)
//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int, int)
    B b5 = (B)1;   // OK: explicit cast performs static_cast
    if (b2) { }    // OK: B::operator bool()
//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()
    bool nb2 = static_cast<bool>(b2); // OK: static_cast performs direct-initialization
 
    [](...){}(a4, a5, na1, na2, b5, nb2); // suppresses “unused variable” warnings
}
```

### converting constructor
> [Converting constructor - cppreference.com](https://en.cppreference.com/w/cpp/language/converting_constructor) 

A constructor that is not declared with the specifier explicit and which can be called with a single parameter(until C++11) is called a converting constructor.

Unlike explicit constructors, which are only considered during direct initialization (which includes explicit conversions such as static_cast), converting constructors are also considered during copy initialization, as part of user-defined conversion sequence.

It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Note that non-explicit user-defined conversion function also specifies an implicit conversion.

Implicitly-declared and user-defined non-explicit copy constructors and move constructors are converting constructors.

转换构造函数是C++中一种特殊的构造函数，它允许编译器在需要时自动将一种类型转换为类类型。

```cpp
struct A
{
    A() { }         // converting constructor (since C++11)  
    A(int) { }      // converting constructor
    A(int, int) { } // converting constructor (since C++11)
};
 
struct B
{
    explicit B() { }
    explicit B(int) { }
    explicit B(int, int) { }
};
 
int main()
{
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3{4, 5};    // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast, direct-initialization
 
//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)
    B b2(2);       // OK: direct-initialization selects B::B(int)
    B b3{4, 5};    // OK: direct-list-initialization selects B::B(int, int)
//  B b4 = {4, 5}; // error: copy-list-initialization selected an explicit constructor
                   //        B::B(int, int)
    B b5 = (B)1;   // OK: explicit cast performs static_cast, direct-initialization
    B b6;          // OK, default-initialization
    B b7{};        // OK, direct-list-initialization
//  B b8 = {};     // error: copy-list-initialization selected an explicit constructor
                   //        B::B()
 
    [](...){}(a1, a4, a4, a5, b5); // may suppress "unused variable" warnings
}
```

### default constructor
> [Default constructors - cppreference.com](https://en.cppreference.com/w/cpp/language/default_constructor) 

A default constructor is a constructor which can be called with no arguments.

Default constructors are called during default initializations and value initializations.

If there is no user-declared constructor or constructor template for a class type, the compiler will implicitly declare a default constructor as an inline public member of its class.

默认构造函数是 C++ 类中一种特殊的构造函数，它不接受任何参数。它的主要作用是在创建对象时初始化对象的成员变量。如果一个类中没有显式定义任何构造函数，编译器会隐式地生成一个默认构造函数。这个默认构造函数的行为取决于类中的成员变量。

1. **成员初始化**：
   - 如果成员变量是基本数据类型（如 `int`、`double` 等），它们不会被自动初始化为零。这意味着它们会被初始化为一个未定义的值。
   - 如果成员变量是类类型，那么它们的默认构造函数（如果存在）会被调用。
   - 如果成员变量是指针类型，它们会被初始化为 `nullptr`。

2. **隐式定义**：
   - 如果类中定义了任何显式的构造函数，编译器不会自动生成默认构造函数，除非显式地使用 `default` 关键字标记。

3. **调用顺序**：
   - 首先调用基类的默认构造函数（如果有的话）。
   - 然后按照成员变量在类中声明的顺序调用它们的构造函数。

#### 使用 `default` 关键字
在 C++11 及以后的版本中，可以使用 `default` 关键字显式要求编译器生成默认构造函数。这在类中已经定义了其他构造函数时特别有用，例如：

```cpp
class MyClass {
public:
    MyClass() = default; // 显式要求编译器生成默认构造函数
};
```

#### 默认构造函数与对象数组
当声明一个对象数组时，如 `MyClass myObjects[10];`，编译器会调用默认构造函数来初始化数组中的每个元素。

#### 示例
```cpp
struct A
{
    int x;
    A(int x = 1): x(x) {} // user-defined default constructor
};
 
struct B : A
{
    // B::B() is implicitly-defined, calls A::A()
};
 
struct C
{
    A a;
    // C::C() is implicitly-defined, calls A::A()
};
 
struct D : A
{
    D(int y) : A(y) {}
    // D::D() is not declared because another constructor exists
};
 
struct E : A
{
    E(int y) : A(y) {}
    E() = default; // explicitly defaulted, calls A::A()
};
 
struct F
{
    int& ref; // reference member
    const int c; // const member
    // F::F() is implicitly defined as deleted
};
 
// user declared copy constructor (either user-provided, deleted or defaulted)
// prevents the implicit generation of a default constructor
 
struct G
{
    G(const G&) {}
    // G::G() is implicitly defined as deleted
};
 
struct H
{
    H(const H&) = delete;
    // H::H() is implicitly defined as deleted
};
 
struct I
{
    I(const I&) = default;
    // I::I() is implicitly defined as deleted
};
 
int main()
{
    A a;
    B b;
    C c;
//  D d; // compile error
    E e;
//  F f; // compile error
//  G g; // compile error
//  H h; // compile error
//  I i; // compile error
}
```

### copy constructor
> [Copy constructors - cppreference.com](https://en.cppreference.com/w/cpp/language/copy_constructor) 
> [Copy Constructor in C++ - GeeksforGeeks](https://www.geeksforgeeks.org/copy-constructor-in-cpp/) 

A copy constructor is a constructor which can be called with an argument of the same class type and copies the content of the argument without mutating the argument.

If no user-defined copy constructors are provided for a class type, the compiler will always declare a copy constructor as a non-explicit inline public member of its class. 

A class can have multiple copy constructors, e.g. both T::T(const T&) and T::T(T&).

The copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization) from another object of the same type (unless overload resolution selects a better match or the call is elided), which includes: 
- initialization: T a = b; or T a(b);, where b is of type T;
- function argument passing: f(a);, where a is of type T and f is void f(T t);
- function return: return a; inside a function such as T f(), where a is of type T, which has no move constructor.

```cpp
struct X
{
    X(X& other); // copy constructor
//  X(X other);  // Error: incorrect parameter type
};
 
union Y
{
    Y(Y& other, int num = 1); // copy constructor with multiple parameters
//  Y(Y& other, int num);     // Error: `num` has no default argument
};
```

拷贝构造的参数不能是值传递，因为如果拷贝构造函数的参数是通过值传递的，那么每次调用拷贝构造函数时，都需要创建一个参数对象的副本。由于这个副本的创建本身又会调用拷贝构造函数，这样就形成了无限递归。这不仅会导致栈溢出，而且根本就没有意义，因为拷贝构造函数的目的就是避免不必要的对象复制。

如果拷贝构造函数还有其他参数，则其他参数需要有默认值。

#### 默认拷贝构造
> [Copy constructors - cppreference.com](https://en.cppreference.com/w/cpp/language/copy_constructor.html) 

当没有为类定义自己的拷贝构造函数时，编译器会自动声明一个。这个隐式声明的拷贝构造函数通常是 `T::T(const T&)` 形式，但**在某些特定条件下**，它会是 `T::T(T&)` 形式。它的主要工作是逐个成员地拷贝（即浅拷贝）。

##### 情况一：通常形式 `T::T(const T&)`

**条件**：当以下所有条件都为真时，编译器会声明为 `const T&` 形式：
1.  所有直接基类和虚基类 `B` 都有一个参数类型为 `const B&` 或 `const volatile B&` 的拷贝构造函数。
2.  所有类类型（或类类型数组）的非静态数据成员 `M` 都有一个参数类型为 `const M&` 或 `const volatile M&` 的拷贝构造函数。


##### 情况二：特殊形式 `T::T(T&)`

**条件**：如果上述两个条件中的任何一个不满足，编译器声明的拷贝构造函数将是 `T::T(T&)` 形式。

#####  关于 volatile 的规则

隐式声明的拷贝构造函数**不能**接受 `volatile` 左值作为参数。

**举例说明**：
```cpp
struct MyClass {
    int x;
};

int main() {
    volatile MyClass v_obj1;
    MyClass obj2 = v_obj1; // 错误！无法用 volatile 对象初始化拷贝构造函数
    // 隐式拷贝构造函数是 MyClass(const MyClass&)，
    // 它不能绑定到 volatile 对象 v_obj1 上。
    return 0;
}
```

##### 使用 `= default`

即使你已经定义了其他拷贝构造函数，仍然可以使用 `= default` 来强制编译器生成隐式版本的拷贝构造函数。

**举例说明**：
```cpp
struct MyClass {
    MyClass(MyClass&) { /* 处理非const拷贝的逻辑 */ }

    // 显式要求编译器生成标准的 const 引用版本的拷贝构造函数
    MyClass(const MyClass&) = default;
};
```

##### 总结

| 规则要点        | 解释与举例                                                                                 |
| :-------------- | :----------------------------------------------------------------------------------------- |
| **默认形式**    | 通常是 `T(const T&)`，进行浅拷贝。                                                         |
| **特殊形式**    | 如果基类或成员的拷贝构造参数非 `const`，则生成 `T(T&)`。                                   |
| **volatile**    | 隐式拷贝构造不能绑定到 `volatile` 对象。                                                   |
| **多版本共存**  | 可以同时存在 `T(const T&)` 和 `T(T&)`。                                                    |
| **`= default`** | 可用 `= default` 显式要求编译器生成默认版本。                                              |
| **定义时机**    | 在被使用时（如初始化对象时）编译器才会生成函数体。                                         |
| **拷贝行为**    | 逐个拷贝基类和成员（对于引用，是绑定到同一对象）。                                         |
| **弃用情况**    | 如果类有用户定义的析构函数或拷贝赋值运算符，则隐式生成拷贝构造函数被弃用（可能产生警告）。 |

### move constructor
> [Move constructors - cppreference.com](https://en.cppreference.com/w/cpp/language/move_constructor) 

移动构造函数是C++11引入的重要特性，它允许高效地将资源（如动态内存、文件句柄等）从一个对象转移到另一个对象，而不是进行昂贵的深拷贝。

移动构造函数是一种特殊的构造函数，它接受一个右值引用参数，用于从临时对象或即将销毁的对象中"窃取"资源。


```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 从other中窃取资源
        // 将other置于有效但可析构的状态
    }
};
```

1. **参数类型**：必须是右值引用 (`ClassName&&`)
2. **不应抛出异常**：通常标记为 `noexcept`
3. **资源转移**：从源对象窃取资源，而不是复制
4. **源对象状态**：移动后，源对象应处于有效但可析构的状态

移动构造函数通过"窃取"另一个对象的资源来工作，而不是分配新资源：

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t length;
    
public:
    // 普通构造函数
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        std::cout << "Constructor: " << data << std::endl;
    }
    
    // 拷贝构造函数（深拷贝）
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        std::cout << "Copy constructor: " << data << std::endl;
    }
    
    // 移动构造函数
    String(String&& other) noexcept {
        // 窃取资源
        data = other.data;
        length = other.length;
        
        // 将原对象置于有效但可析构的状态
        other.data = nullptr;
        other.length = 0;
        
        std::cout << "Move constructor: " << data << std::endl;
    }
    
    // 析构函数
    ~String() {
        if (data) {
            std::cout << "Destructor: " << data << std::endl;
            delete[] data;
        } else {
            std::cout << "Destructor: (null)" << std::endl;
        }
    }
    
    // 赋值运算符等省略...
};

int main() {
    String s1("Hello");          // 调用普通构造函数
    String s2 = s1;              // 调用拷贝构造函数
    String s3 = std::move(s1);   // 调用移动构造函数
    
    return 0;
}
```

## copy assignment
> [Copy assignment operator - cppreference.com](https://en.cppreference.com/w/cpp/language/copy_assignment) 

拷贝赋值运算符是 C++ 中的一个成员函数，它用于将一个对象的内容赋值给另一个已经存在的对象。它的一般形式如下：
```cpp
ClassType& ClassType::operator=(const ClassType& other) {
    // ... 赋值操作 ...
    return *this;
}
```
这里的 `ClassType` 是类名，`other` 是一个对另一个同类型对象的引用，该对象的内容将被复制到调用赋值运算符的对象中。

拷贝赋值运算符的主要作用是：
1. **复制数据**：将一个对象的状态复制到另一个对象中。
2. **实现对象的赋值**：允许使用赋值运算符 `=` 来将一个对象赋予另一个对象。
3. **处理自我赋值**：如果赋值运算符没有正确处理自我赋值（self-assignment），即对象赋值给自己，可能会导致内存泄漏或多次释放同一资源等问题。
自我赋值是一个特殊的情况，当两个指向同一对象的指针或引用相互赋值时，如果不检查自我赋值，可能会导致问题。处理自我赋值的一种常见方法是：
```cpp
ClassType& ClassType::operator=(const ClassType& other) {
    if (this != &other) {
        // 清理现有资源
        // 复制新资源
    }
    return *this;
}
```

实现步骤：
1. **检查自我赋值**：首先检查是否是自我赋值，如果是，则直接返回。
2. **释放资源**：如果当前对象拥有动态分配的资源，应该先释放这些资源。
3. **复制资源**：复制 `other` 对象的资源到当前对象。
4. **返回当前对象的引用**：返回 `*this`。

```cpp
class MyClass {
public:
    // 拷贝赋值运算符
    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            delete[] data; // 释放原有资源
            data = new int[other.size]; // 复制资源
            size = other.size;
            std::copy(other.data, other.data + other.size, data);
        }
        return *this;
    }

private:
    int* data;
    size_t size;
};
```

### 返回值

**拷贝赋值运算符的返回值必须（且应该）是引用类型**，通常是类类型的左值引用（`ClassName&`）。返回非引用类型在语法上可能允许，但会违反C++的惯用法和预期行为，导致问题。

```cpp
class MyClass {
public:
    // 正确的拷贝赋值运算符声明
    MyClass& operator=(const MyClass& other) {
        // 实现拷贝逻辑
        return *this;
    }
};
```

如果尝试返回非引用类型，会有几个问题：
1. **性能问题**：返回非引用类型会导致不必要的对象拷贝
2. **语义错误**：赋值表达式的结果应该是左值，可以继续被赋值
3. **不符合预期**：破坏连续赋值的功能 `a = b = c`
4. **与内置类型不一致**：内置类型的赋值运算符返回左值引用

在某些设计模式下，可能会返回const引用以防止进一步修改，但这也不常见：

```cpp
class ReadOnlyAssignment {
public:
    int value;
    
    // 返回const引用 - 不常见但有时有用
    const ReadOnlyAssignment& operator=(const ReadOnlyAssignment& other) {
        value = other.value;
        return *this;
    }
};
```

### Implicitly-declared copy assignment operator
If no user-defined copy assignment operators are provided for a class type, the compiler will always declare one as an inline public member of the class. 

Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.

当类没有用户自定义的拷贝赋值运算符时，编译器会自动声明一个：

```cpp
class MyClass {
public:
    // 编译器隐式声明：
    // MyClass& operator=(const MyClass&);
};
```

这个隐式声明的赋值运算符是：
- `inline`的
- `public`的
- 执行成员逐项拷贝（member-wise copy）

```cpp
#include <iostream>

class Base {
public:
    Base(int val = 0) : baseValue(val) {}
    
    Base& operator=(const Base& other) {
        baseValue = other.baseValue;
        std::cout << "Base assignment operator called\n";
        return *this;
    }
    
    int baseValue;
};

class Derived : public Base {
public:
    Derived(int bval = 0, int dval = 0) : Base(bval), derivedValue(dval) {}
    
    // 使用using声明尝试引入基类赋值运算符
    using Base::operator=;
    
    // 编译器仍然会隐式声明：
    // Derived& operator=(const Derived&);
    
    int derivedValue;
};

int main() {
    std::cout << "=== 演示赋值运算符隐藏 ===\n";
    
    Derived d1(1, 10);
    Derived d2(2, 20);
    Base b(99);
    
    std::cout << "Before assignments:\n";
    std::cout << "d1: base=" << d1.baseValue << ", derived=" << d1.derivedValue << "\n";
    std::cout << "d2: base=" << d2.baseValue << ", derived=" << d2.derivedValue << "\n";
    std::cout << "b: base=" << b.baseValue << "\n";
    
    // 1. 派生类对象之间的赋值 - 正常工作
    std::cout << "\n1. Derived to Derived assignment:\n";
    d1 = d2; // 调用隐式生成的Derived::operator=
    std::cout << "d1: base=" << d1.baseValue << ", derived=" << d1.derivedValue << "\n";
    
    // 2. 基类对象赋给派生类对象 - 可能工作，但取决于具体情况
    std::cout << "\n2. Base to Derived assignment:\n";
    d1 = b; // 使用using引入的Base::operator=
    std::cout << "d1: base=" << d1.baseValue << ", derived=" << d1.derivedValue << "\n";
    // 注意：derivedValue没有被修改，只有基类部分被赋值
    
    return 0;
}
```

### 自定义拷贝赋值
> [21.12 — Overloading the assignment operator – Learn C++](https://www.learncpp.com/cpp-tutorial/overloading-the-assignment-operator/) 

注释动态资源的分配和释放。

```cpp
#include <algorithm>
#include <iostream>
#include <memory>
#include <string>
 
struct A
{
    int n;
    std::string s1;
 
    A() = default;
    A(A const&) = default;
 
    // user-defined copy assignment (copy-and-swap idiom)
    A& operator=(A other)
    {
        std::cout << "copy assignment of A\n";
        std::swap(n, other.n);
        std::swap(s1, other.s1);
        return *this;
    }
};
 
struct B : A
{
    std::string s2;
    // implicitly-defined copy assignment
};
 
struct C
{
    std::unique_ptr<int[]> data;
    std::size_t size;
 
    // user-defined copy assignment (non copy-and-swap idiom)
    // note: copy-and-swap would always reallocate resources
    C& operator=(const C& other)
    {
        if (this != &other) // not a self-assignment
        {
            if (size != other.size) // resource cannot be reused
            {
                data.reset(new int[other.size]);
                size = other.size;
            }
            std::copy(&other.data[0], &other.data[0] + size, &data[0]);
        }
        return *this;
    }
};
 
int main()
{
    A a1, a2;
    std::cout << "a1 = a2 calls ";
    a1 = a2; // user-defined copy assignment
 
    B b1, b2;
    b2.s1 = "foo";
    b2.s2 = "bar";
    std::cout << "b1 = b2 calls ";
    b1 = b2; // implicitly-defined copy assignment
 
    std::cout << "b1.s1 = " << b1.s1 << "; b1.s2 = " << b1.s2 << '\n';
}
```

## Move assignment 
> [Move assignment operator - cppreference.com](https://en.cppreference.com/w/cpp/language/move_assignment.html) 

移动赋值运算符是C++11引入的重要特性，它允许高效地将资源从一个对象转移到另一个已存在的对象。

**移动赋值运算符必须返回当前对象的左值引用（`ClassName&`）**。这与拷贝赋值运算符的要求相同，目的是支持连续赋值操作（如 `a = b = c;`）。

```cpp
#include <iostream>
#include <utility> // for std::move
#include <algorithm> // for std::copy

class String {
private:
    char* data;
    size_t length;
    
public:
    // 普通构造函数
    String(const char* str = "") : length(0), data(nullptr) {
        if (str) {
            length = std::strlen(str);
            data = new char[length + 1];
            std::strcpy(data, str);
        }
        std::cout << "Constructed: " << (data ? data : "null") << std::endl;
    }
    
    // 移动构造函数
    String(String&& other) noexcept 
        : data(other.data), length(other.length) {
        other.data = nullptr;
        other.length = 0;
        std::cout << "Move constructed: " << (data ? data : "null") << std::endl;
    }
    
    // 移动赋值运算符
    String& operator=(String&& other) noexcept {
        // 1. 检查自赋值
        if (this != &other) {
            // 2. 释放当前资源
            delete[] data;
            
            // 3. 窃取资源
            data = other.data;
            length = other.length;
            
            // 4. 将源对象置于有效但空的状态
            other.data = nullptr;
            other.length = 0;
            
            std::cout << "Move assigned: " << (data ? data : "null") << std::endl;
        }
        
        // 5. 返回当前对象的引用
        return *this;
    }
    
    // 拷贝构造函数
    String(const String& other) : length(other.length), data(nullptr) {
        if (other.data) {
            data = new char[length + 1];
            std::strcpy(data, other.data);
        }
        std::cout << "Copy constructed: " << (data ? data : "null") << std::endl;
    }
    
    // 拷贝赋值运算符
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data;
            
            length = other.length;
            if (other.data) {
                data = new char[length + 1];
                std::strcpy(data, other.data);
            } else {
                data = nullptr;
            }
            
            std::cout << "Copy assigned: " << (data ? data : "null") << std::endl;
        }
        return *this;
    }
    
    // 析构函数
    ~String() {
        delete[] data;
        std::cout << "Destructed: " << (data ? data : "null") << std::endl;
    }
    
    // 辅助方法
    const char* c_str() const { return data ? data : "null"; }
};

int main() {
    std::cout << "=== 创建原始对象 ===" << std::endl;
    String s1("Hello");
    String s2("World");
    String s3("Test");
    
    std::cout << "\n=== 使用移动赋值运算符 ===" << std::endl;
    s1 = std::move(s2); // 调用移动赋值运算符
    
    std::cout << "\n=== 连续赋值 ===" << std::endl;
    s1 = s3 = String("New String"); // 连续赋值
    
    std::cout << "\n=== 对象状态 ===" << std::endl;
    std::cout << "s1: " << s1.c_str() << std::endl;
    std::cout << "s2: " << s2.c_str() << std::endl;
    std::cout << "s3: " << s3.c_str() << std::endl;
    
    std::cout << "\n=== 程序结束 ===" << std::endl;
    return 0;
}
```

## desctructors
> [Destructors - cppreference.com](https://en.cppreference.com/w/cpp/language/destructor) 

A destructor is a special member function that is called when the lifetime of an object ends. The purpose of the destructor is to free the resources that the object may have acquired during its lifetime.

A destructor cannot be a coroutine.

The destructor is implicitly invoked whenever an object's lifetime ends, which includes:
- program termination, for objects with static storage duration
- thread exit, for objects with thread-local storage duration (since C++11)
- end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to a reference
- delete-expression, for objects with dynamic storage duration
- end of the full expression, for nameless temporaries
- stack unwinding, for objects with automatic storage duration when an exception escapes their block, uncaught.

The destructor can also be invoked explicitly.

If no user-declared prospective(since C++20) destructor is provided for a class type, the compiler will always declare a destructor as an inline public member of its class.

### 析构顺序
和构造顺序相反。

### 虚析构函数
Deleting an object through pointer to base invokes undefined behavior unless the destructor in the base class is virtual:
```cpp
class Base
{
public:
    virtual ~Base() {}
};
 
class Derived : public Base {};
 
Base* b = new Derived;
delete b; // safe
```

在C++中，如果一个类继承自另一个类（基类），并且基类有一个非虚的析构函数，那么通过基类的指针来删除派生类的对象会导致问题。因为非虚析构函数不会调用派生类的析构函数，导致派生类中的资源可能不会被正确释放，从而引发内存泄漏或其他未定义行为。

为了避免这个问题，基类的析构函数应该被声明为虚函数。这样，当通过基类的指针删除派生类的对象时，首先会调用派生类的析构函数，然后再调用基类的析构函数，确保资源被正确释放。

### 纯虚析构函数
A prospective(since C++20) destructor may be declared pure virtual, for example in a base class which needs to be made abstract, but has no other suitable functions that could be declared pure virtual. A pure virtual destructor must have a definition, since all base class destructors are always called when the derived class is destroyed:
```cpp
class AbstractBase
{
public:
    virtual ~AbstractBase() = 0;
};
AbstractBase::~AbstractBase() {}
 
class Derived : public AbstractBase {};
 
// AbstractBase obj; // compiler error
Derived obj;         // OK
```

### 析构函数的访问级别

#### 1. public 析构函数

这是最常见的情况，适用于大多数类。public析构函数允许任何代码删除对象。

```cpp
class PublicDestructor {
public:
    PublicDestructor() {
        std::cout << "PublicDestructor constructed\n";
    }
    
    ~PublicDestructor() { // public析构函数
        std::cout << "PublicDestructor destroyed\n";
    }
};

int main() {
    PublicDestructor obj1; // 栈上对象，自动析构
    PublicDestructor* obj2 = new PublicDestructor(); // 堆上对象
    delete obj2; // 可以正常删除
    
    return 0;
}
```

#### 2. protected 析构函数

protected 析构函数用于基类，防止直接实例化基类对象，但允许派生类对象正常析构。这是一种常见的设计模式，用于创建抽象基类。

```cpp
#include <iostream>

class AbstractBase {
protected:
    AbstractBase() {
        std::cout << "AbstractBase constructed\n";
    }
    
    // 将析构函数声明为虚函数
    virtual ~AbstractBase() {
        std::cout << "AbstractBase destroyed\n";
    }
    
public:
    virtual void doSomething() = 0; // 纯虚函数
};

class ConcreteDerived : public AbstractBase {
public:
    ConcreteDerived() {
        std::cout << "ConcreteDerived constructed\n";
    }
    
    ~ConcreteDerived() override {
        std::cout << "ConcreteDerived destroyed\n";
    }
    
    void doSomething() override {
        std::cout << "Doing something\n";
    }
};

int main() {
    // AbstractBase base; // 错误：无法实例化抽象类
    // AbstractBase* basePtr = new AbstractBase(); // 错误：无法实例化抽象类
    
    ConcreteDerived derived; // 正确：栈上对象，自动调用析构函数
    std::cout << "---\n";
    
    AbstractBase* basePtr = new ConcreteDerived(); // 正确：通过基类指针指向派生类
    std::cout << "---\n";
    
    basePtr->doSomething();
    std::cout << "---\n";
    
    delete basePtr; // 正确：调用虚析构函数，会先调用派生类析构函数，再调用基类析构函数
    
    return 0;
}
```

#### 3. private 析构函数

private析构函数用于完全控制对象的生命周期，常见于以下场景：

1. **禁止栈上分配**：防止创建自动存储期的对象
2. **单例模式**：控制唯一实例的销毁
3. **只能通过特定方法删除的对象**：如引用计数对象
4. **防止继承**：阻止类被用作基类

##### 示例1：禁止栈上分配

```cpp
#include <iostream>

class HeapOnly {
private:
    int data;
    
    // 私有构造函数
    HeapOnly(int value) : data(value) {
        std::cout << "HeapOnly constructed\n";
    }
    
    // 私有析构函数
    ~HeapOnly() {
        std::cout << "HeapOnly destroyed\n";
    }
    
    // 声明友元类，允许它访问私有成员
    friend class HeapOnlyManager;
    
public:
    void doSomething() {
        std::cout << "Doing something with data: " << data << "\n";
    }
    
    // 防止拷贝
    HeapOnly(const HeapOnly&) = delete;
    HeapOnly& operator=(const HeapOnly&) = delete;
};

// 专门管理HeapOnly生命周期的类
class HeapOnlyManager {
public:
    static HeapOnly* create(int value) {
        return new HeapOnly(value);
    }
    
    static void destroy(HeapOnly* obj) {
        delete obj;
    }
};

int main() {
    HeapOnly* obj = HeapOnlyManager::create(42);
    obj->doSomething();
    HeapOnlyManager::destroy(obj);
    
    return 0;
}
```

##### 示例2：单例模式 - 动态内存分配

```cpp
class Singleton {
private:
    static Singleton* instance;
    
    Singleton() { // private构造函数
        std::cout << "Singleton constructed\n";
    }
    
    ~Singleton() { // private析构函数
        std::cout << "Singleton destroyed\n";
    }
    
    // 防止拷贝
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
public:
    static Singleton* getInstance() {
        if (!instance) {
            instance = new Singleton();
        }
        return instance;
    }
    
    static void releaseInstance() {
        delete instance; // 类内可以访问private析构函数
        instance = nullptr;
    }
    
    void doSomething() {
        std::cout << "Singleton doing something\n";
    }
};

Singleton* Singleton::instance = nullptr;

int main() {
    Singleton* singleton = Singleton::getInstance();
    singleton->doSomething();
    Singleton::releaseInstance();
    
    return 0;
}
```

这里析构函数是 private，提供一个 static 的函数释放资源。

##### 示例3：只能通过特定方法删除的对象
```cpp
class ReferenceCounted {
private:
    int refCount;
    
    ~ReferenceCounted() { // private析构函数
        std::cout << "ReferenceCounted destroyed\n";
    }
    
public:
    ReferenceCounted() : refCount(0) {
        std::cout << "ReferenceCounted constructed\n";
    }
    
    void addRef() {
        ++refCount;
    }
    
    void release() {
        if (--refCount == 0) {
            delete this; // 类内可以访问private析构函数
        }
    }
    
    void doSomething() {
        std::cout << "ReferenceCounted doing something, refCount: " << refCount << "\n";
    }
};

int main() {
    ReferenceCounted* obj = new ReferenceCounted();
    obj->addRef();
    obj->doSomething();
    obj->release(); // 减少引用计数，但不销毁
    obj->doSomething();
    obj->release(); // 引用计数为0，销毁对象
    
    return 0;
}
```
