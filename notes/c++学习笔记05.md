C++ 学习笔记

# 嵌套类型
在 C++ 中，**嵌套类型**是指在一个类或结构体内部定义的类型。这些类型可以是类、结构体、枚举或类型别名（`typedef` 或 `using`）。

嵌套类型是在类或结构体内部定义的类型。这些类型可以访问外部类或结构体的成员，但外部类或结构体不能直接访问嵌套类型的成员。

## 示例代码

```cpp
class Outer {
public:
    // 嵌套类型
    class Inner {
    public:
        void print() {
            std::cout << "Hello from Inner!" << std::endl;
        }
    };

    // 使用嵌套类型
    void useInner() {
        Inner inner;
        inner.print();
    }
};

int main() {
    Outer::Inner inner; // 直接使用嵌套类型
    inner.print();

    Outer outer;
    outer.useInner();

    return 0;
}
```

```
Hello from Inner!
Hello from Inner!
```

## 嵌套类型的用途

嵌套类型的主要用途包括：
- **封装**：将相关类型封装在一起，提高代码的可读性和可维护性。
- **访问控制**：嵌套类型可以访问外部类的私有成员，但外部类不能直接访问嵌套类型的成员。
- **命名空间**：嵌套类型可以避免命名冲突，因为它们的作用域被限制在外部类中。

# 虚函数
> [面试官：为什么构造函数不能是虚的？你只答对了一半](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483928&idx=1&sn=f17db1131c7065fb434addac0e0e5fc9&chksm=c4735e61f304d777502dd229f08b249db4451529cf7dab182b65b4cf7edb0be3479f307539a3&cur_album_id=4104376609422147595&scene=190#rd) 
> [C++虚函数是“毒瘤”？这3个方案让你告别性能瓶颈](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483905&idx=1&sn=87e38d421117a5582ab11436a617d5f8&chksm=c4735e78f304d76ebd7643ae98e53ef77b9718ae9a3bab49bbdb8ac27a469ab363c521770701&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 
> [为什么你的C++多态又“失灵”了？一个const引发的“血案”，C++11后竟有完美解药](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483738&idx=1&sn=dfaebd36278deb0bb817d67df35fa5f8&chksm=c4735d23f304d4359d6550c2f3d7d62902d00fd9c235cff84418941db0b5a82e6e54851435ff&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 

## 构造函数不能是虚函数

C++ 标准明确规定了构造函数不能是虚函数。如果你尝试将构造函数声明为虚函数，编译器会直接报错：

```cpp
class Base {
public:
    virtual Base() { } // ❌ 编译错误：构造函数不能是虚函数
};
```

### 为什么不能是虚函数

#### a) 虚函数机制依赖虚表（vtable），而虚表在构造过程中建立

- 虚函数通过虚表（vtable）实现动态绑定
- 虚表指针（vptr）在构造函数执行期间被初始化
- 如果构造函数本身是虚函数，那么调用它需要访问vptr，但此时vptr可能指向错误的虚表或者根本未初始化

#### b) 对象类型在构造期间是确定的

- 当创建对象时，必须明确指定具体类型：`new DerivedClass()`
- 构造函数的调用在编译时就已经确定，不需要运行时多态
- 虚函数的目的是为了在不知道对象具体类型时决定调用哪个函数，但构造函数调用时类型是明确的

#### c) 内存分配和对象构造的分离

- 在 C++ 中，内存分配（operator new）和对象构造（构造函数）是两个独立的步骤
- 虚函数机制需要在对象完全构造后才能正常工作
- 在构造函数执行期间，对象还没有完全「诞生」，因此无法支持虚函数机制

### 替代方案：工厂模式和克隆模式

虽然不能有虚构造函数，但可以通过其他设计模式实现类似的功能：

#### 工厂模式

```cpp
class Base {
public:
    virtual ~Base() = default;
    
    // 工厂方法，可以看作是"虚拟构造函数"的替代
    static std::unique_ptr<Base> create(const std::string& type);
};

class Derived1 : public Base {
    // ...
};

class Derived2 : public Base {
    // ...
};

std::unique_ptr<Base> Base::create(const std::string& type) {
    if (type == "Derived1") return std::make_unique<Derived1>();
    if (type == "Derived2") return std::make_unique<Derived2>();
    return nullptr;
}
```

### 构造函数中调用虚函数

虽然构造函数本身不能是虚函数，但可以在构造函数中调用虚函数。

```cpp
class Base {
public:
    Base() {
        callVirtual(); // 在构造函数中调用虚函数
    }
    
    virtual void callVirtual() {
        std::cout << "Base::callVirtual()" << std::endl;
    }
};

class Derived : public Base {
public:
    void callVirtual() override {
        std::cout << "Derived::callVirtual()" << std::endl;
    }
};

int main() {
    Derived d; // 输出: Base::callVirtual()，而不是 Derived::callVirtual()
}
```

**原因**：在基类构造函数执行期间，派生类部分还没有构造完成，因此虚函数机制会调用基类的版本，而不是派生类的重写版本。

## 静态成员函数不能是虚函数

静态成员函数不能声明为虚函数，这是由C++的对象模型和虚函数机制的本质决定的。

静态成员函数没有`this`指针，虚函数的整个机制都依赖于对象的`this`指针：

静态成员函数和虚函数在概念上是矛盾的：

1. **静态成员函数**：与类关联，而不是与对象实例关联。它们在编译时绑定，不依赖于对象的状态。

2. **虚函数**：与对象实例关联，通过运行时多态实现动态绑定。它们依赖于对象的具体类型。

将这两者结合没有任何逻辑意义：
- 如果静态函数是虚的，它应该根据什么对象来确定调用哪个版本？
- 静态函数没有接收对象，无法确定对象的实际类型。


### 虚函数的工作原理
- 每个具有虚函数的类都有一个虚函数表（vtable）
- 每个对象实例都有一个指向vtable的指针（vptr）
- 当调用虚函数时，通过对象的vptr找到vtable，然后在vtable中找到正确的函数地址进行调用
- 这一切都需要通过对象的`this`指针来访问vptr

### 静态成员函数的特性
- 静态成员函数不属于任何对象实例，它属于类本身
- 静态成员函数没有`this`指针，因为它不操作特定对象实例
- 静态成员函数可以直接通过类名调用，不需要对象实例

```cpp
class MyClass {
public:
    static void staticFunc(); // 没有this指针
    virtual void virtualFunc(); // 有隐含的this参数
};

// 调用方式
MyClass::staticFunc(); // 不需要对象
MyClass obj;
obj.virtualFunc(); // 需要对象，通过this指针工作
```

## 内联函数不能是虚函数

**内联函数可以是虚函数，但在大多数情况下，虚函数的内联特性会被忽略，这使得将虚函数声明为内联通常没有实际意义。**

从语法上讲，C++允许将虚函数声明为内联：

```cpp
class Base {
public:
    virtual inline void func() { // ✅ 语法上是合法的
        std::cout << "Base::func()" << std::endl;
    }
};
```

编译器不会拒绝这样的代码，但内联建议很可能被忽略。

### 内联和虚函数机制本质上冲突

#### a) 内联的机制
- 内联是一种编译期优化
- 编译器将函数体直接插入调用处，避免函数调用开销
- 内联决策在编译时做出，需要知道函数的确切实现

#### b) 虚函数的机制
- 虚函数通过虚表(vtable)实现运行时的多态性
- 调用哪个函数版本在运行时根据对象实际类型决定
- 虚函数调用需要通过指针间接跳转，这与内联的直接插入代码相矛盾

#### c) 根本冲突
- **内联需要编译时确定**：编译器必须知道要插入的确切代码
- **虚函数需要运行时确定**：具体调用哪个函数在运行时才能决定
- 这两个要求直接冲突，使得虚函数的内联化几乎不可能

## 模板成员函数不能是虚函数

**C++标准明确禁止模板成员函数成为虚函数，这是因为两者在根本机制上存在不可调和的矛盾。**

### a) 编译时 vs 运行时的矛盾

这是最核心的原因：

- **模板是编译时机制**：模板实例化发生在编译时。对于每个不同的模板参数，编译器都会生成一个全新的函数
- **虚函数是运行时机制**：虚函数通过虚函数表(vtable)实现运行时多态，vtable在编译时创建但用于运行时决策

```cpp
// 假设允许模板虚函数（实际不允许）
class Processor {
public:
    template<typename T>
    virtual void process(T value); // 假设允许
};

// 使用
Processor* processor = getProcessor();
processor->process<int>(42);     // 需要生成process<int>实例
processor->process<std::string>("hello"); // 需要生成process<std::string>实例
```

问题在于：vtable应该在编译时创建并包含所有可能的虚函数指针，但模板实例的数量在编译时是未知的（理论上可以是无限的）。

### b) 虚函数表(vtable)的结构问题

每个有虚函数的类都有一个vtable，其中包含了该类所有虚函数的指针。vtable的大小在编译时就必须确定。

但是对于模板成员函数：
- 模板可以有无穷多种实例化方式
- vtable无法预先为所有可能的模板实例化准备槽位
- 无法确定vtable应该有多大

### c) 对象大小和内存布局

C++要求对象的大小在编译时已知。每个有虚函数的对象都有一个指向vtable的指针(vptr)。

如果允许模板虚函数：
- 不同的翻译单元可能实例化不同的模板特化
- 这会导致同一类的vtable在不同编译单元中大小不同
- 进而导致同一类的对象在不同编译单元中大小不同
- 这会破坏C++的内存模型和ABI(应用程序二进制接口)

## 析构函数可以是虚函数

**当一个类被设计为通过基类指针来操作派生类对象时（即多态使用），基类必须有虚析构函数。**

在C++中，如果一个类继承自另一个类（基类），并且基类有一个非虚的析构函数，那么通过基类的指针来删除派生类的对象会导致问题。因为非虚析构函数不会调用派生类的析构函数，导致派生类中的资源可能不会被正确释放，从而引发内存泄漏或其他未定义行为。

为了避免这个问题，基类的析构函数应该被声明为虚函数。这样，当通过基类的指针删除派生类的对象时，首先会调用派生类的析构函数，然后再调用基类的析构函数，确保资源被正确释放。