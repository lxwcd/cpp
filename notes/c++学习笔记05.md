C++ 学习笔记

# 嵌套类型
在 C++ 中，**嵌套类型**是指在一个类或结构体内部定义的类型。这些类型可以是类、结构体、枚举或类型别名（`typedef` 或 `using`）。

嵌套类型是在类或结构体内部定义的类型。这些类型可以访问外部类或结构体的成员，但外部类或结构体不能直接访问嵌套类型的成员。

## 示例代码

```cpp
class Outer {
public:
    // 嵌套类型
    class Inner {
    public:
        void print() {
            std::cout << "Hello from Inner!" << std::endl;
        }
    };

    // 使用嵌套类型
    void useInner() {
        Inner inner;
        inner.print();
    }
};

int main() {
    Outer::Inner inner; // 直接使用嵌套类型
    inner.print();

    Outer outer;
    outer.useInner();

    return 0;
}
```

```
Hello from Inner!
Hello from Inner!
```

## 嵌套类型的用途

嵌套类型的主要用途包括：
- **封装**：将相关类型封装在一起，提高代码的可读性和可维护性。
- **访问控制**：嵌套类型可以访问外部类的私有成员，但外部类不能直接访问嵌套类型的成员。
- **命名空间**：嵌套类型可以避免命名冲突，因为它们的作用域被限制在外部类中。

# 虚函数
> [面试官：为什么构造函数不能是虚的？你只答对了一半](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483928&idx=1&sn=f17db1131c7065fb434addac0e0e5fc9&chksm=c4735e61f304d777502dd229f08b249db4451529cf7dab182b65b4cf7edb0be3479f307539a3&cur_album_id=4104376609422147595&scene=190#rd) 
> [C++虚函数是“毒瘤”？这3个方案让你告别性能瓶颈](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483905&idx=1&sn=87e38d421117a5582ab11436a617d5f8&chksm=c4735e78f304d76ebd7643ae98e53ef77b9718ae9a3bab49bbdb8ac27a469ab363c521770701&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 
> [为什么你的C++多态又“失灵”了？一个const引发的“血案”，C++11后竟有完美解药](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247483738&idx=1&sn=dfaebd36278deb0bb817d67df35fa5f8&chksm=c4735d23f304d4359d6550c2f3d7d62902d00fd9c235cff84418941db0b5a82e6e54851435ff&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 

## 构造函数不能是虚函数

C++ 标准明确规定了构造函数不能是虚函数。如果你尝试将构造函数声明为虚函数，编译器会直接报错：

```cpp
class Base {
public:
    virtual Base() { } // ❌ 编译错误：构造函数不能是虚函数
};
```

### a) 虚函数机制依赖虚表（vtable），而虚表在构造过程中建立

- 虚函数通过虚表（vtable）实现动态绑定
- 虚表指针（vptr）在构造函数执行期间被初始化
- 如果构造函数本身是虚函数，那么调用它需要访问vptr，但此时vptr可能指向错误的虚表或者根本未初始化

### b) 对象类型在构造期间是确定的

- 当创建对象时，必须明确指定具体类型：`new DerivedClass()`
- 构造函数的调用在编译时就已经确定，不需要运行时多态
- 虚函数的目的是为了在不知道对象具体类型时决定调用哪个函数，但构造函数调用时类型是明确的

### c) 内存分配和对象构造的分离

- 在 C++ 中，内存分配（operator new）和对象构造（构造函数）是两个独立的步骤
- 虚函数机制需要在对象完全构造后才能正常工作
- 在构造函数执行期间，对象还没有完全「诞生」，因此无法支持虚函数机制

### 替代方案：工厂模式和克隆模式

虽然不能有虚构造函数，但可以通过其他设计模式实现类似的功能：

#### 工厂模式

```cpp
class Base {
public:
    virtual ~Base() = default;
    
    // 工厂方法，可以看作是"虚拟构造函数"的替代
    static std::unique_ptr<Base> create(const std::string& type);
};

class Derived1 : public Base {
    // ...
};

class Derived2 : public Base {
    // ...
};

std::unique_ptr<Base> Base::create(const std::string& type) {
    if (type == "Derived1") return std::make_unique<Derived1>();
    if (type == "Derived2") return std::make_unique<Derived2>();
    return nullptr;
}
```

## 构造函数中不建议调用虚函数
> Effective C++ 第三版 Item 9

虽然构造函数本身不能是虚函数，但可以在构造函数中调用虚函数，但不建议这样做，可能结果和预期不同。

**在构造函数和析构函数中，虚函数不会表现出“多态”行为，它们被当作当前类的普通函数来调用。**

```cpp
class Transaction { // 所有交易的基类
public:
    Transaction();
    virtual void logTransaction() const = 0; // 创建一个纯虚函数，记录日志
    // ...
};

Transaction::Transaction() {
    // ...
    logTransaction(); // 在基类构造函数中调用虚函数
}

class BuyTransaction : public Transaction { // 派生类：买入交易
public:
    virtual void logTransaction() const; // 实现了记录日志的函数
    // ...
};

class SellTransaction : public Transaction { // 派生类：卖出交易
public:
    virtual void logTransaction() const; // 实现了记录日志的函数
    // ...
};
```

现在，当创建一个 `BuyTransaction` 对象时：

```cpp
BuyTransaction b;
```

1.  `BuyTransaction` 的构造函数首先被调用。
2.  但在此之前，必须先调用其基类 `Transaction` 的构造函数。
3.  在 `Transaction` 的构造函数中，执行到了 `logTransaction()`。
4.  **此时，`logTransaction()` 调用的是 `Transaction::logTransaction()`，而不是 `BuyTransaction::logTransaction()`！**

即使创建的是 `BuyTransaction` 对象，在基类构造函数执行期间，这个对象的类型被认为是 `Transaction` 类。派生部分（即 `BuyTransaction` 的部分）还没有被初始化，因此C++不会“向下”去调用派生类的重写函数。

**结果就是：程序可能会崩溃（因为调用了纯虚函数），或者记录了错误的日志信息（记录了基类的信息而不是派生类的）。**

构造顺序 (Construction Order)：
1.  **基类部分** -> 2. **派生类部分**

当基类 `Transaction` 的构造函数正在执行时，`BuyTransaction` 的部分还没有被构造。**让一个尚未初始化的部分（派生类）去响应一个虚函数调用是极其危险的**。因为派生类的虚函数很可能会访问其自身的成员变量，而这些成员变量此时还没有被初始化！这会导致未定义行为。

## 析构函数中不建议调用虚函数
> Effective C++ 第三版 Item 9

析构顺序 (Destruction Order)：
1.  **派生类部分** -> 2. **基类部分**

析构是构造的逆过程。当 `Transaction` 的析构函数被调用时，`BuyTransaction` 的部分已经被销毁了。**对象此时已经“死”了，派生类部分不复存在**。同样，为了安全起见，C++认为对象的类型已经被“回退”到了基类 (`Transaction`)，任何虚函数调用都会直接定位到基类的版本，而不会试图去调用一个已经被销毁的派生类对象上的函数。

## 静态成员函数不能是虚函数

静态成员函数不能声明为虚函数，这是由C++的对象模型和虚函数机制的本质决定的。

静态成员函数没有`this`指针，虚函数的整个机制都依赖于对象的`this`指针：

静态成员函数和虚函数在概念上是矛盾的：

1. **静态成员函数**：与类关联，而不是与对象实例关联。它们在编译时绑定，不依赖于对象的状态。

2. **虚函数**：与对象实例关联，通过运行时多态实现动态绑定。它们依赖于对象的具体类型。

将这两者结合没有任何逻辑意义：
- 如果静态函数是虚的，它应该根据什么对象来确定调用哪个版本？
- 静态函数没有接收对象，无法确定对象的实际类型。


### 虚函数的工作原理
- 每个具有虚函数的类都有一个虚函数表（vtable）
- 每个对象实例都有一个指向vtable的指针（vptr）
- 当调用虚函数时，通过对象的vptr找到vtable，然后在vtable中找到正确的函数地址进行调用
- 这一切都需要通过对象的`this`指针来访问vptr

### 静态成员函数的特性
- 静态成员函数不属于任何对象实例，它属于类本身
- 静态成员函数没有`this`指针，因为它不操作特定对象实例
- 静态成员函数可以直接通过类名调用，不需要对象实例

```cpp
class MyClass {
public:
    static void staticFunc(); // 没有this指针
    virtual void virtualFunc(); // 有隐含的this参数
};

// 调用方式
MyClass::staticFunc(); // 不需要对象
MyClass obj;
obj.virtualFunc(); // 需要对象，通过this指针工作
```

## 内联函数不能是虚函数

**内联函数可以是虚函数，但在大多数情况下，虚函数的内联特性会被忽略，这使得将虚函数声明为内联通常没有实际意义。**

从语法上讲，C++允许将虚函数声明为内联：

```cpp
class Base {
public:
    virtual inline void func() { // ✅ 语法上是合法的
        std::cout << "Base::func()" << std::endl;
    }
};
```

编译器不会拒绝这样的代码，但内联建议很可能被忽略。

### 内联和虚函数机制本质上冲突

#### a) 内联的机制
- 内联是一种编译期优化
- 编译器将函数体直接插入调用处，避免函数调用开销
- 内联决策在编译时做出，需要知道函数的确切实现

#### b) 虚函数的机制
- 虚函数通过虚表(vtable)实现运行时的多态性
- 调用哪个函数版本在运行时根据对象实际类型决定
- 虚函数调用需要通过指针间接跳转，这与内联的直接插入代码相矛盾

#### c) 根本冲突
- **内联需要编译时确定**：编译器必须知道要插入的确切代码
- **虚函数需要运行时确定**：具体调用哪个函数在运行时才能决定
- 这两个要求直接冲突，使得虚函数的内联化几乎不可能

## 模板成员函数不能是虚函数

**C++标准明确禁止模板成员函数成为虚函数，这是因为两者在根本机制上存在不可调和的矛盾。**

### a) 编译时 vs 运行时的矛盾

这是最核心的原因：

- **模板是编译时机制**：模板实例化发生在编译时。对于每个不同的模板参数，编译器都会生成一个全新的函数
- **虚函数是运行时机制**：虚函数通过虚函数表(vtable)实现运行时多态，vtable在编译时创建但用于运行时决策

```cpp
// 假设允许模板虚函数（实际不允许）
class Processor {
public:
    template<typename T>
    virtual void process(T value); // 假设允许
};

// 使用
Processor* processor = getProcessor();
processor->process<int>(42);     // 需要生成process<int>实例
processor->process<std::string>("hello"); // 需要生成process<std::string>实例
```

问题在于：vtable应该在编译时创建并包含所有可能的虚函数指针，但模板实例的数量在编译时是未知的（理论上可以是无限的）。

### b) 虚函数表(vtable)的结构问题

每个有虚函数的类都有一个vtable，其中包含了该类所有虚函数的指针。vtable的大小在编译时就必须确定。

但是对于模板成员函数：
- 模板可以有无穷多种实例化方式
- vtable无法预先为所有可能的模板实例化准备槽位
- 无法确定vtable应该有多大

### c) 对象大小和内存布局

C++要求对象的大小在编译时已知。每个有虚函数的对象都有一个指向vtable的指针(vptr)。

如果允许模板虚函数：
- 不同的翻译单元可能实例化不同的模板特化
- 这会导致同一类的vtable在不同编译单元中大小不同
- 进而导致同一类的对象在不同编译单元中大小不同
- 这会破坏C++的内存模型和ABI(应用程序二进制接口)

## 析构函数可以是虚函数

**当一个类被设计为通过基类指针来操作派生类对象时（即多态使用），基类必须有虚析构函数。**

在C++中，如果一个类继承自另一个类（基类），并且基类有一个非虚的析构函数，那么通过基类的指针来删除派生类的对象会导致问题。因为非虚析构函数不会调用派生类的析构函数，导致派生类中的资源可能不会被正确释放，从而引发内存泄漏或其他未定义行为。

为了避免这个问题，基类的析构函数应该被声明为虚函数。这样，当通过基类的指针删除派生类的对象时，首先会调用派生类的析构函数，然后再调用基类的析构函数，确保资源被正确释放。

# 赋值操作符重载返回指向 *this 的引用
> Effective C++ 第三版 Item 10

当你重载赋值操作符（`=`、`+=`、`-=`、`*=` 等）时，应该让它们返回一个指向当前对象的引用（`*this`）。
主要是为了**支持连锁赋值（chain of assignments）** 并**与内置类型的行为保持一致**。

```cpp
class MyClass {
private:
    int value;
    
public:
    // 基本赋值操作符
    MyClass& operator=(const MyClass& rhs) { // 返回 MyClass&
        if (this != &rhs) { // 自赋值检查
            value = rhs.value;
        }
        return *this; // 返回当前对象的引用
    }
    
    // 复合赋值操作符也应返回引用
    MyClass& operator+=(const MyClass& rhs) {
        value += rhs.value;
        return *this;
    }
    
    MyClass& operator-=(const MyClass& rhs) {
        value -= rhs.value;
        return *this;
    }
    
    int getValue() const { return value; }
};
```

## 支持连锁赋值

这是模仿C++内置类型的行为方式：

```cpp
// 内置类型的连锁赋值
int a, b, c;
a = b = c = 10; // 所有变量都变成10

// 对于自定义类型，我们也希望有相同的行为
MyClass x, y, z;
x = y = z; // 这需要赋值操作符返回引用才能工作
```

如果没有返回引用，上面的代码就无法编译或无法正确工作。

## 与内置类型行为一致

在C++中，所有内置类型的赋值操作都返回一个左值引用：

```cpp
int a = 5;
int b = (a = 10); // (a = 10) 返回a的引用，然后b被赋值为10
cout << b; // 输出10
```

让自定义类型遵循相同的惯例，可以使代码更加一致和可预测。

## 效率考虑

返回引用避免了不必要的对象拷贝：

```cpp
// 如果返回的是值而不是引用
MyClass operator=(const MyClass& rhs) {
    // ... 赋值操作 ...
    return *this; // 这里会创建临时对象，效率低下
}

// 如果返回引用
MyClass& operator=(const MyClass& rhs) {
    // ... 赋值操作 ...
    return *this; // 没有额外开销，只是返回引用
}
```

## 其他赋值操作符也应遵循此惯例

不仅基本赋值操作符 `=`，所有复合赋值操作符都应返回引用：

```cpp
class MyClass {
public:
    MyClass& operator+=(const MyClass& rhs) {
        // 实现加法赋值
        return *this;
    }
    
    MyClass& operator-=(const MyClass& rhs) {
        // 实现减法赋值
        return *this;
    }
    
    MyClass& operator*=(const MyClass& rhs) {
        // 实现乘法赋值
        return *this;
    }
    
    MyClass& operator/=(const MyClass& rhs) {
        // 实现除法赋值
        return *this;
    }
};
```

# 拷贝构造要拷贝基类的部分

**当你为派生类手动定义拷贝构造函数或拷贝赋值操作符时，编译器不会自动调用基类的相应拷贝函数**。

这会导致一个非常危险的情况：**派生类中的基类部分没有被正确拷贝**，从而引发资源泄漏、数据不一致和未定义行为。

当没有为类定义拷贝构造函数或拷贝赋值操作符时，编译器会为你自动生成它们。这些生成的函数会尝试拷贝每个成员（包括调用基类的拷贝函数）。

但是，**一旦手动定义了这些函数，编译器就认为你知道自己在做什么，不会再自动为你调用基类的拷贝操作**。你必须显式地调用它们。


```cpp
class Base {
private:
    int baseValue;
    // 假设这里可能还有其他资源，如指针、文件句柄等
    
public:
    Base(int val) : baseValue(val) {}
    
    // 基类的拷贝构造函数
    Base(const Base& other) : baseValue(other.baseValue) {
        std::cout << "Base copy constructor called\n";
    }
    
    // 基类的拷贝赋值操作符
    Base& operator=(const Base& other) {
        if (this != &other) {
            baseValue = other.baseValue;
        }
        std::cout << "Base copy assignment called\n";
        return *this;
    }
    
    virtual ~Base() {}
    
    int getBaseValue() const { return baseValue; }
};

class Derived : public Base {
private:
    int derivedValue;
    char* derivedData; // 派生类管理的资源
    
public:
    Derived(int baseVal, int derivedVal, const char* data)
        : Base(baseVal), derivedValue(derivedVal) {
        derivedData = new char[strlen(data) + 1];
        strcpy(derivedData, data);
    }
    
    ~Derived() {
        delete[] derivedData;
    }
    
    // 问题：忘记了调用基类的拷贝函数！
    Derived(const Derived& other)
        : derivedValue(other.derivedValue) {
        // 这里只拷贝了派生类的成员
        derivedData = new char[strlen(other.derivedData) + 1];
        strcpy(derivedData, other.derivedData);
        // 基类部分 baseValue 没有被拷贝！它保持未初始化或默认值
    }
    
    // 问题：同样忘记了基类的拷贝赋值
    Derived& operator=(const Derived& other) {
        if (this != &other) {
            // 只处理派生类的资源
            delete[] derivedData;
            derivedValue = other.derivedValue;
            derivedData = new char[strlen(other.derivedData) + 1];
            strcpy(derivedData, other.derivedData);
            // 基类的 baseValue 没有被赋值！
        }
        return *this;
    }
};
```

```cpp
int main() {
    Derived original(1, 2, "Hello");
    Derived copy(original); // 调用有问题的拷贝构造函数
    
    std::cout << "Original base value: " << original.getBaseValue() << std::endl; // 输出 1
    std::cout << "Copy base value: " << copy.getBaseValue() << std::endl;         // 输出随机值或0！
    
    return 0;
}
```

在这个例子中，`copy` 对象的基类部分 `baseValue` 没有被正确初始化，因为它从未调用 `Base` 的拷贝构造函数。

正确的拷贝构造函数

```cpp
Derived(const Derived& other)
    : Base(other), // 关键：显式调用基类的拷贝构造函数
      derivedValue(other.derivedValue) {
    derivedData = new char[strlen(other.derivedData) + 1];
    strcpy(derivedData, other.derivedData);
}
```

正确的拷贝赋值操作符

```cpp
Derived& operator=(const Derived& other) {
    if (this != &other) {
        Base::operator=(other); // 关键：显式调用基类的拷贝赋值操作符
        
        // 然后处理派生类的资源
        delete[] derivedData;
        derivedValue = other.derivedValue;
        derivedData = new char[strlen(other.derivedData) + 1];
        strcpy(derivedData, other.derivedData);
    }
    return *this;
}
```

1.  **`Base(other)`**：在初始化列表中，将 `other`（`Derived` 类型）传递给 `Base` 的拷贝构造函数。由于 `Derived` 是 `Base` 的派生类，这里会发生向上转型（upcasting），`Base` 的拷贝构造函数只能看到 `Base` 的部分。

2.  **`Base::operator=(other)`**：显式调用基类的拷贝赋值操作符。同样，`other` 会被向上转型为 `const Base&`，所以 `Base::operator=` 只能访问 `Base` 的部分。

在拷贝赋值操作符中，正确的顺序很重要：

1.  先调用基类的赋值操作
2.  然后处理派生类的资源

这样即使在处理派生类资源时抛出异常，基类部分也已经被正确赋值，对象处于一致状态。

## 现代C++的改进：拷贝-交换惯用法

使用拷贝-交换惯用法可以简化代码并提供强异常安全保证：

```cpp
#include <algorithm> // for std::swap

class Derived : public Base {
    // ... 其他成员同上 ...
    
    // 拷贝赋值操作符使用拷贝-交换惯用法
    Derived& operator=(Derived other) { // 注意：按值传递！
        swap(*this, other);
        return *this;
    }
    
    void swap(Derived& other) noexcept {
        using std::swap;
        Base::swap(other); // 如果Base有swap函数
        swap(derivedValue, other.derivedValue);
        swap(derivedData, other.derivedData);
    }
};
```

在这种方法中，参数 `other` 是通过拷贝构造函数创建的，而拷贝构造函数已经正确处理了基类部分。然后我们只需要交换当前对象和这个临时对象的内容。

# 资源管理类

| 特征           | 普通类           | 资源管理类                   |
| -------------- | ---------------- | ---------------------------- |
| **管理的对象** | 自己的数据成员   | 外部资源（文件、内存、锁等） |
| **构造函数**   | 初始化自己的成员 | 获取外部资源                 |
| **析构函数**   | 清理自己的成员   | 释放外部资源                 |
| **拷贝语义**   | 通常允许拷贝     | 通常禁止或特殊处理拷贝       |
| **主要目的**   | 表示业务概念     | 管理资源生命周期             |


## 普通类（非资源管理类）
```cpp
class Person {
private:
    std::string name;
    int age;
    
public:
    Person(const std::string& n, int a) : name(n), age(a) {
        // 只是初始化成员变量，不获取外部资源
    }
    
    ~Person() {
        // 析构函数是空的或只处理内部成员
        // std::string 会自己管理它的内存
    }
    
    // 其他方法...
};
```

## 资源管理类（RAII 类）
```cpp
class DatabaseConnection {
private:
    ConnectionHandle* connection; // 管理外部资源
    
public:
    DatabaseConnection(const std::string& connectionString) {
        // 获取外部资源：数据库连接
        connection = connectToDatabase(connectionString);
    }
    
    ~DatabaseConnection() {
        // 释放外部资源：关闭数据库连接
        if (connection) {
            disconnectFromDatabase(connection);
        }
    }
    
    // 禁止拷贝（因为数据库连接不能被共享）
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
};
```

## 异常安全保证
```cpp
void processData() {
    FileHandler file("data.txt"); // 获取资源
    // 如果这里抛出异常...
    processFileContents(file);    // 可能抛出异常
    // 即使抛出异常，文件也会被正确关闭
} // 资源自动释放
```

## 所有权管理
资源管理类需要明确资源的所有权：
- 独占所有权（禁止拷贝）
- 共享所有权（引用计数）
- 所有权转移（移动语义）

## 资源泄漏防护
```cpp
// 没有资源管理类 - 容易泄漏
void riskyFunction() {
    void* memory = malloc(1024);
    if (someCondition) return; // 内存泄漏！
    // 使用内存...
    free(memory); // 可能忘记调用
}

// 使用资源管理类 - 自动防护
void safeFunction() {
    MemoryHandler memory(1024); // 自动管理内存
    if (someCondition) return; // 内存自动释放
    // 使用内存...
} // 内存自动释放
```

## 为什么不是所有类都是资源管理类？

### 1. 单一职责原则
一个类应该只有一个主要职责。资源管理类的职责是管理资源，而不是同时表示业务概念。

```cpp
// 不好的设计：混合职责
class EmployeeWithFile {
private:
    std::string name;
    int id;
    FileHandler personalFile; // 混合了员工信息和文件管理
    
public:
    EmployeeWithFile(const std::string& n, int i, const std::string& filename)
        : name(n), id(i), personalFile(filename) {}
    
    // 现在这个类既有业务逻辑又有资源管理
};

// 好的设计：分离关注点
class Employee {
private:
    std::string name;
    int id;
    
public:
    Employee(const std::string& n, int i) : name(n), id(i) {}
    // 纯粹的业务类
};

// 在需要使用文件的地方，使用资源管理类
void processEmployeeFile(const Employee& emp, const std::string& filename) {
    FileHandler file(filename); // 资源管理
    // 处理文件...
}
```

### 2. 性能考虑
资源管理类通常有额外的开销（如引用计数、资源获取/释放），不是所有类都需要这些。

### 3. 设计清晰性
明确区分哪些类是管理资源的，哪些是表示业务概念的，使代码更易于理解和维护。

## 如何识别资源管理类？

一个类是资源管理类，如果它：

1. **在构造函数中获取外部资源**（不是初始化自己的数据成员）
2. **在析构函数中释放这些资源**
3. **通常禁止或特殊处理拷贝操作**
4. **主要目的是管理资源生命周期**

## 现代 C++ 中的资源管理

现代 C++ 鼓励使用现有的资源管理类，而不是自己创建：

```cpp
// 使用标准库的资源管理类
void modernCpp() {
    // 内存管理
    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
    std::shared_ptr<MyClass> shared = std::make_shared<MyClass>();
    
    // 文件管理 (C++17)
    std::ifstream file("data.txt");
    
    // 锁管理
    std::mutex mtx;
    std::lock_guard<std::mutex> lock(mtx);
    
    // 不需要自己实现资源管理类，除非有特殊需求
}
```

## 总结

虽然所有类都有构造函数和析构函数，但**资源管理类**有特殊的职责：

1. **管理外部资源**（而不仅仅是自己的数据成员）
2. **确保资源正确释放**（即使发生异常）
3. **明确资源所有权语义**（独占、共享或转移）
4. **提供异常安全保证**

普通类的目的是表示业务概念和封装数据，而资源管理类的目的是管理资源生命周期。理解这个区别对于编写健壮、安全的 C++ 代码至关重要。

资源管理类是 C++ RAII 理念的核心体现，它们使资源管理变得自动化、安全化，是现代 C++ 编程的基础。

# 类的大小
```cpp
class Base {
char data[3];
public:
    virtual void f() { cout << "Base::f" << endl; }
    virtual void g() { cout << "Base::g" << endl; }
    virtual void h() { cout << "Base::h" << endl; }
};
int main() {
    cout << sizeof(Base)<< endl;
    return 0;
}
```

在32位系统上，`sizeof(Base)` 的输出为 **8** 字节。原因如下：

- 由于 `Base` 类包含虚函数，编译器会为其生成一个虚函数表指针（vptr），该指针在32位系统上占用 **4 字节**。
- 类中的字符数组 `data[3]` 占用 **3 字节**。
- 为了内存对齐（通常按4字节对齐），编译器会在 `data[3]` 后添加 **1 字节** 的填充，使总大小达到8字节。

因此，`cout << sizeof(Base) << endl;` 会输出 `8`。

# 转换函数

转换函数是 C++ 中一种特殊的成员函数，它允许自定义类型与其他类型之间的隐式或显式转换。它们是 C++ 类型系统的重要组成部分，提供了强大的类型转换能力。

转换函数是一种特殊的成员函数，它告诉编译器如何将自定义类型转换为其他类型（包括内置类型和其他自定义类型）。它们使用 `operator` 关键字后接目标类型来定义。

```cpp
class MyClass {
public:
    // 转换函数语法
    operator TargetType() const;
};
```

## 转换为内置类型

```cpp
class Fraction {
private:
    int numerator;
    int denominator;
    
public:
    Fraction(int num, int den) : numerator(num), denominator(den) {}
    
    // 转换为 double
    operator double() const {
        return static_cast<double>(numerator) / denominator;
    }
    
    // 转换为 float
    operator float() const {
        return static_cast<float>(numerator) / denominator;
    }
    
    // 转换为 bool（判断分数是否有效）
    explicit operator bool() const {
        return denominator != 0;
    }
};

// 使用示例
Fraction f(3, 4);
double d = f;    // 隐式调用 operator double()
float fl = f;    // 隐式调用 operator float()
if (f) {         // 显式调用 operator bool()（因为是 explicit）
    // 分数有效
}
```

## 转换为其他自定义类型

```cpp
class Meters {
private:
    double value;
    
public:
    Meters(double m) : value(m) {}
    
    // 转换为英尺
    operator class Feet() const;
};

class Feet {
private:
    double value;
    
public:
    Feet(double ft) : value(ft) {}
    
    // 转换为米
    operator Meters() const {
        return Meters(value * 0.3048);
    }
};

// 实现 Meters 到 Feet 的转换
Meters::operator Feet() const {
    return Feet(value / 0.3048);
}

// 使用示例
Meters m(10);
Feet f = m;  // 隐式转换
```

## 转换为指针或引用类型

```cpp
class SmartPointer {
private:
    int* ptr;
    
public:
    SmartPointer(int value) : ptr(new int(value)) {}
    
    ~SmartPointer() { delete ptr; }
    
    // 转换为原始指针
    operator int*() const {
        return ptr;
    }
    
    // 转换为 const 指针
    operator const int*() const {
        return ptr;
    }
};

// 使用示例
SmartPointer sp(42);
int* raw_ptr = sp;  // 隐式转换为原始指针
```

# 类中引用成员

```cpp
#include <iostream>
using namespace std;

struct Bar { 
    char c[16];  // 16字节的字符数组
};

struct Test { 
    Bar& bar;    // 对Bar的引用
};

int main() {
    cout << sizeof(Test::bar);  // 输出引用的"大小"
}
```

1. **引用声明但不初始化**：
   在类定义中声明引用成员而不初始化是允许的，只要不创建该类的实例。编译器只在需要创建对象时才要求引用必须初始化。

2. **sizeof 是编译时操作**：
   `sizeof(Test::bar)` 在编译时计算，不需要实际创建 Test 对象，因此不会触发"引用未初始化"的错误。

关键点：**当对引用使用 sizeof 时，它返回被引用类型的大小，而不是引用本身的大小**。

所以：
- `Bar` 的大小是 16 字节（因为 `char c[16]`）
- `sizeof(Test::bar)` 返回的是 `Bar` 的大小，即 16


```cpp
int main() {
    Bar actualBar;
    // Test test; // 错误: 引用成员"bar"需要初始化
    
    // 正确的方式是使用初始化列表
    Test test = {actualBar}; // 正确: 引用被初始化
    
    cout << sizeof(Test::bar); // 仍然输出16
}
```

# 纯虚函数可以带默认实现

**使纯虚函数有实现，包含纯虚函数的类仍然是抽象类，不能直接实例化**。

```cpp
#include <iostream>
using namespace std;

class AbstractClass {
public:
    // 纯虚函数声明，但有实现
    virtual void pureVirtual() = 0;
    
    virtual ~AbstractClass() = default;
};

// 纯虚函数的实现（在类外定义）
void AbstractClass::pureVirtual() {
    cout << "纯虚函数的默认实现" << endl;
}

int main() {
    // AbstractClass obj; // 错误：不能实例化抽象类
    
    // 即使纯虚函数有实现，仍然不能直接创建实例
    return 0;
}
```

这种设计提供了重要的灵活性：

1. **强制派生类提供接口**：纯虚函数强制派生类必须重写该方法
2. **提供默认实现**：基类可以提供默认实现，派生类可以选择性使用
3. **保持抽象性**：即使有默认实现，类仍然是抽象的，不能直接实例化


派生类必须重写纯虚函数，但可以选择性地调用基类的实现：

```cpp
class ConcreteClass : public AbstractClass {
public:
    // 必须重写纯虚函数
    void pureVirtual() override {
        // 可以选择调用基类的实现
        AbstractClass::pureVirtual(); // 调用纯虚函数的实现
        
        // 添加派生类特有的行为
        cout << "派生类的额外实现" << endl;
    }
};

class AnotherConcrete : public AbstractClass {
public:
    // 也可以完全重写，不调用基类实现
    void pureVirtual() override {
        cout << "完全重写的实现" << endl;
    }
};

int main() {
    // 现在可以创建派生类的实例
    ConcreteClass obj1;
    obj1.pureVirtual();
    
    AnotherConcrete obj2;
    obj2.pureVirtual();
    
    return 0;
}
```

输出结果：
```
纯虚函数的默认实现
派生类的额外实现
完全重写的实现
```