C++ 学习笔记

# 嵌套类型
在 C++ 中，**嵌套类型**是指在一个类或结构体内部定义的类型。这些类型可以是类、结构体、枚举或类型别名（`typedef` 或 `using`）。

嵌套类型是在类或结构体内部定义的类型。这些类型可以访问外部类或结构体的成员，但外部类或结构体不能直接访问嵌套类型的成员。

## 示例代码

```cpp
class Outer {
public:
    // 嵌套类型
    class Inner {
    public:
        void print() {
            std::cout << "Hello from Inner!" << std::endl;
        }
    };

    // 使用嵌套类型
    void useInner() {
        Inner inner;
        inner.print();
    }
};

int main() {
    Outer::Inner inner; // 直接使用嵌套类型
    inner.print();

    Outer outer;
    outer.useInner();

    return 0;
}
```

```
Hello from Inner!
Hello from Inner!
```

## 嵌套类型的用途

嵌套类型的主要用途包括：
- **封装**：将相关类型封装在一起，提高代码的可读性和可维护性。
- **访问控制**：嵌套类型可以访问外部类的私有成员，但外部类不能直接访问嵌套类型的成员。
- **命名空间**：嵌套类型可以避免命名冲突，因为它们的作用域被限制在外部类中。

# 虚函数表 (Virtual Function Table, vtable)

这是一个理解C++多态（Polymorphism）核心机制的关键概念。

在面向对象编程中，多态意味着“一个接口，多种实现”。在C++中，通过以下方式实现多态：

1.  **基类**中使用 `virtual` 关键字声明函数（虚函数）。
2.  **派生类**中**重写（override）** 这个虚函数。
3.  使用**基类的指针或引用**来指向**派生类的对象**。
4.  通过该指针或引用调用虚函数时，实际调用的是派生类中重写的版本。

**核心问题：** 在编译阶段，编译器只知道指针是基类类型的，它无法确定这个指针指向的到底是基类对象还是某个派生类对象。那么程序在运行时，如何正确地决定应该调用哪个函数呢？

**答案：** 这就是虚函数表要解决的问题。它是一种在运行时进行函数解析的机制，是C++实现动态绑定的基石。

**虚函数表（vtable）** 是一个编译器在编译时为每个**包含虚函数的类**（或者从包含虚函数的类继承而来的类）自动生成的**静态函数指针数组**。

*   **每个类一个表**：每个有虚函数的类都有自己的虚函数表。
*   **表的内容**：表中的每一个条目（slot）都是该类的一个虚函数的地址。这些条目按照虚函数声明的顺序排列。
*   **指向表的指针（vptr）**：编译器还会隐式地为该类的**每一个对象**添加一个隐藏的指针成员（通常称为 `vptr`）。这个 `vptr` 指向该类的虚函数表。

## 机制和原理：内存布局与动态绑定

```cpp
class Base {
public:
    virtual void func1() { cout << "Base::func1" << endl; }
    virtual void func2() { cout << "Base::func2" << endl; }
    void func3() { cout << "Base::func3 (non-virtual)" << endl; } // 非虚函数
    int base_data;
};

class Derived : public Base {
public:
    void func1() override { cout << "Derived::func1" << endl; } // 重写 func1
    virtual void func4() { cout << "Derived::func4" << endl; } // 新的虚函数
    int derived_data;
};
```

**1. 编译期：生成虚函数表**

编译器会为 `Base` 和 `Derived` 类分别生成一个虚函数表。

*   **`Base` 类的 vtable:**
    | 索引 | 函数指针       | 指向的实际函数  |
    | :--- | :------------- | :-------------- |
    | 0    | `&Base::func1` | `Base::func1()` |
    | 1    | `&Base::func2` | `Base::func2()` |

*   **`Derived` 类的 vtable:**
    | 索引 | 函数指针          | 指向的实际函数     |
    | :--- | :---------------- | :----------------- |
    | 0    | `&Derived::func1` | `Derived::func1()` | // 重写了，地址不同   |
    | 1    | `&Base::func2`    | `Base::func2()`    | // 没重写，继承基类的 |
    | 2    | `&Derived::func4` | `Derived::func4()` | // 新增的虚函数       |

**注意：** 派生类的虚函数表首先包含基类的虚函数条目，然后才是自己的。这保证了基类和派生类中相同功能的虚函数在表中的**索引位置（offset）是相同的**。这是实现多态的关键。

**2. 对象构建时：初始化 vptr**

当创建对象时，会发生以下事情：

```cpp
Derived d;
```

*   在构造 `Derived` 对象 `d` 时，它的内存中不仅包含 `Base` 的成员 `base_data` 和自身的成员 `derived_data`，**开头还会有一个隐藏的指针 `vptr`** (通常在所有显式定义的成员之前)。
*   在 `Derived` 的构造函数被调用过程中（在初始化列表之后，函数体之前），这个 `vptr` 会被设置为指向 `Derived` 类的虚函数表。

**`Derived` 对象 `d` 的内存布局：**
```
+--------------------------+
| vptr (隐藏成员)          | ----> 指向 Derived::vtable
+--------------------------+
| base_data (来自 Base)    |
+--------------------------+
| derived_data (来自 Derived) |
+--------------------------+
```

**3. 运行时：通过动态绑定调用函数**

```cpp
Base* bp = new Derived(); // bp 是 Base 指针，指向一个 Derived 对象
bp->func1(); // 输出 "Derived::func1"
```

`bp->func1()` 这行代码的执行过程如下：

1.  **编译器层面：** 编译器看到 `bp` 是 `Base*` 类型，并且 `func1` 是虚函数。它知道不能直接进行静态绑定（即直接调用 `Base::func1`）。
2.  **生成指令：** 编译器会生成一系列指令来执行**动态绑定**：
    a. 通过 `bp` 指针找到它所指向的对象。
    b. 从该对象的内存起始位置取出 `vptr`（因为编译器知道 `vptr` 总是在对象的最开始）。
    c. 通过 `vptr` 找到类的 `vtable`。
    d. 在 `vtable` 中找到第 `0` 个条目（因为 `func1` 在基类中是第一个声明的虚函数，索引为0）。
    e. 调用该条目中存储的函数地址（即 `&Derived::func1`）。
3.  **运行时执行：** CPU 执行上述指令，最终跳转到 `Derived::func1` 的代码并执行。

**对于非虚函数调用：**
```cpp
bp->func3(); // 输出 "Base::func3 (non-virtual)"
```
编译器在编译时就知道 `bp` 是 `Base*` 类型，并且 `func3` 不是虚函数。所以它直接进行静态绑定，生成调用 `Base::func3` 的指令，完全不会涉及 vtable。

## 虚函数表 (vtable) 的创建时机

*   **编译期（Compile Time）**
    vtable 是编译器在编译源代码时生成的。它是一个**静态的数据结构**，存储在程序的**只读数据段**（通常与代码段在一起）。每个类有且只有一个 vtable，所有该类的对象共享同一个 vtable。

## 虚指针 (vptr) 的初始化和设置时机

*   **运行期（Run Time）**，具体是在**对象的构造过程中**。
    当一个对象被创建时，它的 `vptr` 的初始化是**由编译器在类的构造函数中自动插入代码来完成的**。

## 对象的构造过程

当一个派生类对象被创建时（例如 `Derived d;`），其完整的构造顺序如下：

1.  **分配内存**：首先为整个派生类对象分配足够的内存（包括基类子对象和派生类自身成员的内存）。

2.  **构造基类部分**：
    *   **调用基类构造函数**：根据初始化列表或默认规则，调用基类的构造函数。
    *   **设置基类 vptr**：**在进入基类构造函数体 `{...}` 之前**，编译器插入代码，将**对象中基类子对象部分的 `vptr`** 设置为指向**基类的虚函数表（Base::vtable）**。
    *   **执行基类初始化列表**：执行基类构造函数的初始化列表。
    *   **执行基类构造函数体**：执行基类构造函数函数体内的代码。
    *   **此时**，如果基类构造函数中调用虚函数，由于 `vptr` 指向 Base::vtable，因此会调用基类自己的版本，而不是派生类重写的版本。

3.  **构造派生类部分**：
    *   **设置派生类 vptr**：在基类构造完成后，**在进入派生类构造函数体 `{...}` 之前**，编译器再次插入代码，将对象的 `vptr` **重新设置为指向派生类的虚函数表（Derived::vtable）**。这一步覆盖了之前在基类构造时设置的 `vptr`。
    *   **执行派生类初始化列表**：执行派生类构造函数的初始化列表（初始化派生类自己的成员以及虚基类等）。
    *   **执行派生类构造函数体**：执行派生类构造函数函数体内的代码。
    *   **从此之后**，任何通过该对象进行的虚函数调用，都将使用 `Derived::vtable` 进行解析。

**关键点：**
*   `vptr` 的设置发生在**每个构造函数的初始化阶段**（在初始化列表处理之后，构造函数体执行之前）。
*   在构造过程中，`vptr` 的值会**被多次修改**。它首先被设置为当前正在构造的类的 vtable，以确保在构造函数体内调用虚函数时行为是确定和安全的（调用当前类的版本）。
*   最终，当派生类的构造函数完成后，`vptr` 才稳定地指向派生类的 vtable。

## 析构过程（完全相反的顺序）

析构过程是构造过程的逆序，同样遵循严格的规则：

1.  **析构派生类部分**：
    *   **执行派生类析构函数体**：执行 `~Derived() {...}` 函数体内的代码。
    *   **设置派生类 vptr**：在派生类析构函数体执行完毕后，编译器插入代码，将对象的 `vptr` **重新设置为指向基类的虚函数表（Base::vtable）**。这样做的目的是确保在后续的析构过程中（比如基类析构函数中调用虚函数），调用的是基类的版本，因为派生类的部分已经被销毁了，再调用派生类的函数是危险的。
    *   **调用成员对象和基类的析构函数**：编译器自动调用派生类成员对象的析构函数（按照声明的逆序），然后调用基类的析构函数。

2.  **析构基类部分**：
    *   **执行基类析构函数体**：执行 `~Base() {...}` 函数体内的代码。
    *   （如果需要）**设置基类 vptr**：在基类析构函数体执行完毕后，如果基类还有自己的基类，`vptr` 可能会被再次设置指向更基类的 vtable。对于没有更基类的类，这一步可能就不需要了。
    *   **释放内存**：最终，对象占用的内存被释放。


## 总结

*   **构造顺序**：基类 -> 派生类。`vptr` 的设置跟随这个顺序，从基类的表逐步变为派生类的表。
*   **析构顺序**：派生类 -> 基类。`vptr` 的设置也跟随这个顺序，从派生类的表**回退**到基类的表。
*   **黄金法则**：**绝对不要在构造函数和析构函数中调用虚函数**。因为在这两个阶段，`vptr` 指向的是**当前正在被构造或析构的类**的虚函数表，而不是最终派生类的表。这意味着不会得到多态行为，调用的是当前层次的函数实现，这可能不是期望的。

**示例：**
```cpp
Derived::Derived(/* args */) // 构造函数
    : Base(/* base args */) // 1. 先调用基类构造函数
    //, ... 其他初始化列表
{
    // 在进入函数体之前，编译器插入代码：`this->vptr = &Derived::vtable;`
    // 2. 设置 vptr 指向 Derived 的 vtable
    derived_data = 0; // 3. 执行函数体内的代码
}
```

## 关键点

1.  **目的**：vtable 是实现C++运行时多态（动态绑定）的核心机制。
2.  **是什么**：
    *   **vtable**： 每个类一个，静态函数指针数组。
    *   **vptr**： 每个对象一个，隐藏指针，指向其类的 vtable。
3.  **工作原理**： 通过对象的 `vptr` 找到类的 `vtable`，再通过固定的索引找到要调用的虚函数地址。
4.  **创建时机**：
    *   **vtable** -> **编译期**生成，存在于静态存储区。
    *   **vptr** -> **运行期**在对象的构造/析构过程中，由编译器自动插入的代码进行设置。
5.  **性能开销**：
    *   **空间开销**：每个对象需要一个额外的指针（vptr）空间。每个类需要一个vtable的空间。
    *   **时间开销**：每次调用虚函数比调用非虚函数多一次间接寻址（通过vptr找vtable，再通过索引找函数地址）的开销。现代CPU对此有很好的优化，但理论上仍有轻微损耗。
    *   **编译器优化**：通常虚函数调用无法被内联。
6.  **其他说明**：
    *   对于**多重继承**和**虚拟继承**，vtable 的结构会变得更加复杂，但核心思想不变。
    *   使用 `final` 关键字可以阻止类被继承或虚函数被重写，有时允许编译器进行去虚拟化（devirtualization）优化，绕过 vtable。

