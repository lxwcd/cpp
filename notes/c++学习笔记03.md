C++ 学习笔记

# RTTI

RTTI（Run-Time Type Identification，运行时类型识别）是 C++ 的一个特性，允许程序在运行时检查对象的实际类型。RTTI 的主要功能包括：
- **`typeid` 运算符**：用于获取对象的类型信息。
- **`dynamic_cast` 运算符**：用于安全地将基类指针或引用转换为派生类指针或引用。
- RTTI 依赖于多态性，只有在类中包含虚函数时才能使用 `dynamic_cast` 和 `typeid`。
- `dynamic_cast` 只能用于指针或引用类型的转换，不能用于基本数据类型。

RTTI 的实现依赖于类的多态性，即类中必须包含虚函数。当类中有虚函数时，编译器会为每个类生成一个虚函数表（vtable），并在对象中添加一个指向该表的指针（vptr）。`typeid` 和 `dynamic_cast` 的实现通常依赖于 vtable。

它默认在大多数编译器中启用，但可以通过编译器选项或项目属性进行控制。

## `typeid` 的使用
`typeid` 运算符返回一个 `std::type_info` 对象，该对象包含类型的信息，如类型名称。
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    const std::type_info& typeInfo = typeid(*basePtr);
    std::cout << "Object type: " << typeInfo.name() << std::endl;
    delete basePtr;
    return 0;
}
```
在上述代码中，`typeid(*basePtr)` 返回 `Derived` 类型的信息。

### 1. **动态类型检查**
`typeid` 可以在运行时检查对象的实际类型，这对于多态类尤其有用。例如，当有一个基类指针，但不确定它指向的具体派生类对象时，`typeid` 可以帮助确定。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    if (typeid(*basePtr) == typeid(Derived)) {
        std::cout << "The object is of type Derived" << std::endl;
    } else {
        std::cout << "The object is not of type Derived" << std::endl;
    }
    delete basePtr;
    return 0;
}
```

输出
```
The object is of type Derived
```

在这个例子中，`typeid(*basePtr)` 返回了对象的实际类型信息，通过比较 `typeid(Derived)`，可以确定 `basePtr` 指向的对象是否是 `Derived` 类型。

### 2. **类型信息的获取**
`typeid` 返回一个 `std::type_info` 对象，该对象包含类型的信息，如类型名称。这在调试和日志记录中非常有用。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    const std::type_info& typeInfo = typeid(*basePtr);
    std::cout << "Object type: " << typeInfo.name() << std::endl;
    delete basePtr;
    return 0;
}
```

输出
```
Object type: 7Derived
```

在这个例子中，`type_info.name()` 返回了对象的实际类型名称。需要注意的是，`name()` 返回的类型名称可能不是完全可读的，具体取决于编译器的实现。例如，GCC 返回的类型名称可能包含修饰符（如 `7Derived` 表示 `Derived` 类型，`7` 是类型名称的长度）。

### 3. **类型安全的容器**
`typeid` 可以用于实现类型安全的容器。例如，当需要存储多种类型的对象时，可以通过 `typeid` 确保容器中的对象类型一致。

```cpp
#include <iostream>
#include <typeinfo>
#include <vector>
#include <memory>

class Base {
public:
    virtual void print() const {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() const override {
        std::cout << "Derived class" << std::endl;
    }
};

class TypeSafeContainer {
public:
    void add(std::shared_ptr<Base> obj) {
        if (container.empty() || typeid(*container[0]) == typeid(*obj)) {
            container.push_back(obj);
        } else {
            throw std::runtime_error("Type mismatch");
        }
    }

    void printAll() const {
        for (const auto& obj : container) {
            obj->print();
        }
    }

private:
    std::vector<std::shared_ptr<Base>> container;
};

int main() {
    TypeSafeContainer container;
    container.add(std::make_shared<Derived>());
    container.add(std::make_shared<Derived>());
    // container.add(std::make_shared<Base>()); // This will throw an exception

    container.printAll();
    return 0;
}
```

输出
```
Derived class
Derived class
```

在这个例子中，`TypeSafeContainer` 使用 `typeid` 确保所有添加到容器中的对象类型一致。如果尝试添加不同类型的对象，会抛出异常。

### 4. **调试和日志记录**
`typeid` 可以在调试和日志记录中提供类型信息，帮助开发者更好地理解程序的运行状态。

```cpp
#include <iostream>
#include <typeinfo>
#include <vector>

void logObject(const std::vector<int>& obj) {
    std::cout << "Logging object of type: " << typeid(obj).name() << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3};
    logObject(vec);
    return 0;
}
```

输出
```
Logging object of type: St6vectorIiSaIiEE
```

在这个例子中，`typeid(obj).name()` 提供了对象的类型信息，帮助记录日志。

### 5. **动态类型转换**
虽然 `dynamic_cast` 是更常用的动态类型转换工具，但在某些情况下，`typeid` 可以作为辅助手段。例如，当 `dynamic_cast` 失败时，可以通过 `typeid` 进一步检查类型。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr != nullptr) {
        std::cout << "Dynamic cast successful" << std::endl;
        derivedPtr->print();
    } else {
        std::cout << "Dynamic cast failed" << std::endl;
        std::cout << "Actual type: " << typeid(*basePtr).name() << std::endl;
    }
    delete basePtr;
    return 0;
}
```

输出
```
Dynamic cast successful
Derived class
```

在这个例子中，`dynamic_cast` 成功后，`typeid(*basePtr).name()` 提供了对象的实际类型信息，帮助确认类型转换的正确性。

## `dynamic_cast` 的使用
`dynamic_cast` 用于安全地将基类指针或引用转换为派生类指针或引用。它依赖于多态，因此基类必须包含虚函数。
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr != nullptr) {
        std::cout << "Dynamic cast successful" << std::endl;
        derivedPtr->print();
    }
    delete basePtr;
    return 0;
}
```
在上述代码中，`dynamic_cast<Derived*>(basePtr)` 将 `Base` 类型的指针安全地转换为 `Derived` 类型的指针。

# 前向声明
在C++中，前向声明（Forward Declaration）是一种告诉编译器某个标识符（如类名、函数名）存在但尚未定义的方式。它主要用于解决编译时的依赖问题，尤其是在头文件中避免重复包含和循环依赖。

## 类的前向声明
类的前向声明通常用于以下场景：
- 当两个类相互引用时（即存在循环依赖）。
- 当某个类只需要知道另一个类的类型，而不需要知道其具体实现时。

```cpp
class ClassName; // 类的前向声明
```

假设有两个类 `A` 和 `B`，它们相互引用。如果不使用前向声明，编译器会报错，因为编译器在编译一个类时需要知道另一个类的完整定义。

```cpp
// A.h
#ifndef A_H
#define A_H

class B; // 类B的前向声明

class A {
public:
    void useB(B* b); // 使用类B的对象
};

#endif // A_H

// B.h
#ifndef B_H
#define B_H

#include "A.h" // 包含类A的定义

class B {
public:
    A* a; // 类A的对象指针
    void useA();
};

#endif // B_H

// A.cpp
#include "A.h"
#include "B.h"

void A::useB(B* b) {
    // 使用类B的对象
    b->useA(); // 假设类B有一个useA方法
}

// B.cpp
#include "B.h"

void B::useA() {
    if (a) {
        // 使用类A的对象
        a->useB(this); // 假设类A有一个useB方法
    }
}

// main.cpp
#include "A.h"
#include "B.h"

int main() {
    A a;
    B b;
    b.a = &a; // 初始化类A的对象指针
    a.useB(&b); // 调用类A的方法，传入类B的对象
    return 0;
}
```

**解释：**
- 在 `A.h` 中，我们对类 `B` 进行了前向声明，这样编译器就知道 `B` 是一个类，但不需要知道其具体定义。
- 在 `B.h` 中，我们包含了 `A.h`，因为类 `B` 需要使用类 `A` 的完整定义。
- 在 `A.cpp` 中，我们实现了 `A` 的方法 `useB`，此时可以使用类 `B` 的完整定义。
- 在 `B.cpp` 中，我们实现了 `B` 的方法 `useA`，此时可以使用类 `A` 的完整定义。

## 函数的前向声明
函数的前向声明通常用于以下场景：
- 当函数在调用它的代码之前尚未定义时。
- 在多文件项目中，确保编译器知道函数的签名。

```cpp
ReturnType functionName(ArgumentType1 arg1, ArgumentType2 arg2, ...); // 函数的前向声明
```

假设有两个函数 `func1` 和 `func2`，其中 `func1` 调用了 `func2`，而 `func2` 调用了 `func1`。如果不使用前向声明，编译器会报错，因为编译器在编译一个函数时需要知道另一个函数的签名。

```cpp
#include <iostream>

// 函数func2的前向声明
void func2();

void func1() {
    std::cout << "Function 1 called" << std::endl;
    func2(); // 调用函数func2
}

void func2() {
    std::cout << "Function 2 called" << std::endl;
    // 不再调用func1，避免无限递归
}

int main() {
    func1(); // 调用函数func1
    return 0;
}
```
