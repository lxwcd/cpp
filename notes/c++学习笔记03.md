C++ 学习笔记

# RTTI

RTTI（Run-Time Type Identification，运行时类型识别）是 C++ 的一个特性，允许程序在运行时检查对象的实际类型。RTTI 的主要功能包括：
- **`typeid` 运算符**：用于获取对象的类型信息。
- **`dynamic_cast` 运算符**：用于安全地将基类指针或引用转换为派生类指针或引用。
- RTTI 依赖于多态性，只有在类中包含虚函数时才能使用 `dynamic_cast` 和 `typeid`。
- `dynamic_cast` 只能用于指针或引用类型的转换，不能用于基本数据类型。

RTTI 的实现依赖于类的多态性，即类中必须包含虚函数。当类中有虚函数时，编译器会为每个类生成一个虚函数表（vtable），并在对象中添加一个指向该表的指针（vptr）。`typeid` 和 `dynamic_cast` 的实现通常依赖于 vtable。

它默认在大多数编译器中启用，但可以通过编译器选项或项目属性进行控制。

## `typeid` 的使用
`typeid` 运算符返回一个 `std::type_info` 对象，该对象包含类型的信息，如类型名称。
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    const std::type_info& typeInfo = typeid(*basePtr);
    std::cout << "Object type: " << typeInfo.name() << std::endl;
    delete basePtr;
    return 0;
}
```
在上述代码中，`typeid(*basePtr)` 返回 `Derived` 类型的信息。

### 1. **动态类型检查**
`typeid` 可以在运行时检查对象的实际类型，这对于多态类尤其有用。例如，当有一个基类指针，但不确定它指向的具体派生类对象时，`typeid` 可以帮助确定。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    if (typeid(*basePtr) == typeid(Derived)) {
        std::cout << "The object is of type Derived" << std::endl;
    } else {
        std::cout << "The object is not of type Derived" << std::endl;
    }
    delete basePtr;
    return 0;
}
```

输出
```
The object is of type Derived
```

在这个例子中，`typeid(*basePtr)` 返回了对象的实际类型信息，通过比较 `typeid(Derived)`，可以确定 `basePtr` 指向的对象是否是 `Derived` 类型。

### 2. **类型信息的获取**
`typeid` 返回一个 `std::type_info` 对象，该对象包含类型的信息，如类型名称。这在调试和日志记录中非常有用。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    const std::type_info& typeInfo = typeid(*basePtr);
    std::cout << "Object type: " << typeInfo.name() << std::endl;
    delete basePtr;
    return 0;
}
```

输出
```
Object type: 7Derived
```

在这个例子中，`type_info.name()` 返回了对象的实际类型名称。需要注意的是，`name()` 返回的类型名称可能不是完全可读的，具体取决于编译器的实现。例如，GCC 返回的类型名称可能包含修饰符（如 `7Derived` 表示 `Derived` 类型，`7` 是类型名称的长度）。

### 3. **类型安全的容器**
`typeid` 可以用于实现类型安全的容器。例如，当需要存储多种类型的对象时，可以通过 `typeid` 确保容器中的对象类型一致。

```cpp
#include <iostream>
#include <typeinfo>
#include <vector>
#include <memory>

class Base {
public:
    virtual void print() const {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() const override {
        std::cout << "Derived class" << std::endl;
    }
};

class TypeSafeContainer {
public:
    void add(std::shared_ptr<Base> obj) {
        if (container.empty() || typeid(*container[0]) == typeid(*obj)) {
            container.push_back(obj);
        } else {
            throw std::runtime_error("Type mismatch");
        }
    }

    void printAll() const {
        for (const auto& obj : container) {
            obj->print();
        }
    }

private:
    std::vector<std::shared_ptr<Base>> container;
};

int main() {
    TypeSafeContainer container;
    container.add(std::make_shared<Derived>());
    container.add(std::make_shared<Derived>());
    // container.add(std::make_shared<Base>()); // This will throw an exception

    container.printAll();
    return 0;
}
```

输出
```
Derived class
Derived class
```

在这个例子中，`TypeSafeContainer` 使用 `typeid` 确保所有添加到容器中的对象类型一致。如果尝试添加不同类型的对象，会抛出异常。

### 4. **调试和日志记录**
`typeid` 可以在调试和日志记录中提供类型信息，帮助开发者更好地理解程序的运行状态。

```cpp
#include <iostream>
#include <typeinfo>
#include <vector>

void logObject(const std::vector<int>& obj) {
    std::cout << "Logging object of type: " << typeid(obj).name() << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3};
    logObject(vec);
    return 0;
}
```

输出
```
Logging object of type: St6vectorIiSaIiEE
```

在这个例子中，`typeid(obj).name()` 提供了对象的类型信息，帮助记录日志。

### 5. **动态类型转换**
虽然 `dynamic_cast` 是更常用的动态类型转换工具，但在某些情况下，`typeid` 可以作为辅助手段。例如，当 `dynamic_cast` 失败时，可以通过 `typeid` 进一步检查类型。

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr != nullptr) {
        std::cout << "Dynamic cast successful" << std::endl;
        derivedPtr->print();
    } else {
        std::cout << "Dynamic cast failed" << std::endl;
        std::cout << "Actual type: " << typeid(*basePtr).name() << std::endl;
    }
    delete basePtr;
    return 0;
}
```

输出
```
Dynamic cast successful
Derived class
```

在这个例子中，`dynamic_cast` 成功后，`typeid(*basePtr).name()` 提供了对象的实际类型信息，帮助确认类型转换的正确性。

## `dynamic_cast` 的使用
`dynamic_cast` 用于安全地将基类指针或引用转换为派生类指针或引用。它依赖于多态，因此基类必须包含虚函数。
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr != nullptr) {
        std::cout << "Dynamic cast successful" << std::endl;
        derivedPtr->print();
    }
    delete basePtr;
    return 0;
}
```
在上述代码中，`dynamic_cast<Derived*>(basePtr)` 将 `Base` 类型的指针安全地转换为 `Derived` 类型的指针。

# 前向声明
在C++中，前向声明（Forward Declaration）是一种告诉编译器某个标识符（如类名、函数名）存在但尚未定义的方式。它主要用于解决编译时的依赖问题，尤其是在头文件中避免重复包含和循环依赖。

## 类的前向声明
类的前向声明通常用于以下场景：
- 当两个类相互引用时（即存在循环依赖）。
- 当某个类只需要知道另一个类的类型，而不需要知道其具体实现时。

```cpp
class ClassName; // 类的前向声明
```

假设有两个类 `A` 和 `B`，它们相互引用。如果不使用前向声明，编译器会报错，因为编译器在编译一个类时需要知道另一个类的完整定义。

```cpp
// A.h
#ifndef A_H
#define A_H

class B; // 类B的前向声明

class A {
public:
    void useB(B* b); // 使用类B的对象
};

#endif // A_H

// B.h
#ifndef B_H
#define B_H

#include "A.h" // 包含类A的定义

class B {
public:
    A* a; // 类A的对象指针
    void useA();
};

#endif // B_H

// A.cpp
#include "A.h"
#include "B.h"

void A::useB(B* b) {
    // 使用类B的对象
    b->useA(); // 假设类B有一个useA方法
}

// B.cpp
#include "B.h"

void B::useA() {
    if (a) {
        // 使用类A的对象
        a->useB(this); // 假设类A有一个useB方法
    }
}

// main.cpp
#include "A.h"
#include "B.h"

int main() {
    A a;
    B b;
    b.a = &a; // 初始化类A的对象指针
    a.useB(&b); // 调用类A的方法，传入类B的对象
    return 0;
}
```

**解释：**
- 在 `A.h` 中，我们对类 `B` 进行了前向声明，这样编译器就知道 `B` 是一个类，但不需要知道其具体定义。
- 在 `B.h` 中，我们包含了 `A.h`，因为类 `B` 需要使用类 `A` 的完整定义。
- 在 `A.cpp` 中，我们实现了 `A` 的方法 `useB`，此时可以使用类 `B` 的完整定义。
- 在 `B.cpp` 中，我们实现了 `B` 的方法 `useA`，此时可以使用类 `A` 的完整定义。

## 函数的前向声明
函数的前向声明通常用于以下场景：
- 当函数在调用它的代码之前尚未定义时。
- 在多文件项目中，确保编译器知道函数的签名。

```cpp
ReturnType functionName(ArgumentType1 arg1, ArgumentType2 arg2, ...); // 函数的前向声明
```

假设有两个函数 `func1` 和 `func2`，其中 `func1` 调用了 `func2`，而 `func2` 调用了 `func1`。如果不使用前向声明，编译器会报错，因为编译器在编译一个函数时需要知道另一个函数的签名。

```cpp
#include <iostream>

// 函数func2的前向声明
void func2();

void func1() {
    std::cout << "Function 1 called" << std::endl;
    func2(); // 调用函数func2
}

void func2() {
    std::cout << "Function 2 called" << std::endl;
    // 不再调用func1，避免无限递归
}

int main() {
    func1(); // 调用函数func1
    return 0;
}
```

# RAII 
RAII（Resource Acquisition Is Initialization，资源获取即初始化）是C++中一种重要的编程范式，它通过将资源管理与对象的生命周期绑定在一起，确保资源在使用完毕后能够被正确地释放，从而避免资源泄漏等问题。

RAII 的核心思想是将资源的获取和释放分别放在对象的构造函数和析构函数中。当对象被创建时，资源被分配；当对象被销毁时，资源被释放。这样可以保证资源的生命周期与对象的生命周期一致，从而避免资源泄漏和悬空指针等问题。

RAII 主要用于管理动态分配的内存、文件句柄、网络连接、互斥锁等资源。

RAII 的实现通常依赖于智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）、文件流对象（如 `std::ifstream` 和 `std::ofstream`）等标准库提供的工具，也可以通过自定义类来实现。

RAII 的优点：
- **自动管理资源**：资源的分配和释放由对象的生命周期自动管理，无需手动干预。
- **异常安全**：即使在发生异常的情况下，资源也能被正确释放。
- **代码简洁**：减少了手动管理资源的代码，使代码更加简洁易读。

## 示例 1：使用智能指针管理动态内存
```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() {
        std::cout << "Resource acquired\n";
    }
    ~Resource() {
        std::cout << "Resource released\n";
    }
};

int main() {
    {
        // 使用智能指针管理动态分配的资源
        std::unique_ptr<Resource> resource(new Resource());
        // 当 resource 离开作用域时，会自动调用析构函数释放资源
    }
    // 输出：
    // Resource acquired
    // Resource released
    return 0;
}
```

## 示例 2：自定义类实现 RAII
假设需要管理一个文件句柄，可以自定义一个类来实现 RAII：
```cpp
#include <iostream>
#include <fstream>

class FileHandle {
private:
    std::ofstream file;

public:
    FileHandle(const std::string& filename) {
        file.open(filename, std::ios::out);
        if (!file.is_open()) {
            throw std::runtime_error("Failed to open file");
        }
        std::cout << "File opened\n";
    }

    ~FileHandle() {
        file.close();
        std::cout << "File closed\n";
    }

    std::ofstream& get() {
        return file;
    }
};

int main() {
    try {
        {
            FileHandle file("example.txt");
            file.get() << "Hello, RAII!\n";
        }
        // 输出：
        // File opened
        // File closed
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
    }
    return 0;
}
```

## 示例 3：使用 RAII 管理互斥锁
```cpp
#include <iostream>
#include <mutex>
#include <thread>

std::mutex mtx;

class ScopedLock {
public:
    ScopedLock() {
        mtx.lock();
        std::cout << "Lock acquired\n";
    }
    ~ScopedLock() {
        mtx.unlock();
        std::cout << "Lock released\n";
    }
};

void worker() {
    ScopedLock lock;
    std::cout << "Worker thread is running\n";
}

int main() {
    std::thread t(worker);
    t.join();
    // 输出：
    // Lock acquired
    // Worker thread is running
    // Lock released
    return 0;
}
```

# using
在C++中，`using` 关键字有多种用途，包括类型别名声明、命名空间成员引入、模板别名等。

## 1. 类型别名声明
`using` 可以用来声明类型别名，类似于 `typedef`，但语法更简洁，功能更强大。

```cpp
using Int = int;
using PtrToInt = int*;
using ArrayOfInt = int[10];
```
这些声明分别定义了 `Int`、`PtrToInt` 和 `ArrayOfInt` 作为 `int`、`int*` 和 `int[10]` 的别名。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

using Int = int;
using PtrToInt = int*;
using VecOfString = vector<string>;

int main() {
    Int a = 10;
    PtrToInt p = &a;
    VecOfString vec = {"Hello", "World"};

    cout << "a: " << a << endl;
    cout << "*p: " << *p << endl;
    for (const auto& str : vec) {
        cout << str << " ";
    }
    cout << endl;

    return 0;
}
```

## 2. 命名空间成员引入
`using` 可以用来引入命名空间中的成员，使它们在当前作用域中可用。

```cpp
using std::cout;
using std::endl;
```
这些声明使得 `cout` 和 `endl` 在当前作用域中可用，而无需使用 `std::` 前缀。

```cpp
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};

    for (const auto& val : vec) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

```cpp
#include <iostream>
#include <chrono>

using namespace std;
using namespace std::chrono;

int main() {
    auto start = high_resolution_clock::now();
    // 一些耗时操作
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end - start);

    cout << "Elapsed time: " << duration.count() << " ms" << endl;

    return 0;
}
```

- `using namespace std;` 将 `std` 命名空间中的所有成员引入到当前作用域中，因此可以直接使用 `cout` 而不是 `std::cout`。
- `using namespace std::chrono;` 将 `std::chrono` 命名空间中的所有成员引入到当前作用域中，因此可以直接使用 `high_resolution_clock` 和 `duration_cast` 而不是 `std::chrono::high_resolution_clock` 和 `std::chrono::duration_cast`。

## 3. 命名空间别名
命名空间别名的作用是为一个较长的命名空间提供一个简短的别名，而不是将所有成员引入到当前作用域中。

```cpp
namespace alias_name = namespace_name;
```

```cpp
#include <iostream>
#include <chrono>

namespace stdc = std::chrono;

int main() {
    auto start = stdc::high_resolution_clock::now();
    // 一些耗时操作
    auto end = stdc::high_resolution_clock::now();
    auto duration = stdc::duration_cast<stdc::milliseconds>(end - start);

    std::cout << "Elapsed time: " << duration.count() << " ms" << std::endl;

    return 0;
}
```

## 4. 模板别名
`using` 可以用来定义模板别名，使复杂的模板类型更加简洁。

```cpp
template <typename T>
using Vec = std::vector<T>;

template <typename T>
using Ptr = std::unique_ptr<T>;
```
这些声明分别定义了 `Vec` 和 `Ptr` 作为 `std::vector<T>` 和 `std::unique_ptr<T>` 的模板别名。

```cpp
#include <iostream>
#include <vector>
#include <memory>

template <typename T>
using Vec = std::vector<T>;

template <typename T>
using Ptr = std::unique_ptr<T>;

int main() {
    Vec<int> vec = {1, 2, 3, 4, 5};
    Ptr<int> ptr = std::make_unique<int>(10);

    for (const auto& val : vec) {
        std::cout << val << " ";
    }
    std::cout << endl;

    std::cout << "*ptr: " << *ptr << endl;

    return 0;
}
```

## 5. 类型特征别名
`using` 可以用来定义类型特征的别名，使代码更加简洁。

```cpp
template <typename T>
using is_integral = std::is_integral<T>;
```
这个声明定义了 `is_integral` 作为 `std::is_integral<T>` 的别名。

```cpp
#include <iostream>
#include <type_traits>

template <typename T>
using is_integral = std::is_integral<T>;

int main() {
    std::cout << std::boolalpha;
    std::cout << "is_integral<int>::value: " << is_integral<int>::value << std::endl;
    std::cout << "is_integral<double>::value: " << is_integral<double>::value << std::endl;

    return 0;
}
```

# using vs typedef
在C++中，`using` 和 `typedef` 都可以用来声明类型别名，但它们在语法和功能上有一些差异。在很多情况下，`using` 可以代替 `typedef`，但 `using` 提供了更简洁和更强大的功能。

## 1. `typedef` 的基本用法
`typedef` 是C语言中引入的关键字，用于声明类型别名。它的语法如下：
```cpp
typedef existing_type new_type;
```
例如：
```cpp
typedef int Integer;
typedef int* PtrToInt;
typedef int ArrayOfInt[10];
```
这些声明分别定义了 `Integer`、`PtrToInt` 和 `ArrayOfInt` 作为 `int`、`int*` 和 `int[10]` 的别名。

## 2. `using` 的基本用法
`using` 是C++11引入的关键字，用于声明类型别名。它的语法如下：
```cpp
using new_type = existing_type;
```
例如：
```cpp
using Integer = int;
using PtrToInt = int*;
using ArrayOfInt = int[10];
```
这些声明分别定义了 `Integer`、`PtrToInt` 和 `ArrayOfInt` 作为 `int`、`int*` 和 `int[10]` 的别名。

## 3. 对比 `typedef` 和 `using`

### 3.1 语法
- **`typedef`**：
  - 语法：`typedef existing_type new_type;`
  - 优点：C语言兼容。
  - 缺点：语法不够直观，尤其是对于复杂的类型声明。
- **`using`**：
  - 语法：`using new_type = existing_type;`
  - 优点：语法更直观，更接近自然语言，尤其是对于复杂的类型声明。
  - 缺点：C++11及以上版本才支持。

### 3.2 功能
- **`typedef`**：
  - 仅支持类型别名声明。
  - 不能用于命名空间成员引入或模板别名。
- **`using`**：
  - 支持类型别名声明。
  - 支持命名空间成员引入。
  - 支持模板别名。
  - 支持类型特征别名。

# std::atomic
`std::atomic` 是C++标准库中的一个模板类，用于提供原子操作。原子操作是指在多线程环境中，操作不会被其他线程中断，从而保证线程安全。`std::atomic` 提供了一系列的原子操作，包括读取、写入、比较交换等。

`std::atomic` 是C++11引入的一个模板类，位于 `<atomic>` 头文件中。它的定义如下：
```cpp
template <typename T>
class atomic;
```

- **`std::atomic`**：提供原子操作，保证多线程环境下的线程安全。 - **主要成员函数**：
  - `load` 和 `store`：读取和写入原子变量的值。
  - `compare_exchange_weak` 和 `compare_exchange_strong`：比较交换操作。
  - `fetch_add` 和 `fetch_sub`：原子地增加和减少原子变量的值。
- **内存顺序**：控制操作的可见性和顺序，常见的内存顺序包括 `memory_order_seq_cst`、`memory_order_acquire`、`memory_order_release` 和 `memory_order_relaxed`。

## 构造函数
```cpp
atomic() noexcept;
atomic(T desired) noexcept;
```
- 默认构造函数：初始化为默认值。
- 带参数的构造函数：初始化为指定的值。

## 读取和写入
```cpp
T load(memory_order order = memory_order_seq_cst) const noexcept;
void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
```
- `load`：读取原子变量的值。
- `store`：写入原子变量的值。

## 比较交换
```cpp
bool compare_exchange_weak(T& expected, T desired, memory_order success_order, memory_order failure_order) noexcept;
bool compare_exchange_strong(T& expected, T desired, memory_order success_order, memory_order failure_order) noexcept;
```
- `compare_exchange_weak`：弱比较交换操作，可能因硬件限制而失败。
- `compare_exchange_strong`：强比较交换操作，不会因硬件限制而失败。

## 增加和减少
```cpp
T fetch_add(T operand, memory_order order = memory_order_seq_cst) noexcept;
T fetch_sub(T operand, memory_order order = memory_order_seq_cst) noexcept;
```
- `fetch_add`：原子地增加原子变量的值。
- `fetch_sub`：原子地减少原子变量的值。

## 内存顺序
在C++的 `std::atomic` 操作中，**内存顺序（memory order）** 是一个非常重要的概念，它用于控制原子操作的可见性和顺序。内存顺序确保了在多线程环境中，操作的执行顺序和可见性符合预期，从而避免数据竞争和内存访问问题。

### `std::memory_order_seq_cst`（顺序一致性）
- **语义**：最强的内存顺序，确保所有线程看到的操作顺序是一致的。
- **用途**：适用于需要全局一致性的场景，是最安全的选择，但可能性能稍差。
- **示例**：
  ```cpp
  atomic_var.compare_exchange_weak(expected, desired, std::memory_order_seq_cst);
  ```

### `std::memory_order_acquire`（获取顺序）
- **语义**：用于读取操作，确保在当前线程中，后续的读写操作不会被重排到该读取操作之前。
- **用途**：通常用于锁的获取操作，确保后续操作不会被提前执行。
- **示例**：
  ```cpp
  int value = atomic_var.load(std::memory_order_acquire);
  ```

### `std::memory_order_release`（释放顺序）
- **语义**：用于写入操作，确保在当前线程中，之前的读写操作不会被重排到该写入操作之后。
- **用途**：通常用于锁的释放操作，确保之前的操作不会被延迟执行。
- **示例**：
  ```cpp
  atomic_var.store(desired, std::memory_order_release);
  ```

### `std::memory_order_acq_rel`（获取-释放顺序）
- **语义**：结合了 `std::memory_order_acquire` 和 `std::memory_order_release` 的特性，适用于读写操作，确保在当前线程中，之前的读写操作不会被重排到该操作之后，后续的读写操作不会被重排到该操作之前。
- **用途**：适用于需要同时保证读取和写入操作一致性的场景。
- **示例**：
  ```cpp
  atomic_var.compare_exchange_weak(expected, desired, std::memory_order_acq_rel);
  ```

### `std::memory_order_relaxed`（放松顺序）
- **语义**：最弱的内存顺序，不保证操作的可见性，仅保证操作的原子性。
- **用途**：适用于性能要求高且不需要全局一致性的场景。
- **示例**：
  ```cpp
  atomic_var.fetch_add(1, std::memory_order_relaxed);
  ```

#### 4.1 使用 `std::memory_order_seq_cst`
```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        counter.fetch_add(1, std::memory_order_seq_cst);
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Counter value: " << counter.load() << std::endl;

    return 0;
}
```

#### 4.2 使用 `std::memory_order_acquire` 和 `std::memory_order_release`
```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Counter value: " << counter.load(std::memory_order_acquire) << std::endl;

    return 0;
}
```

### 5. 总结
- **内存顺序**：控制原子操作的可见性和顺序，确保在多线程环境中操作的一致性和安全性。
- **`std::memory_order_seq_cst`**：最强的内存顺序，确保全局一致性。
- **`std::memory_order_acquire`**：用于读取操作，确保后续操作不会被提前。
- **`std::memory_order_release`**：用于写入操作，确保之前的操作不会被延迟。
- **`std::memory_order_acq_rel`**：结合了获取和释放的特性，适用于读写操作。
- **`std::memory_order_relaxed`**：最弱的内存顺序，仅保证操作的原子性，不保证可见性。

## 示例：基本使用
```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Counter value: " << counter.load() << std::endl;

    return 0;
}
```

## 示例：比较交换
```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        int expected = counter.load();
        while (!counter.compare_exchange_weak(expected, expected + 1, std::memory_order_relaxed)) {
            expected = counter.load();
        }
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Counter value: " << counter.load() << std::endl;

    return 0;
}
```