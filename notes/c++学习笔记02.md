C++ 学习笔记

# 临时对象
在 C++ 中，临时对象（Temporary Object）是编译器在表达式求值过程中自动创建的、未命名的对象。它们具有以下关键特性：
1. **生存期短暂**：通常存活到当前完整表达式结束（一般是分号处）
2. **没有命名**：无法直接通过标识符访问
3. **天然属于右值**（rvalue）：可绑定到右值引用（`&&`）或 const 左值引用

## **函数返回非引用类型**
```cpp
std::string createString() {
    return "Hello"; // 返回临时 string 对象（右值）
}

auto s = createString(); // 临时对象用于初始化 s
```

## **类型转换**
```cpp
double d = 3.14;
int i = static_cast<int>(d); // 转换产生临时 int（右值）
```

## **运算符表达式结果**
```cpp
int a = 5, b = 3;
int c = a + b; // a+b 产生临时 int（右值）

std::string s1 = "Hello", s2 = "World";
std::string s3 = s1 + s2; // operator+ 返回临时 string
```

## **构造未命名对象**
```cpp
class Widget {};
void process(Widget&& w); // 接收右值引用

process(Widget{}); // Widget{} 构造临时对象（右值）
```

## **按值传参时的隐式转换**
```cpp
void print(double d);
print(42); // 整型 42 隐式转换为临时 double（右值）
```

## **异常抛出**
```cpp
throw std::runtime_error("Error"); // 构造临时异常对象（右值）
```

## **初始化列表**
```cpp
std::vector<int> v = {1, 2, 3}; // 初始化列表生成临时 array
```

# 右值

在 C++ 中，表达式分为两种主要值类别：
- **左值 (lvalue)**：有持久身份的对象（有内存地址）
- **右值 (rvalue)**：临时对象或即将销毁的对象

右值的核心特征：
- 通常没有名称（匿名）
- 不能取地址（`&`操作符）
- 生命周期仅限于当前表达式
- 代表"数据值"而非"存储位置"

## 右值分类

| 类型             | 描述                   | 示例                   |
| ---------------- | ---------------------- | ---------------------- |
| 纯右值 (prvalue) | 纯粹的字面值或临时对象 | `42`, `3.14`, `func()` |
| 将亡值 (xvalue)  | 即将被移动的资源       | `std::move(var)`       |

```cpp
int a = 10;         // a 是左值
int b = a;          // a 是左值（有名称）
int c = 20;         // 20 是右值（字面量）
int d = a + b;      // (a+b) 是右值（临时结果）

int e = func();     // func() 返回右值（临时对象）
int* p = &a;        // 正确：a 是左值
// int* q = &(a+b); // 错误：不能取右值地址
```

# 右值引用

右值引用（rvalue reference）是C++11引入的一种新的引用类型，用 `&&` 表示。它与左值引用（lvalue reference，用 `&` 表示）不同，右值引用只能绑定到**右值**上。

- **左值（lvalue）**：表示一个有名字的对象，可以取地址，可以出现在赋值运算符的左边。例如，变量名、数组名等。
- **右值（rvalue）**：表示一个临时对象或无名字的对象，通常出现在表达式的右边，不能取地址。

右值引用的主要目的是支持**移动语义（move semantics）**和**完美转发（perfect forwarding）**。

在 C++11 之前，资源管理面临两大难题：

1. **不必要的拷贝开销**
   ```cpp
   std::vector<int> createVector() {
       std::vector<int> v(1000000); // 分配100万int
       return v; // 传统C++：拷贝整个向量返回
   }
   ```

2. **无法有效利用临时对象**
   ```cpp
   std::string s1 = "Hello";
   std::string s2 = "World";
   std::string s3 = s1 + s2; // 临时(s1+s2)被构造后立即拷贝
   ```

右值引用 (`Type&&`) 解决了这些问题：
- 允许识别临时对象（右值）
- 提供"移动"而非"拷贝"的语义
- 避免不必要的资源复制

```cpp
int&& rref1 = 42; // 正确：绑定到字面量
int&& rref2 = std::move(a); // 正确：绑定到转换后的右值

// int&& rref3 = a; // 错误：不能直接绑定到左值
```

右值引用特性：
- 只能绑定到右值
- 延长临时对象的生命周期（绑定期间）
- 允许修改右值（不同于 const 左值引用）

## 右值引用的作用
1. **支持移动语义**
   - 移动语义允许资源（如动态内存、文件句柄、网络连接等）的所有权从一个对象转移到另一个对象，从而避免不必要的拷贝，提高效率。
   - 移动构造函数和移动赋值运算符是实现移动语义的关键。

2. **支持完美转发**
   - 完美转发允许函数模板将参数原封不动地转发给其他函数，保持参数的左值或右值属性不变。

## 移动语义（Move Semantics）
移动语义是右值引用最重要的用途之一。它允许资源的所有权从一个对象转移到另一个对象，从而避免不必要的拷贝。

### 示例1：移动构造函数
```cpp
#include <iostream>
#include <utility> // std::move

class Resource {
public:
    int* data;

    // 构造函数
    Resource(int value) : data(new int(value)) {
        std::cout << "Constructor called" << std::endl;
    }

    // 拷贝构造函数
    Resource(const Resource& other) : data(new int(*other.data)) {
        std::cout << "Copy constructor called" << std::endl;
    }

    // 移动构造函数
    Resource(Resource&& other) noexcept : data(other.data) {
        other.data = nullptr; // 防止析构时释放
        std::cout << "Move constructor called" << std::endl;
    }

    // 析构函数
    ~Resource() {
        delete data;
        std::cout << "Destructor called" << std::endl;
    }

    int getValue() const {
        return data ? *data : 0;
    }
};

int main() {
    Resource r1(42); // 调用构造函数
    std::cout << "r1 value: " << r1.getValue() << std::endl;

    Resource r2 = std::move(r1); // 调用移动构造函数
    std::cout << "r2 value: " << r2.getValue() << std::endl;
    std::cout << "r1 value after move: " << r1.getValue() << std::endl;

    return 0;
}
```

**输出结果：**
```
Constructor called
r1 value: 42
Move constructor called
r2 value: 42
r1 value after move: 0
Destructor called
Destructor called
```

- `Resource r1(42)`：调用构造函数，创建了一个对象 `r1`。
- `Resource r2 = std::move(r1)`：`std::move(r1)` 将左值 `r1` 转换为右值引用，触发了移动构造函数。
- 移动构造函数将 `r1.data` 的所有权转移到 `r2`，并将 `r1.data` 置为 `nullptr`。
- `r1` 仍然存在，但它的资源已经被清空。

### 示例2：移动赋值运算符
```cpp
#include <iostream>
#include <utility> // std::move

class Resource {
public:
    int* data;

    // 构造函数
    Resource(int value) : data(new int(value)) {
        std::cout << "Constructor called" << std::endl;
    }

    // 拷贝赋值运算符
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        std::cout << "Copy assignment called" << std::endl;
        return *this;
    }

    // 移动赋值运算符
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr; // 防止析构时释放
        }
        std::cout << "Move assignment called" << std::endl;
        return *this;
    }

    // 析构函数
    ~Resource() {
        delete data;
        std::cout << "Destructor called" << std::endl;
    }

    int getValue() const {
        return data ? *data : 0;
    }
};

int main() {
    Resource r1(42); // 调用构造函数
    std::cout << "r1 value: " << r1.getValue() << std::endl;

    Resource r2(100); // 调用构造函数
    std::cout << "r2 value: " << r2.getValue() << std::endl;

    r2 = std::move(r1); // 调用移动赋值运算符
    std::cout << "r2 value after move: " << r2.getValue() << std::endl;
    std::cout << "r1 value after move: " << r1.getValue() << std::endl;

    return 0;
}
```

**输出结果：**
```
Constructor called
r1 value: 42
Constructor called
r2 value: 100
Move assignment called
r2 value after move: 42
r1 value after move: 0
Destructor called
Destructor called
```

- `Resource r1(42)` 和 `Resource r2(100)`：分别调用构造函数，创建了两个对象 `r1` 和 `r2`。
- `r2 = std::move(r1)`：`std::move(r1)` 将左值 `r1` 转换为右值引用，触发了移动赋值运算符。
- 移动赋值运算符将 `r1.data` 的所有权转移到 `r2`，并将 `r1.data` 置为 `nullptr`。
- `r1` 仍然存在，但它的资源已经被清空。

## 完美转发（Perfect Forwarding）
完美转发允许函数模板将参数原封不动地转发给其他函数，保持参数的左值或右值属性不变。

```cpp
#include <iostream>
#include <utility> // std::forward

// 模拟目标函数
void process(int& x) {
    std::cout << "Processing lvalue: " << x << std::endl;
}

void process(int&& x) {
    std::cout << "Processing rvalue: " << x << std::endl;
}

// 转发函数模板
template <typename T>
void forwardFunction(T&& arg) {
    process(std::forward<T>(arg)); // 完美转发
}

int main() {
    int x = 10;

    // 转发左值
    forwardFunction(x); // 调用 process(int& x)

    // 转发右值
    forwardFunction(20); // 调用 process(int&& x)

    return 0;
}
```

**输出结果：**
```
Processing lvalue: 10
Processing rvalue: 20
```

**解释：**
- `forwardFunction` 是一个函数模板，接受一个右值引用参数 `T&& arg`。
- `std::forward<T>(arg)` 用于完美转发，保持参数的左值或右值属性不变。
- 如果传入的是左值，`std::forward` 保持为左值；如果传入的是右值，`std::forward` 保持为右值。

### 五、总结
- **右值引用（rvalue reference）** 是C++11引入的一种新的引用类型，用 `&&` 表示。
- **移动语义（Move Semantics）** 是右值引用最重要的用途之一，允许资源的所有权从一个对象转移到另一个对象，从而避免不必要的拷贝。
- **移动构造函数** 和 **移动赋值运算符** 是实现移动语义的关键。
- **完美转发（Perfect Forwarding）** 允许函数模板将参数原封不动地转发给其他函数，保持参数的左值或右值属性不变。

## 示例
### 优化容器操作

```cpp
std::vector<HeavyObject> objects;

// 添加对象（高效移动）
HeavyObject obj(500000);
objects.push_back(std::move(obj)); // 移动而非拷贝

// 就地构造（完美转发）
objects.emplace_back(800000); // 直接构造在容器中
```

### 实现资源管理类

```cpp
class UniqueFile {
    FILE* file;
public:
    UniqueFile(const char* filename) : file(fopen(filename, "r")) {}
    
    // 移动构造函数
    UniqueFile(UniqueFile&& other) noexcept : file(other.file) {
        other.file = nullptr;
    }
    
    ~UniqueFile() {
        if (file) fclose(file);
    }
    
    // 禁止拷贝
    UniqueFile(const UniqueFile&) = delete;
    UniqueFile& operator=(const UniqueFile&) = delete;
};

int main() {
    UniqueFile f1("data.txt");
    UniqueFile f2 = std::move(f1); // 所有权转移
}
```

### 高效交换操作

```cpp
template <typename T>
void swap(T& a, T& b) noexcept {
    T temp(std::move(a)); // 移动构造
    a = std::move(b);     // 移动赋值
    b = std::move(temp);  // 移动赋值
}

// 对比传统拷贝交换：
// void swap(T& a, T& b) {
//     T temp = a; // 拷贝
//     a = b;      // 拷贝
//     b = temp;   // 拷贝
// }
```

### 完美转发

```cpp
template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

class Widget {
public:
    Widget(int x, double y) { /*...*/ }
};

auto widget = make_unique<Widget>(10, 3.14); // 完美转发参数
```

## 移动语义的关键点

1. **移动不是拷贝**：
   - 移动 = 资源所有权转移
   - 拷贝 = 资源内容复制

2. **移动后源对象状态**：
   - 有效但未定义状态（通常为空）
   - 可安全析构和重新赋值
   ```cpp
   std::string s1 = "Hello";
   std::string s2 = std::move(s1);
   
   // s1 现在为空（未定义但有效）
   s1 = "New value"; // 安全：重新赋值
   ```

3. **`noexcept`保证的重要性**：
   - 标准库容器在重新分配时优先使用移动（如果标记为 noexcept）
   ```cpp
   class SafeMove {
   public:
       SafeMove(SafeMove&&) noexcept; // 容器优先使用此移动操作
   };
   ```

4. **何时自动生成移动操作**：
   - 如果用户未声明拷贝操作/析构函数
   - 所有非静态成员可移动
   - 基类可移动

## 注意

### 误区 1：移动比拷贝快？
- 对于小型对象（int, double 等），移动=拷贝
- 仅对资源管理类有意义（vector, string, unique_ptr 等）

### 误区 2：`std::move` 会移动数据？
- `std::move` 只是类型转换
- 真正移动发生在移动构造/赋值中

### 误区 3：右值引用会延长所有临时对象的生命周期？
- 只延长直接绑定的临时对象
- 不适用于子对象或成员
  ```cpp
  std::string&& r = "temp"; // 临时字符串生命周期延长
  std::string&& bad = someFunc().substr(1); // 子对象不延长
  ```
在C++中，临时对象的生命周期通常在表达式结束时结束。然而，C++标准提供了一个特殊的规则，允许右值引用延长临时对象的生命周期。这个规则被称为**生命周期延长（Lifetime Extension）**。

根据C++标准，右值引用可以延长临时对象的生命周期，但这种延长只适用于**直接绑定的临时对象**。

这种区别源于C++标准对临时对象生命周期的严格定义。标准规定，生命周期延长只适用于**直接绑定的临时对象**，而不适用于其子对象或成员。这样设计的原因是为了避免复杂的生命周期管理问题，确保语言的简单性和一致性。

#### 1. 直接绑定的临时对象
**示例代码：**
```cpp
#include <iostream>
#include <string>

void test(const std::string& str) {
    std::cout << "String: " << str << std::endl;
}

int main() {
    std::string&& r = "temp"; // 临时字符串生命周期延长
    test(r); // 临时字符串 "temp" 的生命周期被延长到 r 的生命周期结束
    return 0;
}
```

**解释：**
- `"temp"` 是一个临时的 `const char*` 字面量。
- `std::string&& r = "temp"` 创建了一个临时的 `std::string` 对象，并将其直接绑定到右值引用 `r`。
- 根据C++标准，临时对象 `"temp"` 的生命周期被延长到 `r` 的生命周期结束。
- 因此，在调用 `test(r)` 时，`"temp"` 仍然是有效的。

#### 2. 子对象或成员
**示例代码：**
```cpp
#include <iostream>
#include <string>

std::string someFunc() {
    return "hello";
}

int main() {
    std::string&& r = someFunc().substr(1); // 子对象不延长
    std::cout << "Substring: " << r << std::endl;
    return 0;
}
```

**解释：**
- `someFunc()` 返回一个临时的 `std::string` 对象，内容为 `"hello"`。
- `someFunc().substr(1)` 调用了 `substr` 方法，返回一个临时的 `std::string` 对象，内容为 `"ello"`。
- `std::string&& r = someFunc().substr(1)` 将临时对象 `"ello"` 绑定到右值引用 `r`。
- 临时对象 `"ello"` 是 `someFunc().substr(1)` 的返回值，它是一个子对象。
- 根据C++标准，子对象的生命周期不会被延长。因此，临时对象 `"ello"` 的生命周期在表达式结束时结束，而不是延长到 `r` 的生命周期结束。
- 因此，`r` 成为一个悬空引用，指向一个已经被销毁的对象。

#### 正确处理临时对象
为了避免上述问题，可以使用 `std::move` 来显式地移动临时对象，确保其生命周期被正确管理。

**改进代码：**
```cpp
#include <iostream>
#include <string>

std::string someFunc() {
    return "hello";
}

int main() {
    std::string r = std::move(someFunc().substr(1)); // 显式移动临时对象
    std::cout << "Substring: " << r << std::endl;
    return 0;
}
```

**解释：**
- `someFunc().substr(1)` 返回一个临时的 `std::string` 对象，内容为 `"ello"`。
- `std::move(someFunc().substr(1))` 将临时对象 `"ello"` 转换为右值引用。
- `std::string r = std::move(someFunc().substr(1))` 触发移动构造函数，将临时对象 `"ello"` 的资源转移到 `r`。
- 临时对象 `"ello"` 的生命周期被正确管理，不会在表达式结束时被销毁。

**输出结果：**
```
Substring: ello
```

## 实际项目中的应用价值

1. **性能提升**：
   - 减少动态内存分配
   - 避免大对象深拷贝
   - 提高容器操作效率

2. **资源管理**：
   - 安全转移文件句柄
   - 传递网络连接所有权
   - 管理 GPU 缓冲区

3. **API 设计改进**：
   - 明确资源所有权转移
   - 支持高效工厂模式
   - 实现链式调用

4. **并发编程优化**：
   - 安全跨线程转移资源
   - 减少锁竞争
   ```cpp
   std::unique_ptr<Message> createMessage();
   void processMessage(std::unique_ptr<Message>);
   
   // 线程间安全转移
   std::thread worker(processMessage, createMessage());
   ```

## 总结：右值引用的核心价值

1. **解决历史难题**：消除不必要的拷贝开销
2. **启用移动语义**：高效转移资源所有权
3. **支持完美转发**：保持参数值类别
4. **优化资源管理**：安全转移文件、内存等资源
5. **提升抽象能力**：实现更高效的现代 C++ 设计模式

右值引用不是语法糖，而是 C++ 编程范式的革命性变革。它使 C++ 能够：
- 安全高效地管理资源
- 达到接近 C 的性能
- 保持高级抽象能力
- 编写更简洁高效的代码

理解右值和右值引用是现代 C++ 高效编程的基石。掌握这些概念后，你将能够：
- 显著提升代码性能
- 设计更安全的资源管理类
- 理解标准库的内部实现
- 编写更现代的 C++ API
- 避免常见的性能陷阱

# noexcept
> [noexcept operator (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/language/noexcept.html)   

`noexcept` 是 C++11 引入的一个关键字，用于指定一个函数不会抛出异常。它主要有以下两个作用：
1. **性能优化**：
   - 编译器可以利用 `noexcept` 信息进行优化。例如，当一个函数被标记为 `noexcept` 时，编译器可以假设该函数不会抛出异常，从而避免生成额外的异常处理代码，提高程序的性能。
   - 标准库中的某些算法（如 `std::move` 和 `std::swap`）会根据函数是否标记为 `noexcept` 来选择不同的实现方式，以提高效率。

2. **语义清晰**：
   - 使用 `noexcept` 可以明确地告诉调用者该函数不会抛出异常，增强代码的可读性和可维护性。

`noexcept` 可以用在函数声明和定义中，表示该函数不会抛出异常。其语法如下：

```cpp
void myFunction() noexcept;
```

或者在函数定义中：

```cpp
void myFunction() noexcept {
    // 函数体
}
```

## `noexcept` 在移动构造函数中的作用
移动构造函数通常用于将资源从一个对象转移到另一个对象，这个过程通常不会抛出异常。因此，移动构造函数通常被标记为 `noexcept`，以表示它不会抛出异常。

```cpp
class Resource {
public:
    int* data;

    // 构造函数
    Resource(int value) : data(new int(value)) {
        std::cout << "Constructor called" << std::endl;
    }

    // 移动构造函数
    Resource(Resource&& other) noexcept : data(other.data) {
        other.data = nullptr; // 防止析构时释放
        std::cout << "Move constructor called" << std::endl;
    }

    // 析构函数
    ~Resource() {
        delete data;
        std::cout << "Destructor called" << std::endl;
    }

    int getValue() const {
        return data ? *data : 0;
    }
};
```

1. **性能优化**：
   - 移动构造函数的主要目的是高效地转移资源，通常不会涉及复杂的逻辑或可能抛出异常的操作。标记为 `noexcept` 可以让编译器进行优化，避免生成额外的异常处理代码。

2. **标准库的要求**：
   - 标准库中的某些算法（如 `std::vector` 的 `push_back` 和 `std::swap`）会根据移动构造函数是否标记为 `noexcept` 来选择不同的实现方式。如果移动构造函数标记为 `noexcept`，这些算法可以更高效地使用移动语义，而不是退化为拷贝语义。

3. **语义清晰**：
   - 标记为 `noexcept` 明确地告诉调用者该函数不会抛出异常，增强代码的可读性和可维护性。

## `noexcept` 用于函数模板

`noexcept` 可以与函数模板结合使用，根据模板参数的类型自动推导是否抛出异常。
```cpp
template <typename T>
void myFunction(T&& arg) noexcept(noexcept(arg.someFunction())) {
    arg.someFunction();
}
```

# std::move
> [std::move - cppreference.com](https://en.cppreference.com/w/cpp/utility/move.html) 

`std::move` 是 C++11 引入的关键工具，用于实现高效的移动语义。虽然名字包含"move"，但它本身**不执行任何移动操作**，而只是进行类型转换。下面我将全面解析 `std::move` 的各个方面，并通过详细示例说明其用法。

```cpp
template <typename T>
typename std::remove_reference<T>::type&& move(T&& arg) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(arg);
}
```
- **作用**：将左值转换为右值引用
- **不移动数据**：仅改变值的类别（lvalue → xvalue）
- **标记对象**：表示该对象可以被移动（资源可以被转移）

| 参数类型   | 处理方式              | 结果类型       |
| ---------- | --------------------- | -------------- |
| 左值       | 转换为右值引用        | `Type&&`       |
| 右值       | 保持不变              | `Type&&`       |
| const 对象 | 转换为 const 右值引用 | `const Type&&` |

- 总是返回右值引用
- 返回类型为 `typename std::remove_reference<T>::type&&`
- 声明为 `noexcept`，保证不抛出异常

## 类型转换非移动数据

`std::move` 是一个类型转换函数，它的作用是将一个左值（lvalue）转换为右值引用（rvalue reference）。这样做的目的是为了让移动构造函数或移动赋值运算符能够被调用。

`std::move` 确实不直接移动数据，但它是一个非常重要的工具，用于触发移动语义。移动语义的核心在于**移动构造函数**和**移动赋值运算符**，它们才是实际执行移动操作的地方。

移动构造函数和移动赋值运算符是实现移动语义的关键。它们负责实际的资源转移操作。具体来说：
- **移动构造函数**：用于在创建新对象时，将资源从一个对象转移到另一个对象。
- **移动赋值运算符**：用于在对象赋值时，将资源从一个对象转移到另一个对象。

虽然 `std::move` 本身不移动数据，但它是一个信号，告诉编译器“我打算移动这个对象的资源”。只有当类中定义了移动构造函数或移动赋值运算符时，`std::move` 才能触发这些函数，从而实现资源的移动。

移动构造函数是实现移动语义的关键。它允许资源的所有权从一个对象转移到另一个对象，从而避免不必要的拷贝，提高效率。如果没有移动构造函数，`std::move` 将无法触发移动操作，程序将退化为使用拷贝构造函数或拷贝赋值运算符。

## 示例

### 示例 1：基本用法（类型转换）

```cpp
#include <iostream>
#include <utility>

void process(int& val) {
    std::cout << "Lvalue processed: " << val << "\n";
}

void process(int&& val) {
    std::cout << "Rvalue processed: " << val << "\n";
}

int main() {
    int a = 10;
    const int b = 20;
    
    process(a);                // 调用左值版本
    process(30);               // 调用右值版本
    process(std::move(a));     // 调用右值版本
    process(std::move(b));     // 调用右值版本 (const int&&)
    
    // 注意：a 的值仍然存在
    std::cout << "a after move: " << a << "\n"; // 输出 10
}
```

### 示例 2：在移动构造函数中使用

```cpp
#include <iostream>
#include <cstring>
#include <utility>

class String {
    char* data;
    size_t length;
    
public:
    // 构造函数
    String(const char* str = "") : length(std::strlen(str)) {
        data = new char[length + 1];
        std::strcpy(data, str);
        std::cout << "Constructed: " << data << "\n";
    }
    
    // 移动构造函数
    String(String&& other) noexcept 
        : data(other.data), length(other.length) {
        std::cout << "Move constructed from: " << data << "\n";
        other.data = nullptr; // 重要：置空源对象
        other.length = 0;
    }
    
    // 析构函数
    ~String() {
        if (data) {
            std::cout << "Destroying: " << data << "\n";
            delete[] data;
        }
    }
    
    const char* c_str() const { return data; }
};

int main() {
    String s1("Hello");
    
    // 使用 std::move 触发移动构造
    String s2(std::move(s1));
    
    std::cout << "s1: " << (s1.c_str() ? s1.c_str() : "nullptr") << "\n";
    std::cout << "s2: " << s2.c_str() << "\n";
}
```

### 示例 3：在容器操作中使用

```cpp
#include <iostream>
#include <vector>
#include <utility>

int main() {
    std::vector<std::string> words;
    
    // 创建大字符串
    std::string bigString(1000, 'a'); // 1000个'a'
    
    // 传统拷贝方式（低效）
    words.push_back(bigString); // 拷贝：分配新内存并复制内容
    
    // 移动方式（高效）
    words.push_back(std::move(bigString)); // 移动：转移所有权
    
    std::cout << "bigString after move: " 
              << (bigString.empty() ? "empty" : "has data") 
              << "\n"; // 输出 empty
    std::cout << "Last word in vector: " 
              << (words.back().size() == 1000 ? "1000 chars" : "invalid")
              << "\n"; // 输出 1000 chars
}
```

### 示例 4：在自定义算法中使用

```cpp
#include <iostream>
#include <utility>
#include <vector>

template <typename T>
void swap(T& a, T& b) noexcept {
    T temp(std::move(a)); // 移动构造
    a = std::move(b);     // 移动赋值
    b = std::move(temp);  // 移动赋值
}

int main() {
    std::vector<int> v1 = {1, 2, 3, 4, 5};
    std::vector<int> v2 = {10, 20, 30};
    
    std::cout << "Before swap:\n";
    std::cout << "v1 size: " << v1.size() << ", v2 size: " << v2.size() << "\n";
    
    swap(v1, v2); // 高效交换
    
    std::cout << "After swap:\n";
    std::cout << "v1 size: " << v1.size() << ", v2 size: " << v2.size() << "\n";
}
```

### 示例 5：在工厂函数中使用

```cpp
#include <iostream>
#include <memory>
#include <utility>

class Resource {
public:
    Resource() { std::cout << "Resource created\n"; }
    ~Resource() { std::cout << "Resource destroyed\n"; }
    void use() { std::cout << "Resource used\n"; }
};

// 工厂函数返回 unique_ptr
std::unique_ptr<Resource> createResource() {
    return std::unique_ptr<Resource>(new Resource());
}

// 接受资源的函数
void takeResource(std::unique_ptr<Resource> res) {
    std::cout << "Taking resource\n";
    res->use();
}

int main() {
    // 1. 直接从工厂获取资源
    takeResource(createResource());
    
    // 2. 转移现有资源的所有权
    auto res = createResource();
    takeResource(std::move(res)); // 必须使用 std::move
    
    // 此时 res 为空
    if (!res) {
        std::cout << "res is now empty\n";
    }
}
```

### 示例 6：在完美转发中使用

```cpp
#include <iostream>
#include <utility>

class Processor {
public:
    // 处理左值
    void process(int& val) {
        std::cout << "Processing lvalue: " << val << "\n";
    }
    
    // 处理右值
    void process(int&& val) {
        std::cout << "Processing rvalue: " << val << "\n";
    }
};

// 包装器函数
template <typename T>
void wrapper(T&& arg) {
    Processor p;
    p.process(std::forward<T>(arg)); // 完美转发
}

int main() {
    int a = 42;
    
    wrapper(a);             // 传递左值
    wrapper(100);           // 传递右值
    wrapper(std::move(a));  // 传递右值
}
```

## 关键注意事项

### 1. 移动后对象状态
```cpp
std::string s = "data";
auto moved = std::move(s);

// s 现在处于"有效但未指定状态"
// 安全操作：
s = "new data";  // 重新赋值
s.clear();       // 清空
// 不安全操作：
// auto c = s[0]; // 未定义行为
```

### 2. 不要移动 const 对象
```cpp
const std::string cs = "const data";
auto moved = std::move(cs); // 转换为 const std::string&&

// 移动操作无效，因为移动构造函数不能修改源对象
// 实际上会调用拷贝构造函数！
```

### 3. 返回值优化 (RVO/NRVO)
```cpp
// 正确：依赖编译器优化
std::vector<int> createVector() {
    std::vector<int> v = {1, 2, 3};
    return v; // 可能触发 RVO/NRVO
}

// 错误：可能阻止优化
std::vector<int> createVector() {
    std::vector<int> v = {1, 2, 3};
    return std::move(v); // 不推荐，可能阻止 RVO
}
```

### 4. 移动基本类型无意义
```cpp
int x = 10;
int y = std::move(x); // 等同于 int y = x;

// 基本类型移动与拷贝相同
// 不需要使用 std::move
```

## 高级应用场景

### 场景 1：在继承体系中使用移动

```cpp
#include <iostream>
#include <utility>

class Base {
public:
    Base() = default;
    virtual ~Base() = default;
    
    // 移动构造函数
    Base(Base&& other) noexcept {
        std::cout << "Base move constructor\n";
    }
};

class Derived : public Base {
public:
    Derived() = default;
    
    // 派生类移动构造函数
    Derived(Derived&& other) noexcept 
        : Base(std::move(other)) { // 必须显式移动基类部分
        std::cout << "Derived move constructor\n";
    }
};

int main() {
    Derived d1;
    Derived d2(std::move(d1)); // 调用移动构造函数
}
```

### 场景 2：移动非拷贝资源

```cpp
#include <iostream>
#include <fstream>
#include <utility>

void processFile(std::ifstream file) {
    if (file.is_open()) {
        std::string content;
        std::getline(file, content);
        std::cout << "File content: " << content << "\n";
    }
}

int main() {
    std::ifstream inputFile("data.txt");
    
    // 移动文件流所有权
    processFile(std::move(inputFile));
    
    if (!inputFile.is_open()) {
        std::cout << "File has been moved\n";
    }
}
```

### 场景 3：在 lambda 中移动捕获

```cpp
#include <iostream>
#include <vector>
#include <utility>
#include <memory>

int main() {
    auto bigData = std::make_unique<std::vector<int>>(1000, 42);
    
    // 移动捕获 unique_ptr
    auto processor = [data = std::move(bigData)]() mutable {
        std::cout << "Processing " << data->size() << " elements\n";
        data->clear();
    };
    
    processor();
    
    if (!bigData) {
        std::cout << "bigData has been moved\n";
    }
}
```

## 常见错误与陷阱

### 错误 1：多次移动同一对象
```cpp
std::string s = "data";
auto s1 = std::move(s); // s 被移动
auto s2 = std::move(s); // 再次移动已移动对象！

// s2 的内容未定义，可能是空字符串或随机数据
```

### 错误 2：移动后立即使用
```cpp
std::vector<int> v = {1, 2, 3};
auto moved = std::move(v);

// 错误：使用已移动的对象
std::cout << v.size(); // 未定义行为（通常是 0，但不保证）
```

### 错误 3：移动局部变量返回
```cpp
std::string createString() {
    std::string s = "hello";
    return std::move(s); // 错误：阻止 RVO
}

// 正确写法：
std::string createString() {
    std::string s = "hello";
    return s; // 可能触发 RVO
}
```

## 性能对比

```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <utility>

constexpr size_t SIZE = 10'000'000;

void testCopy() {
    std::vector<int> source(SIZE, 42);
    
    auto start = std::chrono::high_resolution_clock::now();
    std::vector<int> dest = source; // 拷贝
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Copy time: " << duration.count() << " ms\n";
}

void testMove() {
    std::vector<int> source(SIZE, 42);
    
    auto start = std::chrono::high_resolution_clock::now();
    std::vector<int> dest = std::move(source); // 移动
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Move time: " << duration.count() << " ms\n";
}

int main() {
    testCopy();
    testMove();
}
```

典型输出：
```
Copy time: 35 ms
Move time: 0 ms
```

## 总结与最佳实践

### `std::move` 的核心要点：
1. **仅类型转换**：不执行移动，仅将左值转为右值引用
2. **启用移动语义**：允许调用移动构造函数/赋值运算符
3. **资源转移**：高效转移资源所有权，避免深拷贝
4. **标记对象**：表示对象不再需要其当前资源

### 使用场景：
- ✅ 实现移动构造函数和移动赋值运算符
- ✅ 将对象所有权转移到函数或容器中
- ✅ 实现高效交换操作
- ✅ 在工厂函数中返回资源
- ✅ 在完美转发中配合 `std::forward`

### 最佳实践：
1. **移动后重置源对象**：在移动操作中将源对象置为有效空状态
2. **避免移动 const 对象**：const 对象无法被有效移动
3. **信任 RVO/NRVO**：返回局部对象时不要使用 `std::move`
4. **基本类型无需移动**：移动与拷贝成本相同
5. **明确对象状态**：文档记录移动后对象的有效状态
6. **使用 `noexcept`**：移动操作应标记为 `noexcept`

`std::move` 是现代 C++ 高效编程的核心工具之一。理解其工作原理和正确使用方式，对于编写高性能、资源敏感的 C++ 代码至关重要。通过本指南中的详细示例和解释，您应该能够自信地在项目中应用移动语义。

# 类型擦除

# lambda
Lambda 表达式是 C++11 引入的一个强大特性，它允许在代码中定义匿名函数对象（闭包）。Lambda 表达式是现代 C++ 编程中不可或缺的工具，特别是在使用 STL 算法、异步编程和事件处理时。

```cpp
[capture-list] (parameters) mutable(可选) noexcept(可选) -> return-type {
    // 函数体
}
```

- **捕获列表 (capture-list)**：指定哪些外部变量在 Lambda 中可见，以及如何捕获它们
- **参数列表 (parameters)**：与普通函数参数类似
- **mutable**：允许修改按值捕获的变量
- **noexcept**：指定 Lambda 是否抛出异常
- **返回类型 (return-type)**：可以显式指定或让编译器自动推导
- **函数体**：Lambda 的实际执行代码

---

## 捕获列表详解

捕获列表决定了 Lambda 如何访问其外部作用域中的变量：

### 1. 值捕获 `[var]`
创建外部变量的副本，Lambda 内部修改不影响外部变量

```cpp
int x = 10;
auto lambda = [x]() {
    std::cout << "Inside lambda (value): " << x << std::endl;
 []   // x++; // 错误：不能修改值捕获的变量（除非使用 mutable）
};
x = 20;
lambda(); // 输出: Inside lambda (value): 10
```

### 2. 引用捕获 `[&var]`
使用外部变量的引用，Lambda 内部修改会影响外部变量

```cpp
int y = 10;
auto lambda = [&y]() {
    std::cout << "Inside lambda (ref): " << y << std::endl;
    y++; // 修改会影响外部变量
};
y = 20;
lambda(); // 输出: Inside lambda (ref): 20
std::cout << "After lambda: " << y << std::endl; // 输出: 21
```

### 3. 隐式捕获
让编译器自动推断捕获方式

```cpp
int a = 5, b = 10;

// 值捕获所有外部变量
auto all_by_value = [=]() {
    std::cout << "a=" << a << ", b=" << b << std::endl;
};

// 引用捕获所有外部变量
auto all_by_ref = [&]() {
    a++;
    b++;
};

// 混合捕获：值捕获所有，但b是引用捕获
auto mixed = [=, &b]() {
    // a 是值捕获，不能修改
    // b 是引用捕获，可以修改
    b = a + b;
};
```

### 4. 捕获 this 指针
在类方法中使用 Lambda 时捕获 this 指针

```cpp
class MyClass {
    int value = 42;
public:
    void run() {
        auto lambda = [this]() {
            std::cout << "Class value: " << value << std::endl;
            value = 100; // 可以修改成员变量
        };
        lambda();
    }
};
```

### 5. 初始化捕获 (C++14)
允许在捕获列表中初始化新变量

```cpp
int x = 10;
auto lambda = [y = x * 2]() {
    std::cout << "y = " << y << std::endl; // 输出: y = 20
};
lambda();

// 移动语义捕获
std::unique_ptr<int> ptr = std::make_unique<int>(30);
auto lambda2 = [ptr = std::move(ptr)]() {
    std::cout << "Moved value: " << *ptr << std::endl;
};
lambda2();
```

## mutable 关键字

默认情况下，按值捕获的变量在 Lambda 内是常量。使用 `mutable` 关键字允许修改这些副本：

```cpp
int counter = 0;
auto lambda = [counter]() mutable {
    counter++;
    std::cout << "Internal counter: " << counter << std::endl;
};

lambda(); // 输出: Internal counter: 1
lambda(); // 输出: Internal counter: 2
std::cout << "External counter: " << counter << std::endl; // 输出: 0
```

## Lambda 表达式的返回类型

返回类型可以显式指定或让编译器自动推导：

```cpp
// 自动推导返回类型 (int)
auto add = [](int a, int b) { return a + b; };

// 显式指定返回类型
auto divide = [](double a, double b) -> double {
    if (b == 0) return 0;
    return a / b;
};

// 复杂返回类型
auto create_vector = []() -> std::vector<int> {
    return {1, 2, 3};
};
```

## 立即调用的 Lambda (C++14)

在C++11中，Lambda表达式需要先定义，然后单独调用。例如：

```cpp
auto lambda = []{ std::cout << "Hello, World!" << std::endl; };
lambda(); // 调用Lambda
```

这里，`auto lambda` 定义了一个Lambda表达式，然后通过 `lambda()` 来调用它。

从C++14开始，Lambda表达式可以直接定义并立即调用，而不需要先定义一个变量。这种写法称为“立即调用的Lambda表达式”（Immediately Invoked Lambda Expression，IIFE）。例如：

```cpp
[]{ std::cout << "Hello, World!" << std::endl; }(); // 定义并立即调用Lambda
```

这里，`[]{ std::cout << "Hello, World!" << std::endl; }` 定义了一个Lambda表达式，紧接着的 `()` 表示立即调用它。

## Lambda 表达式的实际应用

### 1. 与 STL 算法配合使用

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 使用 Lambda 过滤偶数
    numbers.erase(std::remove_if(numbers.begin(), numbers.end(), 
        [](int n) { return n % 2 != 0; }), 
        numbers.end());
    
    // 使用 Lambda 转换每个元素
    std::transform(numbers.begin(), numbers.end(), numbers.begin(),
        [](int n) { return n * 2; });
    
    // 使用 Lambda 输出结果
    std::for_each(numbers.begin(), numbers.end(), 
        [](int n) { std::cout << n << " "; });
    // 输出: 4 8 12 16 20
    
    return 0;
}
```

### 2. 作为回调函数

```cpp
#include <iostream>
#include <functional>
#include <thread>
#include <chrono>

void async_operation(std::function<void(int)> callback) {
    std::thread([callback]() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        callback(42); // 模拟异步操作完成
    }).detach();
}

int main() {
    std::cout << "Starting async operation..." << std::endl;
    
    async_operation([](int result) {
        std::cout << "Async operation completed with result: " << result << std::endl;
    });
    
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 等待异步操作完成
    return 0;
}
```

### 3. 创建函数工厂

```cpp
#include <iostream>

auto create_multiplier(double factor) {
    return [factor](double value) {
        return value * factor;
    };
}

int main() {
    auto times_two = create_multiplier(2.0);
    auto times_ten = create_multiplier(10.0);
    
    std::cout << "5 * 2 = " << times_two(5) << std::endl; // 输出: 10
    std::cout << "5 * 10 = " << times_ten(5) << std::endl; // 输出: 50
    
    return 0;
}
```

### 4. 在 GUI 编程中处理事件

```cpp
// 伪代码示例
button.on_click([](MouseEvent event) {
    if (event.position.x > 100) {
        std::cout << "Right side clicked!" << std::endl;
    } else {
        std::cout << "Left side clicked!" << std::endl;
    }
});
```

### 5. 在类成员函数中使用

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Logger {                      
public:
    static void info(const std::string& s) { std::cout << "[INFO] " << s << '\n'; }
};
```

#### 1. 捕获**当前成员函数的局部变量**

```cpp
class DemoLocal {
public:
    void work() {
        int local = 42;                       // 局部变量
        auto lam = [local] { std::cout << local << '\n'; };
        lam();                                // 打印 42
    }
};
```

---

#### 2. 捕获**成员变量**（3 种写法）

```cpp
class DemoMember {
    int value_ = 100;
public:
    void show() {
        // 2.1 值捕获 this
        auto lam1 = [this] { std::cout << value_ << '\n'; };    // 100

        // 2.2 引用捕获 this
        auto lam2 = [this] { value_ *= 2; };                   // 改原对象
        lam2();

        // 2.3 C++17 值捕获 *this（拷贝整个对象）
        auto lam3 = [*this] { std::cout << value_ << '\n'; };   // 200，但操作的是副本
        lam3();                                                // 原对象仍是 200
    }
};
```

---

#### 3. 调用**成员函数 + 静态成员**

```cpp
class DemoMethod {
    std::string name_ = "DemoMethod";
    static int counter_;
public:
    void run() {
        // 3.1 捕获 this 并调用成员函数
        auto print = [this] { dump(); };

        // 3.2 捕获 this 并改静态成员
        auto inc = [this] { ++counter_; };

        print();   // 打印 "DemoMethod"
        inc();
        inc();
        std::cout << "counter = " << counter_ << '\n';   // counter = 2
    }
private:
    void dump() const { std::cout << name_ << '\n'; }
};

int DemoMethod::counter_ = 0;
```

---

#### 4. 跨类调用**其他类的 public 成员**

```cpp
class DemoCross {
public:
    void cross() {
        // Lambda 里直接调用别的类的静态方法
        auto log = [] { Logger::info("hello from lambda"); };
        log();
    }
};
```

---

#### 5. 混合捕获：局部 + 成员 + 静态

```cpp
class DemoMix {
    double factor_ = 2.5;
    static int idx_;
public:
    void transform_vec(std::vector<double>& v) {
        int offset = 10;                      // 局部变量
        std::for_each(v.begin(), v.end(),
            [this, offset](double& x) {      // 捕获 this + 局部 offset
                x = x * factor_ + offset + idx_;
            });
        ++idx_;
    }
    void print(const std::vector<double>& v) const {
        for (double d : v) std::cout << d << ' ';
        std::cout << '\n';
    }
};

int DemoMix::idx_ = 0;
```

---

#### 6. 使用成员函数指针

还可以先获取成员函数指针，然后在lambda表达式中通过`this`指针和成员函数指针调用成员函数。示例如下：

```cpp
#include <iostream>
#include <functional>

class MyClass {
public:
    void memberFunction() {
        std::cout << "Member function called" << std::endl;
    }

    void useLambda() {
        // 获取成员函数指针
        void (MyClass::*funcPtr)() = &MyClass::memberFunction;

        // 定义lambda表达式，通过this指针和成员函数指针调用成员函数
        auto lambda = [this, funcPtr]() {
            (this->*funcPtr)();
        };

        // 调用lambda表达式
        lambda();
    }
};

int main() {
    MyClass obj;
    obj.useLambda();
    return 0;
}
```

在这个例子中，先获取了`memberFunction`成员函数的指针`funcPtr`，然后在lambda表达式中通过`this`指针和`funcPtr`调用成员函数。

---

#### 7. 常见注意点速记表

| 场景         | 捕获写法               | 说明                              |
| ------------ | ---------------------- | --------------------------------- |
| 修改成员变量 | `[this]`               | 必须捕获 `this` 才能访问 `value_` |
| 只读成员变量 | `[=]` 或 `[this]`      | 两者均可                          |
| 拷贝整个对象 | `[*this]`              | 改副本，不影响原对象              |
| 访问静态成员 | 不需要捕获             | 直接 `Class::member`              |
| 跨类调用     | 不需要捕获             | 直接 `OtherClass::func()`         |
| 局部变量     | `[local]` / `[&local]` | 值/引用捕获                       |

### 6. 和 `std::bind` 结合使用

除了捕获`this`指针，还可以使用`std::bind`来将成员函数绑定到特定的对象上，然后在lambda表达式中调用绑定后的函数。示例如下：

```cpp
#include <iostream>
#include <functional>

class MyClass {
public:
    void memberFunction() {
        std::cout << "Member function called" << std::endl;
    }

    void useLambda() {
        // 使用std::bind将成员函数绑定到当前对象
        auto boundFunction = std::bind(&MyClass::memberFunction, this);

        // 定义lambda表达式，调用绑定后的成员函数
        auto lambda = [&boundFunction]() {
            boundFunction();
        };

        // 调用lambda表达式
        lambda();
    }
};

int main() {
    MyClass obj;
    obj.useLambda();
    return 0;
}
```

在这个例子中，先使用`std::bind`将`memberFunction`成员函数绑定到当前对象`this`上，得到一个可调用对象`boundFunction`。然后在lambda表达式中通过引用捕获`boundFunction`并调用它，从而间接调用了类的成员函数。

## 通用 Lambda (C++14)

C++14 引入了通用 Lambda，可以使用 `auto` 作为参数类型：

```cpp
auto print = [](const auto& value) {
    std::cout << value << std::endl;
};

print(42);          // 输出: 42
print("Hello");     // 输出: Hello
print(3.14159);     // 输出: 3.14159
```

## Lambda 作为递归函数

Lambda 表达式可以通过 `std::function` 实现递归：

```cpp
#include <iostream>
#include <functional>

int main() {
    std::function<int(int)> factorial;
    
    factorial = [&factorial](int n) -> int {
        return (n <= 1) ? 1 : n * factorial(n - 1);
    };
    
    std::cout << "Factorial of 5: " << factorial(5) << std::endl; // 输出: 120
    return 0;
}
```

## Lambda 表达式的性能

Lambda 表达式在性能上通常优于 `std::function`：
- Lambda 是编译器生成的匿名类对象
- 没有虚函数调用开销
- 通常可以被编译器内联优化
- 对于小捕获列表，通常没有动态内存分配

## 最佳实践

1. **优先使用 Lambda 而不是函数对象**：语法更简洁
2. **明确捕获**：避免使用 `[=]` 或 `[&]` 隐式捕获所有变量
3. **注意生命周期**：引用捕获时要确保被引用的对象在 Lambda 使用时仍然存在
4. **使用初始化捕获**：对于需要移动的对象或复杂的初始化
5. **考虑使用通用 Lambda**：提高代码的通用性
6. **避免大型 Lambda**：如果函数体很大，考虑使用命名函数

## Lambda 表达式与 std::function

Lambda 表达式可以存储在 `std::function` 中，但要注意：
- `std::function` 有类型擦除的开销
- 直接使用 `auto` 存储 Lambda 更高效
- `std::function` 用于需要统一类型的回调存储

```cpp
#include <functional>
#include <vector>

int main() {
    std::vector<std::function<void()>> tasks;
    
    // 添加多个不同类型的 Lambda
    tasks.push_back([]() { std::cout << "Task 1\n"; });
    tasks.push_back([]() { std::cout << "Task 2\n"; });
    
    for (auto& task : tasks) {
        task(); // 执行所有任务
    }
    
    return 0;
}
```

# std::bind
> [std::bind - cppreference.com](https://en.cppreference.com/w/cpp/utility/functional/bind.html) 

`std::bind` 是 C++ 标准库中的一个函数模板，用于创建一个可调用对象，该对象可以将参数绑定到另一个可调用对象（如函数、lambda 表达式、函数对象等）。`std::bind` 的主要用途是固定某些参数，从而生成一个新的可调用对象，这个新对象在被调用时会自动传递这些固定的参数。

```cpp
template <typename F, typename... Args>
std::function<typename std::result_of<F(Args...)>::type> bind(F&& f, Args&&... args);
```

- **`F`**：可调用对象的类型。
- **`Args`**：参数列表的类型。
- **`f`**：可调用对象（如函数、lambda 表达式、函数对象等）。
- **`args`**：要绑定的参数。

`std::bind` 返回一个 `std::function` 对象，该对象可以被调用，并且会将固定的参数传递给原始的可调用对象。

1. **参数**：
   - 第一个参数 `f` 是一个可调用对象。
   - 后续的参数 `args` 是要绑定到 `f` 的参数。

2. **返回值**：
   - 返回一个 `std::function` 对象，该对象可以被调用，并且会将固定的参数传递给原始的可调用对象。

`std::bind` 的工作原理可以分为以下几个步骤：
1. **获取可调用对象**：第一个参数是一个可调用对象，可以是普通函数、成员函数指针、lambda 表达式等。
2. **绑定参数**：后续的参数是要绑定到可调用对象的参数。
3. **生成新的可调用对象**：`std::bind` 返回一个 `std::function` 对象，该对象可以被调用，并且会将固定的参数传递给原始的可调用对象。

## 示例

### 示例 1：绑定函数参数
```cpp
#include <iostream>
#include <functional> // std::bind, std::function

void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

int main() {
    // 使用 std::bind 将 "Hello, World!" 绑定到 printMessage
    auto printHello = std::bind(printMessage, "Hello, World!");

    // 调用绑定后的函数
    printHello(); // 输出: Hello, World!

    return 0;
}
```

- `std::bind(printMessage, "Hello, World!")` 创建了一个新的可调用对象 `printHello`。
- 当调用 `printHello()` 时，它会自动将 `"Hello, World!"` 传递给 `printMessage`。

### 示例 2：绑定成员函数
```cpp
#include <iostream>
#include <functional> // std::bind, std::function

class MyClass {
public:
    void printMessage(const std::string& message) {
        std::cout << message << std::endl;
    }
};

int main() {
    MyClass obj;
    std::string message = "Hello from MyClass";

    // 使用 std::bind 将 obj 和 message 绑定到 printMessage
    auto printHello = std::bind(&MyClass::printMessage, &obj, message);

    // 调用绑定后的函数
    printHello(); // 输出: Hello from MyClass

    return 0;
}
```

在C++中，成员函数和普通函数是不同的。成员函数需要一个对象来调用，而普通函数不需要。为了表示成员函数，需要使用取地址操作符 `&` 来获取成员函数的指针。

`std::bind` 的第二个参数是要绑定的对象。对于成员函数，需要一个对象来调用该成员函数。因此，我们需要传递对象的地址。

- **成员函数指针**：`&MyClass::printMessage` 是一个成员函数指针，表示 `MyClass` 类中的 `printMessage` 成员函数。
- `&obj`：传递 `obj` 的地址，表示 `printMessage` 将在这个对象上被调用。
- `message`：传递的参数，表示 `printMessage` 的第一个参数。
- **`std::bind`**：将成员函数指针和对象的地址绑定在一起，生成一个新的可调用对象。
- **普通函数指针**：对于普通函数，可以直接使用函数名，因为函数名本身就是一个指针。
```cpp
void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

int main() {
    auto printHello = std::bind(printMessage, "Hello from function");
    printHello(); // 输出: Hello from function
}
```
在这个例子中，`printMessage` 是一个普通函数，可以直接使用函数名。

### 示例 3：绑定成员变量
```cpp
#include <iostream>
#include <functional> // std::bind, std::function

class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}
};

int main() {
    MyClass obj(42);

    // 使用 std::bind 将 obj 绑定到成员变量 value
    auto getValue = std::bind(&MyClass::value, &obj);

    // 调用绑定后的函数
    std::cout << "Value: " << getValue() << std::endl; // 输出: Value: 42

    return 0;
}
```

- `std::bind(&MyClass::value, &obj)` 创建了一个新的可调用对象 `getValue`。
- 当调用 `getValue()` 时，它会自动返回 `obj.value` 的值。

### 示例 4：使用占位符
`std::bind` 支持使用占位符 `_1`, `_2`, `_3` 等，这些占位符表示调用时传递的参数。

```cpp
#include <iostream>
#include <functional> // std::bind, std::function, std::placeholders

void printMessage(const std::string& message, int number) {
    std::cout << message << " " << number << std::endl;
}

int main() {
    // 使用 std::bind 将 "Hello" 绑定到 printMessage，并使用占位符 _1 表示调用时传递的参数
    auto printHello = std::bind(printMessage, "Hello", std::placeholders::_1);

    // 调用绑定后的函数
    printHello(42); // 输出: Hello 42

    return 0;
}
```

- `std::placeholders::_1` 是一个占位符，表示调用时传递的第一个参数。
- `std::bind(printMessage, "Hello", std::placeholders::_1)` 创建了一个新的可调用对象 `printHello`。
- 当调用 `printHello(42)` 时，它会自动将 `"Hello"` 和 `42` 传递给 `printMessage`。

### 示例 5：绑定多个参数
`std::bind` 可以绑定多个参数，并且可以使用多个占位符。

```cpp
#include <iostream>
#include <functional> // std::bind, std::function, std::placeholders

void printMessage(const std::string& message, int number, double value) {
    std::cout << message << " " << number << " " << value << std::endl;
}

int main() {
    // 使用 std::bind 将 "Hello" 绑定到 printMessage，并使用占位符 _1 和 _2 表示调用时传递的参数
    auto printHello = std::bind(printMessage, "Hello", std::placeholders::_1, std::placeholders::_2);

    // 调用绑定后的函数
    printHello(42, 3.14); // 输出: Hello 42 3.14

    return 0;
}
```

- `std::placeholders::_1` 和 `std::placeholders::_2` 是占位符，分别表示调用时传递的第一个和第二个参数。
- `std::bind(printMessage, "Hello", std::placeholders::_1, std::placeholders::_2)` 创建了一个新的可调用对象 `printHello`。
- 当调用 `printHello(42, 3.14)` 时，它会自动将 `"Hello"`、`42` 和 `3.14` 传递给 `printMessage`。

# std::function
> [std::function - cppreference.com](https://en.cppreference.com/w/cpp/utility/functional/function.html) 
> [https://cplusplus.com/reference/functional/function/function/](https://cplusplus.com/reference/functional/function/function/) 

std::function 是 C++11 引入的一个通用的函数包装器，它是一个类模板，定义在 <functional> 头文件中。它可以存储、复制和调用任何可调用对象（callable object）。

- 它是一个类模板，不是一个函数

- 它可以包装各种类型的可调用实体

- 提供统一的调用接口

- 实现了类型擦除（type erasure）技术

```cpp
template <typename> class function;
```

具体使用时，需要指定其模板参数，通常是返回类型和参数列表，形式如下：

```cpp
std::function<返回类型(参数列表)>
```

例如：

```cpp
std::function<int(int, int)> add; // 可以存储一个接受两个 int 参数并返回一个 int 的函数
std::function<void()> print;     // 可以存储一个无参数无返回值的函数
```

## 实现逻辑

它的魔力在于**类型擦除**：你可以在编译时不知道具体类型的情况下，在运行时存储和调用各种可调用对象。

`std::function` 的实现通常基于 **“小对象优化” + 虚函数多态** 的策略。核心思想是：

1. 定义一个通用接口
2. 为每种可调用类型生成一个特化实现
3. 通过指针间接调用，擦除具体类型

构建一个简化版的 `MyFunction`：

```cpp
// 第一步：定义通用的调用接口
class CallableBase {
public:
    virtual ~CallableBase() = default;
    virtual void invoke() = 0; // 纯虚函数，用于调用
    virtual CallableBase* clone() const = 0; // 用于复制
};

// 第二步：为具体类型实现特化模板
template<typename F>
class CallableImpl : public CallableBase {
public:
    CallableImpl(F func) : func_(std::move(func)) {}
    
    void invoke() override {
        func_(); // 调用存储的可调用对象
    }
    
    CallableBase* clone() const override {
        return new CallableImpl<F>(func_);
    }
    
private:
    F func_; // 存储的实际可调用对象
};

// 第三步：实现MyFunction包装器
class MyFunction {
public:
    // 默认构造
    MyFunction() : callable_(nullptr) {}
    
    // 模板构造函数，接受任何可调用类型
    template<typename F>
    MyFunction(F func) {
        // 关键：在堆上创建具体类型的CallableImpl
        callable_ = new CallableImpl<F>(std::move(func));
    }
    
    // 复制构造函数（需要深拷贝）
    MyFunction(const MyFunction& other) {
        if (other.callable_) {
            callable_ = other.callable_->clone();
        } else {
            callable_ = nullptr;
        }
    }
    
    // 移动构造函数
    MyFunction(MyFunction&& other) noexcept : callable_(other.callable_) {
        other.callable_ = nullptr;
    }
    
    ~MyFunction() {
        delete callable_;
    }
    
    // 调用运算符
    void operator()() {
        if (callable_) {
            callable_->invoke();
        } else {
            throw std::bad_function_call();
        }
    }
    
private:
    CallableBase* callable_; // 指向基类的指针
};
```

###  性能优化：小对象优化（Small Object Optimization）

真实的 `std::function` 不会每次都进行堆分配，而是使用小对象优化：

```cpp
#include <new> // placement new
#include <cstdlib>

class OptimizedFunction {
    static constexpr size_t BufferSize = 32; // 通常足够存储函数指针和小Lambda
    
    // 联合体：要么使用堆分配，要么使用内部缓冲区
    union {
        void* heap_ptr;      // 指向堆分配的对象
        char buffer[BufferSize]; // 内部缓冲区
    } storage_;
    
    bool use_heap_; // 标记使用堆还是缓冲区
    
    CallableBase* get_callable() {
        if (use_heap_) {
            return static_cast<CallableBase*>(storage_.heap_ptr);
        } else {
            return reinterpret_cast<CallableBase*>(storage_.buffer);
        }
    }
    
    template<typename F>
    void initialize(F&& func) {
        // 如果对象小，使用内部缓冲区
        if (sizeof(CallableImpl<F>) <= BufferSize) {
            new (storage_.buffer) CallableImpl<F>(std::forward<F>(func));
            use_heap_ = false;
        } else {
            // 否则堆分配
            storage_.heap_ptr = new CallableImpl<F>(std::forward<F>(func));
            use_heap_ = true;
        }
    }
    
    // ... 其他成员函数需要相应修改 ...
};
```

## 存储和调用

`std::function` 可以存储以下类型的可调用对象：

- 普通函数
- Lambda 表达式
- 函数对象
- 绑定的成员函数
- `std::bind` 的结果

### 存储普通函数

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    std::function<int(int, int)> f = add;
    std::cout << f(2, 3) << std::endl; // 输出 5
}
```

### 存储 Lambda 表达式

```cpp
int main() {
    std::function<int(int, int)> f = [](int a, int b) { return a + b; };
    std::cout << f(2, 3) << std::endl; // 输出 5
}
```

### 存储函数对象

```cpp
struct Adder {
    int operator()(int a, int b) const {
        return a + b;
    }
};

int main() {
    std::function<int(int, int)> f = Adder();
    std::cout << f(2, 3) << std::endl; // 输出 5
}
```

### 存储绑定的成员函数

```cpp
#include <functional>
#include <iostream>

struct Data {
    int value;
    void print() const { std::cout << "Value: " << value << std::endl; }
};

int main() {
    Data d{42};
    std::function<void()> f = std::bind(&Data::print, &d);
    f(); // 输出 Value: 42
}
```

## Result_type 嵌套类型

`result_type` 确实是 `std::function` 的一个嵌套类型（nested type），这是C++标准库中函数对象适配器的常见设计模式。

`std::function` 是一个模板类，其简化定义大致如下：

```cpp
template<typename>
class function;  // 主模板声明

template<typename R, typename... Args>
class function<R(Args...)> {  // 特化版本
public:
    using result_type = R;  // 嵌套类型定义
    
    // 其他成员...
    R operator()(Args... args) const;
    // ...
};
```

### `result_type` 的作用和意义

#### 1. 提供统一的类型查询接口
```cpp
std::function<int(double, std::string)> func;
// 通过 result_type 获取返回类型
std::function<int(double, std::string)>::result_type value = 42;  // value 是 int 类型
```

#### 2. 用于模板元编程
```cpp
template<typename Func>
void process_function() {
    // 在模板代码中获取函数的返回类型
    typename Func::result_type default_value{};
    // ...
}

// 使用
process_function<std::function<bool(int)>>();
```

#### 3. 与其他标准库组件保持一致
许多C++标准库的可调用对象包装器都有类似的嵌套类型：
- `std::function<>::result_type`
- `std::plus<>::result_type` (以及其他算术函数对象)
- `std::negate<>::result_type`

## `std::function` 的完整嵌套类型

`std::function` 提供了多个嵌套类型用于类型查询：

```cpp
template<typename R, typename... Args>
class function<R(Args...)> {
public:
    using result_type = R;                   // 返回类型 (C++17前)
    
    // C++17 引入了更完整的类型特征
    using result_type = R;                   // 返回类型
    using argument_type = Args...;           // 参数类型（单参数时）
    using first_argument_type = Args...;     // 第一个参数（多参数时）
    using second_argument_type = Args...;    // 第二个参数（多参数时）
};
```

### C++11/C++14
```cpp
// 主要使用 result_type
std::function<int()>::result_type x = 10;  // int
```

### C++17
```cpp
// 引入了更完整的类型特征，但 result_type 仍然存在
std::function<int(double)> func;
using Result = decltype(func)::result_type;          // int
using Arg = std::tuple_element_t<0, decltype(func)::argument_type>;  // double
```

### C++20
```cpp
// 引入了更多现代类型特征工具
std::function<int(double)> func;
using Result = std::invoke_result_t<decltype(func), double>;  // int
```

### 示例1：类型安全的函数处理
```cpp
template<typename Func>
auto call_and_process(Func func) -> typename Func::result_type {
    // 获取函数的返回类型
    typename Func::result_type result = func();
    
    // 进行一些处理
    std::cout << "Function returned type: " 
              << typeid(typename Func::result_type).name() << std::endl;
    
    return result;
}

// 使用
std::function<std::string()> get_string = [] { return "Hello"; };
auto result = call_and_process(get_string);
```

### 示例2：通用函数包装器
```cpp
template<typename Func>
class FunctionLogger {
public:
    using result_type = typename Func::result_type;
    
    FunctionLogger(Func f) : func_(f) {}
    
    template<typename... Args>
    result_type operator()(Args... args) {
        std::cout << "Calling function..." << std::endl;
        result_type result = func_(args...);
        std::cout << "Function returned: " << result << std::endl;
        return result;
    }
    
private:
    Func func_;
};

// 使用
std::function<int(int, int)> add = [](int a, int b) { return a + b; };
FunctionLogger<decltype(add)> logged_add(add);
int sum = logged_add(3, 4);  // 输出调用日志
```

### 设计意义

#### 1. 类型擦除的补偿
`std::function` 使用了类型擦除技术，可以包装任何可调用对象。嵌套类型提供了在类型擦除后仍然能够查询原始类型信息的方法。

#### 2. 元编程支持
在模板元编程中，经常需要查询函数对象的类型特征：
```cpp
template<typename F>
void analyze_function() {
    using Result = typename F::result_type;
    // 编译时分析函数特征
    static_assert(std::is_same_v<Result, int>, "Function must return int");
}
```

#### 3. 接口统一性
标准库中的各种函数对象（functor）都遵循类似的模式，提供一致的接口。

## 使用场景

### 1. 作为回调函数

```cpp
#include <iostream>
#include <functional>
#include <thread>
#include <chrono>

void async_operation(std::function<void(int)> callback) {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    callback(42);
}

int main() {
    async_operation([](int result) {
        std::cout << "Async operation completed with result: " << result << std::endl;
    });
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 0;
}
```

### 2. 作为算法的参数

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    std::function<int(int)> square = [](int x) { return x * x; };

    std::transform(v.begin(), v.end(), v.begin(), square);

    for (int n : v) {
        std::cout << n << ' ';
    }
    std::cout << std::endl; // 输出 1 4 9 16 25
}
```

### 3. 作为事件处理器

```cpp
#include <iostream>
#include <functional>
#include <vector>

class Button {
public:
    void setOnClick(std::function<void()> handler) {
        onClick_ = handler;
    }

    void click() {
        if (onClick_) onClick_();
    }

private:
    std::function<void()> onClick_;
};

int main() {
    Button button;
    button.setOnClick([]() {
        std::cout << "Button clicked!" << std::endl;
    });

    button.click(); // 输出 Button clicked!
    return 0;
}
```

## 注意

1. **性能**：`std::function` 有一个小的性能开销，因为它需要存储和调用一个可调用对象。对于性能敏感的应用，应谨慎使用。
2. **类型安全**：`std::function` 会进行严格的类型检查，确保调用时的参数和返回类型与存储的可调用对象一致。
3. **空函数**：`std::function` 可以为空，调用空的 `std::function` 会导致未定义行为。可以通过 `if (f)` 来检查是否为空。
