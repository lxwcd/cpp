C++ 学习笔记

# 虚函数表 (Virtual Function Table, vtable)

这是一个理解C++多态（Polymorphism）核心机制的关键概念。

在面向对象编程中，多态意味着“一个接口，多种实现”。在C++中，通过以下方式实现多态：

1.  **基类**中使用 `virtual` 关键字声明函数（虚函数）。
2.  **派生类**中**重写（override）** 这个虚函数。
3.  使用**基类的指针或引用**来指向**派生类的对象**。
4.  通过该指针或引用调用虚函数时，实际调用的是派生类中重写的版本。

**核心问题：** 在编译阶段，编译器只知道指针是基类类型的，它无法确定这个指针指向的到底是基类对象还是某个派生类对象。那么程序在运行时，如何正确地决定应该调用哪个函数呢？

**答案：** 这就是虚函数表要解决的问题。它是一种在运行时进行函数解析的机制，是C++实现动态绑定的基石。

**虚函数表（vtable）** 是一个编译器在编译时为每个**包含虚函数的类**（或者从包含虚函数的类继承而来的类）自动生成的**静态函数指针数组**。

*   **每个类一个表**：每个有虚函数的类都有自己的虚函数表。
*   **表的内容**：表中的每一个条目（slot）都是该类的一个虚函数的地址。这些条目按照虚函数声明的顺序排列。
*   **指向表的指针（vptr）**：编译器还会隐式地为该类的**每一个对象**添加一个隐藏的指针成员（通常称为 `vptr`）。这个 `vptr` 指向该类的虚函数表。

## 机制和原理：内存布局与动态绑定

```cpp
class Base {
public:
    virtual void func1() { cout << "Base::func1" << endl; }
    virtual void func2() { cout << "Base::func2" << endl; }
    void func3() { cout << "Base::func3 (non-virtual)" << endl; } // 非虚函数
    int base_data;
};

class Derived : public Base {
public:
    void func1() override { cout << "Derived::func1" << endl; } // 重写 func1
    virtual void func4() { cout << "Derived::func4" << endl; } // 新的虚函数
    int derived_data;
};
```

**1. 编译期：生成虚函数表**

编译器会为 `Base` 和 `Derived` 类分别生成一个虚函数表。

*   **`Base` 类的 vtable:**
    | 索引 | 函数指针       | 指向的实际函数  |
    | :--- | :------------- | :-------------- |
    | 0    | `&Base::func1` | `Base::func1()` |
    | 1    | `&Base::func2` | `Base::func2()` |

*   **`Derived` 类的 vtable:**
    | 索引 | 函数指针          | 指向的实际函数     |
    | :--- | :---------------- | :----------------- |
    | 0    | `&Derived::func1` | `Derived::func1()` | // 重写了，地址不同   |
    | 1    | `&Base::func2`    | `Base::func2()`    | // 没重写，继承基类的 |
    | 2    | `&Derived::func4` | `Derived::func4()` | // 新增的虚函数       |

**注意：** 派生类的虚函数表首先包含基类的虚函数条目，然后才是自己的。这保证了基类和派生类中相同功能的虚函数在表中的**索引位置（offset）是相同的**。这是实现多态的关键。

**2. 对象构建时：初始化 vptr**

当创建对象时，会发生以下事情：

```cpp
Derived d;
```

*   在构造 `Derived` 对象 `d` 时，它的内存中不仅包含 `Base` 的成员 `base_data` 和自身的成员 `derived_data`，**开头还会有一个隐藏的指针 `vptr`** (通常在所有显式定义的成员之前)。
*   在 `Derived` 的构造函数被调用过程中（在初始化列表之后，函数体之前），这个 `vptr` 会被设置为指向 `Derived` 类的虚函数表。

**`Derived` 对象 `d` 的内存布局：**
```
+--------------------------+
| vptr (隐藏成员)          | ----> 指向 Derived::vtable
+--------------------------+
| base_data (来自 Base)    |
+--------------------------+
| derived_data (来自 Derived) |
+--------------------------+
```

**3. 运行时：通过动态绑定调用函数**

```cpp
Base* bp = new Derived(); // bp 是 Base 指针，指向一个 Derived 对象
bp->func1(); // 输出 "Derived::func1"
```

`bp->func1()` 这行代码的执行过程如下：

1.  **编译器层面：** 编译器看到 `bp` 是 `Base*` 类型，并且 `func1` 是虚函数。它知道不能直接进行静态绑定（即直接调用 `Base::func1`）。
2.  **生成指令：** 编译器会生成一系列指令来执行**动态绑定**：
    a. 通过 `bp` 指针找到它所指向的对象。
    b. 从该对象的内存起始位置取出 `vptr`（因为编译器知道 `vptr` 总是在对象的最开始）。
    c. 通过 `vptr` 找到类的 `vtable`。
    d. 在 `vtable` 中找到第 `0` 个条目（因为 `func1` 在基类中是第一个声明的虚函数，索引为0）。
    e. 调用该条目中存储的函数地址（即 `&Derived::func1`）。
3.  **运行时执行：** CPU 执行上述指令，最终跳转到 `Derived::func1` 的代码并执行。

**对于非虚函数调用：**
```cpp
bp->func3(); // 输出 "Base::func3 (non-virtual)"
```
编译器在编译时就知道 `bp` 是 `Base*` 类型，并且 `func3` 不是虚函数。所以它直接进行静态绑定，生成调用 `Base::func3` 的指令，完全不会涉及 vtable。

## 虚函数表 (vtable) 的创建时机

*   **编译期（Compile Time）**
    vtable 是编译器在编译源代码时生成的。它是一个**静态的数据结构**，存储在程序的**只读数据段**（通常与代码段在一起）。每个类有且只有一个 vtable，所有该类的对象共享同一个 vtable。

## 虚指针 (vptr) 的初始化和设置时机

*   **运行期（Run Time）**，具体是在**对象的构造过程中**。
    当一个对象被创建时，它的 `vptr` 的初始化是**由编译器在类的构造函数中自动插入代码来完成的**。

## 对象的构造过程

当一个派生类对象被创建时（例如 `Derived d;`），其完整的构造顺序如下：

1.  **分配内存**：首先为整个派生类对象分配足够的内存（包括基类子对象和派生类自身成员的内存）。

2.  **构造基类部分**：
    *   **调用基类构造函数**：根据初始化列表或默认规则，调用基类的构造函数。
    *   **设置基类 vptr**：**在进入基类构造函数体 `{...}` 之前**，编译器插入代码，将**对象中基类子对象部分的 `vptr`** 设置为指向**基类的虚函数表（Base::vtable）**。
    *   **执行基类初始化列表**：执行基类构造函数的初始化列表。
    *   **执行基类构造函数体**：执行基类构造函数函数体内的代码。
    *   **此时**，如果基类构造函数中调用虚函数，由于 `vptr` 指向 Base::vtable，因此会调用基类自己的版本，而不是派生类重写的版本。

3.  **构造派生类部分**：
    *   **设置派生类 vptr**：在基类构造完成后，**在进入派生类构造函数体 `{...}` 之前**，编译器再次插入代码，将对象的 `vptr` **重新设置为指向派生类的虚函数表（Derived::vtable）**。这一步覆盖了之前在基类构造时设置的 `vptr`。
    *   **执行派生类初始化列表**：执行派生类构造函数的初始化列表（初始化派生类自己的成员以及虚基类等）。
    *   **执行派生类构造函数体**：执行派生类构造函数函数体内的代码。
    *   **从此之后**，任何通过该对象进行的虚函数调用，都将使用 `Derived::vtable` 进行解析。

**关键点：**
*   `vptr` 的设置发生在**每个构造函数的初始化阶段**（在初始化列表处理之后，构造函数体执行之前）。
*   在构造过程中，`vptr` 的值会**被多次修改**。它首先被设置为当前正在构造的类的 vtable，以确保在构造函数体内调用虚函数时行为是确定和安全的（调用当前类的版本）。
*   最终，当派生类的构造函数完成后，`vptr` 才稳定地指向派生类的 vtable。

## 析构过程（完全相反的顺序）

析构过程是构造过程的逆序，同样遵循严格的规则：

1.  **析构派生类部分**：
    *   **执行派生类析构函数体**：执行 `~Derived() {...}` 函数体内的代码。
    *   **设置派生类 vptr**：在派生类析构函数体执行完毕后，编译器插入代码，将对象的 `vptr` **重新设置为指向基类的虚函数表（Base::vtable）**。这样做的目的是确保在后续的析构过程中（比如基类析构函数中调用虚函数），调用的是基类的版本，因为派生类的部分已经被销毁了，再调用派生类的函数是危险的。
    *   **调用成员对象和基类的析构函数**：编译器自动调用派生类成员对象的析构函数（按照声明的逆序），然后调用基类的析构函数。

2.  **析构基类部分**：
    *   **执行基类析构函数体**：执行 `~Base() {...}` 函数体内的代码。
    *   （如果需要）**设置基类 vptr**：在基类析构函数体执行完毕后，如果基类还有自己的基类，`vptr` 可能会被再次设置指向更基类的 vtable。对于没有更基类的类，这一步可能就不需要了。
    *   **释放内存**：最终，对象占用的内存被释放。


## 总结

*   **构造顺序**：基类 -> 派生类。`vptr` 的设置跟随这个顺序，从基类的表逐步变为派生类的表。
*   **析构顺序**：派生类 -> 基类。`vptr` 的设置也跟随这个顺序，从派生类的表**回退**到基类的表。
*   **黄金法则**：**绝对不要在构造函数和析构函数中调用虚函数**。因为在这两个阶段，`vptr` 指向的是**当前正在被构造或析构的类**的虚函数表，而不是最终派生类的表。这意味着不会得到多态行为，调用的是当前层次的函数实现，这可能不是期望的。

**示例：**
```cpp
Derived::Derived(/* args */) // 构造函数
    : Base(/* base args */) // 1. 先调用基类构造函数
    //, ... 其他初始化列表
{
    // 在进入函数体之前，编译器插入代码：`this->vptr = &Derived::vtable;`
    // 2. 设置 vptr 指向 Derived 的 vtable
    derived_data = 0; // 3. 执行函数体内的代码
}
```

## 关键点

1.  **目的**：vtable 是实现C++运行时多态（动态绑定）的核心机制。
2.  **是什么**：
    *   **vtable**： 每个类一个，静态函数指针数组。
    *   **vptr**： 每个对象一个，隐藏指针，指向其类的 vtable。
3.  **工作原理**： 通过对象的 `vptr` 找到类的 `vtable`，再通过固定的索引找到要调用的虚函数地址。
4.  **创建时机**：
    *   **vtable** -> **编译期**生成，存在于静态存储区。
    *   **vptr** -> **运行期**在对象的构造/析构过程中，由编译器自动插入的代码进行设置。
5.  **性能开销**：
    *   **空间开销**：每个对象需要一个额外的指针（vptr）空间。每个类需要一个vtable的空间。
    *   **时间开销**：每次调用虚函数比调用非虚函数多一次间接寻址（通过vptr找vtable，再通过索引找函数地址）的开销。现代CPU对此有很好的优化，但理论上仍有轻微损耗。
    *   **编译器优化**：通常虚函数调用无法被内联。
6.  **其他说明**：
    *   对于**多重继承**和**虚拟继承**，vtable 的结构会变得更加复杂，但核心思想不变。
    *   使用 `final` 关键字可以阻止类被继承或虚函数被重写，有时允许编译器进行去虚拟化（devirtualization）优化，绕过 vtable。

# operator

`operator` 关键字在 C++ 中用于重载操作符或定义类型转换函数。它允许为自定义类型定义操作符的行为，使这些类型可以像内置类型一样使用操作符。

```cpp
return_type operator op (parameters) {
    // 操作实现
}
```

1. **算术操作符**：`+`, `-`, `*`, `/`, `%` 等
2. **比较操作符**：`==`, `!=`, `<`, `>`, `<=`, `>=` 等
3. **赋值操作符**：`=`, `+=`, `-=`, `*=`, `/=` 等
4. **下标操作符**：`[]`
5. **函数调用操作符**：`()`
6. **递增递减操作符**：`++`, `--`
7. **类型转换操作符**：`operator type()`
8. **流操作符**：`<<`, `>>`

使用操作符重载时需要注意：
- 保持操作符的语义一致性
- 考虑是否需要同时提供成员函数和非成员函数版本
- 对于对称操作符（如 `+`），通常定义为非成员函数
- 使用 `explicit` 关键字防止意外的隐式类型转换
- 注意处理自赋值情况（特别是在赋值操作符中）

## 算术操作符重载

```cpp
#include <iostream>

class Complex {
private:
    double real;
    double imag;
public:
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}
    
    // 重载 + 操作符
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // 重载 - 操作符
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    
    // 重载 * 操作符
    Complex operator*(const Complex& other) const {
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }
    
    // 重载 << 操作符（输出）
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
};

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real << " + " << c.imag << "i";
    return os;
}

int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.0, 2.0);
    
    std::cout << "c1 = " << c1 << std::endl;
    std::cout << "c2 = " << c2 << std::endl;
    std::cout << "c1 + c2 = " << (c1 + c2) << std::endl;
    std::cout << "c1 - c2 = " << (c1 - c2) << std::endl;
    std::cout << "c1 * c2 = " << (c1 * c2) << std::endl;
    
    return 0;
}
```

## 比较操作符重载

```cpp
#include <iostream>

class Date {
private:
    int day, month, year;
public:
    Date(int d, int m, int y) : day(d), month(m), year(y) {}
    
    // 重载 == 操作符
    bool operator==(const Date& other) const {
        return day == other.day && month == other.month && year == other.year;
    }
    
    // 重载 != 操作符
    bool operator!=(const Date& other) const {
        return !(*this == other);
    }
    
    // 重载 < 操作符
    bool operator<(const Date& other) const {
        if (year != other.year) return year < other.year;
        if (month != other.month) return month < other.month;
        return day < other.day;
    }
    
    // 重载 > 操作符
    bool operator>(const Date& other) const {
        return other < *this;
    }
    
    // 重载 << 操作符
    friend std::ostream& operator<<(std::ostream& os, const Date& d);
};

std::ostream& operator<<(std::ostream& os, const Date& d) {
    os << d.day << "/" << d.month << "/" << d.year;
    return os;
}

int main() {
    Date d1(15, 5, 2023);
    Date d2(20, 5, 2023);
    Date d3(15, 5, 2023);
    
    std::cout << "d1: " << d1 << std::endl;
    std::cout << "d2: " << d2 << std::endl;
    std::cout << "d3: " << d3 << std::endl;
    
    std::cout << "d1 == d2: " << (d1 == d2) << std::endl;
    std::cout << "d1 == d3: " << (d1 == d3) << std::endl;
    std::cout << "d1 < d2: " << (d1 < d2) << std::endl;
    std::cout << "d1 > d2: " << (d1 > d2) << std::endl;
    
    return 0;
}
```

## 赋值操作符重载

```cpp
#include <iostream>
#include <cstring>

class MyString {
private:
    char* data;
    size_t length;
    
    void copyString(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
    
public:
    // 构造函数
    MyString(const char* str = "") {
        copyString(str);
    }
    
    // 拷贝构造函数
    MyString(const MyString& other) {
        copyString(other.data);
    }
    
    // 析构函数
    ~MyString() {
        delete[] data;
    }
    
    // 重载赋值操作符
    MyString& operator=(const MyString& other) {
        if (this != &other) { // 防止自赋值
            delete[] data;
            copyString(other.data);
        }
        return *this;
    }
    
    // 重载 += 操作符
    MyString& operator+=(const MyString& other) {
        size_t newLength = length + other.length;
        char* newData = new char[newLength + 1];
        
        strcpy(newData, data);
        strcat(newData, other.data);
        
        delete[] data;
        data = newData;
        length = newLength;
        
        return *this;
    }
    
    // 重载 + 操作符
    MyString operator+(const MyString& other) const {
        MyString result = *this;
        result += other;
        return result;
    }
    
    // 重载 [] 操作符
    char& operator[](size_t index) {
        return data[index];
    }
    
    // 重载 const [] 操作符
    const char& operator[](size_t index) const {
        return data[index];
    }
    
    // 重载 << 操作符
    friend std::ostream& operator<<(std::ostream& os, const MyString& s);
};

std::ostream& operator<<(std::ostream& os, const MyString& s) {
    os << s.data;
    return os;
}

int main() {
    MyString s1 = "Hello";
    MyString s2 = " World";
    
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;
    
    MyString s3 = s1 + s2;
    std::cout << "s1 + s2: " << s3 << std::endl;
    
    s1 += s2;
    std::cout << "s1 += s2: " << s1 << std::endl;
    
    std::cout << "s3[0]: " << s3[0] << std::endl;
    s3[0] = 'h';
    std::cout << "After s3[0] = 'h': " << s3 << std::endl;
    
    return 0;
}
```

## 类型转换操作符

```cpp
#include <iostream>
#include <string>

class Number {
private:
    double value;
public:
    Number(double v = 0.0) : value(v) {}
    
    // 转换为 int
    explicit operator int() const {
        return static_cast<int>(value);
    }
    
    // 转换为 double
    operator double() const {
        return value;
    }
    
    // 转换为 bool
    explicit operator bool() const {
        return value != 0.0;
    }
    
    // 转换为 std::string
    operator std::string() const {
        return std::to_string(value);
    }
    
    // 重载 << 操作符
    friend std::ostream& operator<<(std::ostream& os, const Number& n);
};

std::ostream& operator<<(std::ostream& os, const Number& n) {
    os << n.value;
    return os;
}

int main() {
    Number n(3.14);
    
    // 隐式转换为 double
    double d = n;
    std::cout << "As double: " << d << std::endl;
    
    // 显式转换为 int
    int i = static_cast<int>(n);
    std::cout << "As int: " << i << std::endl;
    
    // 显式转换为 bool
    if (static_cast<bool>(n)) {
        std::cout << "As bool: true" << std::endl;
    }
    
    // 隐式转换为 string
    std::string s = n;
    std::cout << "As string: " << s << std::endl;
    
    return 0;
}
```

## 函数调用操作符

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Multiplier {
private:
    int factor;
public:
    Multiplier(int f) : factor(f) {}
    
    // 重载函数调用操作符，仿函数
    int operator()(int x) const {
        return x * factor;
    }
};

class RangeChecker {
private:
    int min, max;
public:
    RangeChecker(int m, int M) : min(m), max(M) {}
    
    // 重载函数调用操作符
    bool operator()(int x) const {
        return x >= min && x <= max;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 使用函数对象进行转换
    Multiplier timesTwo(2);
    std::vector<int> doubled;
    for (int n : numbers) {
        doubled.push_back(timesTwo(n));
    }
    
    std::cout << "Original: ";
    for (int n : numbers) std::cout << n << " ";
    std::cout << std::endl;
    
    std::cout << "Doubled: ";
    for (int n : doubled) std::cout << n << " ";
    std::cout << std::endl;
    
    // 使用函数对象进行筛选
    RangeChecker inRange(2, 4);
    std::cout << "Numbers in range [2, 4]: ";
    for (int n : numbers) {
        if (inRange(n)) {
            std::cout << n << " ";
        }
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 下标操作符重载

```cpp
#include <iostream>
#include <stdexcept>

class SafeArray {
private:
    int* data;
    size_t size;
public:
    SafeArray(size_t s) : size(s) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) {
            data[i] = 0;
        }
    }
    
    ~SafeArray() {
        delete[] data;
    }
    
    // 重载下标操作符（非常量版本）
    int& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    // 重载下标操作符（常量版本）
    const int& operator[](size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    size_t getSize() const {
        return size;
    }
};

int main() {
    SafeArray arr(5);
    
    // 使用下标操作符赋值
    for (size_t i = 0; i < arr.getSize(); ++i) {
        arr[i] = static_cast<int>(i) * 10;
    }
    
    // 使用下标操作符读取
    std::cout << "Array elements: ";
    for (size_t i = 0; i < arr.getSize(); ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    
    // 测试越界访问
    try {
        std::cout << "Trying to access arr[10]: ";
        std::cout << arr[10] << std::endl;
    } catch (const std::out_of_range& e) {
        std::cout << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

## 递增和递减操作符重载

```cpp
#include <iostream>

class Counter {
private:
    int count;
public:
    Counter(int c = 0) : count(c) {}
    
    // 前缀递增
    Counter& operator++() {
        ++count;
        return *this;
    }
    
    // 后缀递增
    Counter operator++(int) {
        Counter temp = *this;
        ++count;
        return temp;
    }
    
    // 前缀递减
    Counter& operator--() {
        --count;
        return *this;
    }
    
    // 后缀递减
    Counter operator--(int) {
        Counter temp = *this;
        --count;
        return temp;
    }
    
    friend std::ostream& operator<<(std::ostream& os, const Counter& c);
};

std::ostream& operator<<(std::ostream& os, const Counter& c) {
    os << c.count;
    return os;
}

int main() {
    Counter c(5);
    
    std::cout << "Initial: " << c << std::endl;
    
    std::cout << "Prefix ++: " << ++c << std::endl;
    std::cout << "After prefix: " << c << std::endl;
    
    std::cout << "Postfix ++: " << c++ << std::endl;
    std::cout << "After postfix: " << c << std::endl;
    
    std::cout << "Prefix --: " << --c << std::endl;
    std::cout << "After prefix: " << c << std::endl;
    
    std::cout << "Postfix --: " << c-- << std::endl;
    std::cout << "After postfix: " << c << std::endl;
    
    return 0;
}
```

# 默认参数

在 C++ 中，默认参数是**静态绑定**（也称为早期绑定）的，这意味着默认参数的值在编译时就已经确定，而不是在运行时确定。

1. **编译时确定**：默认参数的值在编译阶段根据函数声明中的默认值确定
2. **不受多态影响**：即使通过基类指针调用虚函数，使用的也是基类中声明的默认参数值
3. **基于静态类型**：默认参数的值取决于调用表达式中的静态类型，而不是对象的实际动态类型

当编译器遇到带有默认参数的函数调用时，它会：

1. 检查调用中提供的参数数量
2. 如果参数数量少于函数声明的参数数量，编译器会自动插入默认值
3. 这个过程在编译时完成，生成的代码就像显式传递了所有参数一样

## 默认参数与函数重载的交互

默认参数和函数重载可以相互作用，但需要小心处理以避免二义性：

```cpp
#include <iostream>
using namespace std;

// 重载函数1
void process(int value) {
    cout << "处理整数: " << value << endl;
}

// 重载函数2（带默认参数）
void process(int value, int factor = 1) {
    cout << "处理整数和因子: " << value * factor << endl;
}

int main() {
    process(5);      // 错误：二义性调用 - 两个函数都匹配
    process(5, 2);   // 正确：调用第二个函数
    
    return 0;
}
```

## 虚函数中使用默认值
> [面试官问：虚函数可以有默认参数吗？C++老手也踩坑](https://mp.weixin.qq.com/s/uqt__9gq9cxli59vWI2GZg) 

语法允许，但可能得到错误的结果，如：
```cpp
// 函数声明
void print(int a, int b = 20, int c = 30);

// 函数调用
print(10); // 编译器处理为 print(10, 20, 30)
```

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show(int x = 10) {
        cout << "Base::show(" << x << ")" << endl;
    }
};

class Derived : public Base {
public:
    void show(int x = 20) override {
        cout << "Derived::show(" << x << ")" << endl;
    }
};

int main() {
    Derived derived;
    Base* basePtr = &derived;
    
    // 静态绑定：默认参数基于指针的静态类型(Base)
    basePtr->show(); // 输出: Derived::show(10)
    
    // 动态绑定：直接调用使用实际类型的默认参数
    derived.show();  // 输出: Derived::show(20)
    
    return 0;
}
```

# 函数重载
> [Function Overloading](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170) 

函数重载（Function Overloading）是 C++ 中的一项重要特性，它允许在同一作用域内定义多个同名函数，但这些函数的**参数列表必须不同**（参数的类型、数量或顺序不同）。

## 可以重载的情况

1. **参数类型不同**
2. **参数数量不同**
3. **参数顺序不同**
4. **const 修饰符（用于指针、引用和成员函数）**

## 不能重载的情况

1. **仅返回类型不同**
2. **仅参数名称不同**
3. **顶层 const 修饰符（用于值参数）**

## 值参数中的 const（不能重载）

```cpp
// 不能重载 - 顶层 const 不影响函数签名
void func(int a) { /* ... */ }
void func(const int a) { /* ... */ } // 错误：重复定义
```

## 指针和引用参数中的 const（可以重载）

```cpp
#include <iostream>
using namespace std;

// 指针参数的 const 重载
void process(int* ptr) {
    cout << "非常量指针" << endl;
}

void process(const int* ptr) {
    cout << "常量指针" << endl;
}

// 引用参数的 const 重载
void modify(int& ref) {
    cout << "非常量引用" << endl;
}

void modify(const int& ref) {
    cout << "常量引用" << endl;
}

int main() {
    int x = 5;
    const int y = 10;
    
    process(&x);    // 调用 process(int*)
    process(&y);    // 调用 process(const int*)
    
    modify(x);      // 调用 modify(int&)
    modify(y);      // 调用 modify(const int&)
    
    return 0;
}
```

## 成员函数的 const 重载

```cpp
#include <iostream>
using namespace std;

class MyClass {
public:
    // 非常量成员函数
    void display() {
        cout << "非常量成员函数" << endl;
    }
    
    // 常量成员函数
    void display() const {
        cout << "常量成员函数" << endl;
    }
};

int main() {
    MyClass obj1;
    const MyClass obj2;
    
    obj1.display();  // 调用非常量版本
    obj2.display();  // 调用常量版本
    
    return 0;
}
```

## 值传递与引用传递的冲突（可能导致二义性）

```cpp
#include <iostream>
using namespace std;

void process(int value) {
    cout << "按值传递" << endl;
}

void process(int& reference) {
    cout << "按引用传递" << endl;
}

int main() {
    int x = 5;
    process(x); // 错误：二义性调用
    
    // 解决方案：使用强制转换明确意图
    process(static_cast<int>(x)); // 调用按值版本
    return 0;
}
```

## 左值引用与右值引用的重载

```cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

// 处理左值引用
void process(int& lref) {
    cout << "处理左值引用: " << lref << endl;
}

// 处理右值引用
void process(int&& rref) {
    cout << "处理右值引用: " << rref << endl;
}

// 处理常量左值引用（可以接受左值和右值）
void process(const int& clref) {
    cout << "处理常量左值引用: " << clref << endl;
}

int main() {
    int x = 5;
    const int y = 10;
    
    process(x);        // 调用 process(int&) - 左值
    process(10);       // 调用 process(int&&) - 右值
    process(y);        // 调用 process(const int&) - 常量左值
    process(x + 1);    // 调用 process(int&&) - 表达式结果是右值
    process(move(x));  // 调用 process(int&&) - 使用move转为右值
    
    return 0;
}
```

### 重载解析规则

当同时存在左值引用和右值引用的重载时，C++ 编译器按照以下规则进行重载解析：

1. **左值**优先匹配左值引用版本
2. **右值**优先匹配右值引用版本
3. **常量左值**匹配常量左值引用版本
4. 如果没有精确匹配，会考虑其他可行的重载

## 函数重载解析规则

当调用重载函数时，编译器按照以下优先级选择最合适的函数：

1. **精确匹配**
2. **提升转换**（如 char → int, float → double）
3. **标准转换**（如 int → double, 派生类 → 基类）
4. **用户定义的转换**（如转换构造函数或转换运算符）
5. **可变参数匹配**（如省略号 ...）

## 重载与默认参数

函数重载和默认参数可以结合使用，但需要注意避免二义性：

```cpp
#include <iostream>
using namespace std;

void print(int a) {
    cout << "一个参数: " << a << endl;
}

void print(int a, int b = 10) {
    cout << "两个参数: " << a << ", " << b << endl;
}

int main() {
    print(5);       // 错误：二义性调用
    print(5, 15);   // 正确：调用两个参数的版本
    
    return 0;
}
```

## 模板函数重载

模板函数也可以参与重载：
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 基本模板 - 处理任意类型
template<typename T>
void process(T value) {
    cout << "通用模板: " << value << endl;
}

// 重载1 - 处理指针类型
template<typename T>
void process(T* ptr) {
    cout << "指针模板: " << *ptr << endl;
}

// 重载2 - 处理特定容器
template<typename T>
void process(const vector<T>& vec) {
    cout << "向量模板: 大小=" << vec.size() << ", 内容=[";
    for (const auto& item : vec) {
        cout << item << " ";
    }
    cout << "]" << endl;
}

// 重载3 - 处理整数类型（非模板函数也可以参与重载）
void process(int value) {
    cout << "整数函数: " << value << endl;
}

int main() {
    int x = 42;
    process(x);           // 调用整数函数（非模板，最匹配）
    
    double d = 3.14;
    process(d);           // 调用通用模板
    
    process(&x);          // 调用指针模板
    
    vector<int> nums = {1, 2, 3};
    process(nums);        // 调用向量模板
    
    vector<string> words = {"hello", "world"};
    process(words);       // 调用向量模板
    
    return 0;
}
```

## 总结

| 情况               | 是否可以重载 | 示例                                           |
| ------------------ | ------------ | ---------------------------------------------- |
| 参数类型不同       | ✅ 可以       | `void f(int)` 和 `void f(double)`              |
| 参数数量不同       | ✅ 可以       | `void f()` 和 `void f(int)`                    |
| 参数顺序不同       | ✅ 可以       | `void f(int, double)` 和 `void f(double, int)` |
| 指针/引用的 const  | ✅ 可以       | `void f(int*)` 和 `void f(const int*)`         |
| 成员函数的 const   | ✅ 可以       | `void f()` 和 `void f() const`                 |
| 仅返回类型不同     | ❌ 不能       | `int f()` 和 `double f()`                      |
| 仅参数名不同       | ❌ 不能       | `void f(int a)` 和 `void f(int b)`             |
| 值参数的 const     | ❌ 不能       | `void f(int)` 和 `void f(const int)`           |
| 值传递 vs 引用传递 | ⚠️ 可能二义性 | `void f(int)` 和 `void f(int&)`                |