C++ 学习笔记

# 语法糖 Syntactic Sugar

在编程语言中，那些为了**让代码更易读、更简洁、更优雅**而引入的语法特性。这些特性**不会引入新的功能**，只是为现有的、可能更复杂的操作提供一种更“甜”的写法。

## 范围 `for` 循环

*   **“有糖”的写法（简洁明了）**：
    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (int value : vec) { // 直接遍历容器中的每个元素
        std::cout << value << " ";
    }
    ```

*   **“无糖”的底层写法（繁琐易错）**：
    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        int value = *it; // 需要手动解引用迭代器
        std::cout << value << " ";
    }
    ```
    **糖在哪**：编译器会自动帮处理迭代器（`begin()`, `end()`）、解引用（`*`）等底层细节，只需关心元素本身。

## `auto` 关键字

*   **“有糖”的写法**：
    ```cpp
    auto i = 42;        // i 被推导为 int
    auto s = "hello";   // s 被推导为 const char*
    std::vector<std::map<std::string, int>> complex_list;
    for (auto it = complex_list.begin(); it != complex_list.end(); ++it) {
        // 不用写一长串的 std::vector<std::map<std::string, int>>::iterator
    }
    ```

*   **“无糖”的写法**：
    ```cpp
    int i = 42;
    const char* s = "hello";
    std::vector<std::map<std::string, int>> complex_list;
    for (std::vector<std::map<std::string, int>>::iterator it = complex_list.begin(); it != complex_list.end(); ++it) {
    }
    ```
    **糖在哪**：避免了书写冗长、复杂的类型名，让代码更清晰，特别是对于模板类型和迭代器。

## Lambda 表达式

Lambda 是定义匿名函数对象的语法糖。

*   **“有糖”的写法**：
    ```cpp
    std::sort(vec.begin(), vec.end(), 
              [](int a, int b) { return a > b; }); // 就地定义一个排序规则
    ```

*   **“无糖”的写法（需要定义一个单独的函数对象）**：
    ```cpp
    struct Compare {
        bool operator()(int a, int b) const {
            return a > b;
        }
    };
    std::sort(vec.begin(), vec.end(), Compare());
    ```
    **糖在哪**：无需在代码的其他地方专门定义一个类或函数，可以直接在需要的地方内联定义行为，非常灵活。

## 结构化绑定

这是 C++17 引入的强大语法糖，用于解包元组、结构体等。

*   **“有糖”的写法**：
    ```cpp
    std::pair<int, std::string> get_data() { return {42, "hello"}; }
    
    auto [id, name] = get_data(); // 直接解包到两个变量中
    std::cout << id << ": " << name << std::endl;
    ```

*   **“无糖”的写法**：
    ```cpp
    std::pair<int, std::string> get_data() { return {42, "hello"}; }
    
    auto data = get_data();
    int id = data.first;
    std::string name = data.second;
    std::cout << id << ": " << name << std::endl;
    ```
    **糖在哪**：无需通过 `.first`、`.second` 或 `std::get<0>(data)` 来访问成员，可以直接用有意义的变量名，代码意图更明确。

## 其他常见语法糖

*   **初始化列表**：`std::vector<int> v = {1, 2, 3, 4, 5};` （糖） vs. 多次调用 `push_back` （无糖）。
*   **空指针**：`nullptr` （糖，类型安全） vs. `NULL` 或 `0` （无糖，容易出错）。
*   **三向比较运算符** `<=>` （C++20）：简化自定义类型的比较操作定义。
*   **类模板参数推导**：`std::pair p(1, 2.0);` （糖） vs. `std::pair<int, double> p(1, 2.0);` （无糖）。

# nullptr

`nullptr` 是真正的指针类型，而 `NULL` 只是一个整型字面量 `0` 的别名。这个根本区别导致了巨大的安全性差异。

`nullptr` 是 C++11 引入的关键字，它具有自己的类型 `std::nullptr_t`。这个类型非常神奇，它可以**隐式转换到任何原始指针类型**，但**不能转换到整型**（除 `bool` 外）。

## `NULL` 和 `0` 问题

在 C++ 中，`NULL` 通常是在标准库中通过 `#define` 定义的一个宏：

```cpp
#define NULL 0
// 或者在某些编译器中也可能是
#define NULL ((void*)0) // 这种形式在C++中并不常用
```

所以，**`NULL` 本质上就是一个整型数字 `0`**。

这就导致了以下问题：

### 问题一：函数重载歧义（最经典的安全问题）

考虑以下代码：

```cpp
#include <iostream>

void func(int i) {
    std::cout << "Called func(int)" << std::endl;
}

void func(char* s) {
    std::cout << "Called func(char*)" << std::endl;
}

int main() {
    func(NULL); // 该调用哪个重载？
    return 0;
}
```

希望调用 `func(char*)` 因为它接受一个指针。但编译器看到的是 `func(0)`，`0` 是一个不折不扣的 `int`。因此，它会毫不犹豫地调用 `func(int)` 版本。

这违背了程序员传递一个“空指针”的初衷，可能导致意料之外的行为，甚至是运行时错误。

### 问题二：模板推导问题

在模板编程中，类型推导非常严格。由于 `NULL` 是整型，在模板中会丢失其“指针”的语义。

```cpp
template<typename T>
void func(T t) {
    // ... 一些操作
}

template<typename T>
void func_with_ptr(T* t) {
    // ... 一些针对指针的操作
}

int main() {
    func(NULL);   // T 被推导为 int，而不是指针类型！
    func_with_ptr(NULL); // 编译错误！不能将 int 转换为 T*
    return 0;
}
```

### 问题三：代码清晰度

使用 `0` 或 `NULL` 来表示空指针，在代码可读性上是一种妥协。看到 `0`，它可能是一个数字，也可能是一个指针，需要根据上下文去推断。

## 解决函数重载歧义

```cpp
void func(int i) {
    std::cout << "Called func(int)" << std::endl;
}

void func(char* s) {
    std::cout << "Called func(char*)" << std::endl;
}

int main() {
    func(nullptr); // 明确无误地调用了 func(char*) 版本！
    return 0;
}
```
输出：
```
Called func(char*)
```

因为 `nullptr` 的类型是 `std::nullptr_t`，它无法匹配 `func(int)`，但可以完美地隐式转换为 `char*`，所以编译器能准确找到正确的重载。

## 解决模板推导问题

```cpp
template<typename T>
void func(T t) {}

template<typename T>
void func_with_ptr(T* t) {}

int main() {
    func(nullptr);          // T 被推导为 std::nullptr_t
    func_with_ptr(nullptr); // T* 与 std::nullptr_t 匹配，T 被推导为所需的类型

    // 也可以直接用于赋值和比较，类型安全
    int*  ptr_int = nullptr;
    char* ptr_char = nullptr;
    if (ptr_int == nullptr) { ... } // 正确

    // int i = nullptr; // 错误！不能将 nullptr 转换为 int
    return 0;
}
```

## 提升代码清晰度

使用 `nullptr` 语义非常明确：“我是一个空指针”。这让代码的意图一目了然。

```cpp
int* my_ptr = nullptr; // 清晰：my_ptr 是一个尚未指向有效内存的指针
if (my_ptr != nullptr) { // 清晰：检查指针是否有效
    // ... do something
}
```

# 悬垂引用（Dangling Reference）

悬垂引用是 C++ 中一个常见且危险的编程错误，理解它的成因和避免方法对于编写安全的 C++ 代码至关重要。

**悬垂引用**指的是一个引用绑定到了一个已经不再存在的对象上。当程序试图通过这样的引用访问内存时，会导致未定义行为（Undefined Behavior），通常表现为程序崩溃、数据损坏或难以预测的结果。

## 1. 返回局部变量的引用

```cpp
int& createInt() {
    int value = 10;       // 局部变量，函数结束时被销毁
    return value;         // 错误：返回局部变量的引用
}

int main() {
    int& myRef = createInt(); // myRef 现在是悬垂引用
    std::cout << myRef;       // 未定义行为：可能崩溃或输出垃圾值
    return 0;
}
```

## 2. 引用临时对象

```cpp
#include <iostream>

int main() {
    // int& ref = 5;        // ❌ 这行代码根本编译不过！
    // 非常量引用不能绑定到一个临时对象（右值）

    // 但如果我们“欺骗”一下编译器呢？
    const int& const_ref = 5; // 先创建一个合法的const引用
    int& ref = const_cast<int&>(const_ref); // ❌ 再强行去掉const

    std::cout << ref; // ❌ 极度危险的未定义行为！
    return 0;
}
```
通过 `const_cast` 去掉了 `const` 属性，我们打破了生命周期延长规则的约定。此时，临时对象 `5` 可能已经被销毁，`ref` 成了一个不折不扣的**悬垂引用**。

在 C++ 中，有一条明确的**生命周期延长规则（Lifetime Extension Rule）**：

**当将一个临时对象绑定到一个 `const` 引用或右值引用（`&&`）上时，该临时对象的生命周期将被延长，以匹配该引用的生命周期。**

`const int& ref = 5;` 这条语句触发了 C++ 的生命周期延长规则。编译器会确保临时对象 `5` 存活到 `ref` 离开其作用域。

## 3. 引用已被释放的动态内存

```cpp
int main() {
    int* ptr = new int(20);
    int& ref = *ptr;     // ref引用动态分配的内存
    delete ptr;          // 内存被释放
    // ref现在是悬垂引用
    std::cout << ref;    // 未定义行为
    return 0;
}
```

## 4. 引用被移动后的对象

C++11引入移动语义后，可能出现新的悬垂引用情况：

```cpp
std::string createString() {
    return "Hello";
}

int main() {
    std::string&& rvalueRef = createString(); // 绑定到临时对象
    // 临时字符串在这里被销毁，rvalueRef成为悬垂引用
    std::cout << rvalueRef; // 未定义行为
    return 0;
}
```

## 5. 引用超出作用域的对象

```cpp
int main() {
    int* outerRef = nullptr;
    {
        int value = 30;      // 块作用域变量
        outerRef = &value;   // 获取它的地址/引用
    } // value在这里被销毁
    // outerRef现在是悬垂指针/引用
    std::cout << *outerRef;  // 未定义行为
    return 0;
}
```

## 悬垂引用 vs 悬垂指针

悬垂引用和悬垂指针本质上是相同的问题，但引用因为必须初始化且不能重新绑定，所以一旦成为悬垂引用，就无法"修复"，而指针可以被重新赋值：

```cpp
int main() {
    int* ptr = nullptr; // 可以后续赋值
    int& ref;           // 错误：引用必须初始化
    
    int value = 10;
    ref = value;        // 正确：但ref仍然引用原来的对象（如果有的话）
    
    return 0;
}
```

# 状态机

状态机（State Machine）是计算机科学中一个非常重要的概念，它描述了一个对象在其生命周期内可能处于的各种状态，以及如何在这些状态之间转换。在 C++ 中，状态机广泛应用于游戏开发、网络协议、用户界面管理和解析器等场景。

状态机是一种行为模型，由以下部分组成：
1. **状态（States）**：系统可能处于的各种状况
2. **转移（Transitions）**：从一个状态切换到另一个状态的条件和动作
3. **事件（Events）**：触发状态转移的输入或条件
4. **动作（Actions）**：在状态转移时执行的操作

## 状态机的基本类型

### 1. 有限状态机（Finite State Machine, FSM）
- 有有限数量的状态
- 在任何给定时间只能处于一个状态
- 根据输入事件改变状态

### 2. 分层状态机（Hierarchical State Machine）
- 状态可以包含子状态
- 允许状态继承和复用

### 3. 下推自动机（Pushdown Automaton）
- 带有栈的状态机
- 可以记忆先前状态的历史

## switch-case 实现（最简单）

```cpp
#include <iostream>
#include <string>

enum class TrafficLightState {
    RED,
    YELLOW,
    GREEN
};

class TrafficLight {
private:
    TrafficLightState currentState;
    
public:
    TrafficLight() : currentState(TrafficLightState::RED) {}
    
    void changeState() {
        switch(currentState) {
            case TrafficLightState::RED:
                std::cout << "红灯 -> 绿灯" << std::endl;
                currentState = TrafficLightState::GREEN;
                break;
            case TrafficLightState::YELLOW:
                std::cout << "黄灯 -> 红灯" << std::endl;
                currentState = TrafficLightState::RED;
                break;
            case TrafficLightState::GREEN:
                std::cout << "绿灯 -> 黄灯" << std::endl;
                currentState = TrafficLightState::YELLOW;
                break;
        }
    }
    
    void display() {
        switch(currentState) {
            case TrafficLightState::RED:
                std::cout << "当前状态: 红灯" << std::endl;
                break;
            case TrafficLightState::YELLOW:
                std::cout << "当前状态: 黄灯" << std::endl;
                break;
            case TrafficLightState::GREEN:
                std::cout << "当前状态: 绿灯" << std::endl;
                break;
        }
    }
};

int main() {
    TrafficLight light;
    
    light.display();    // 当前状态: 红灯
    light.changeState(); // 红灯 -> 绿灯
    light.display();    // 当前状态: 绿灯
    light.changeState(); // 绿灯 -> 黄灯
    light.display();    // 当前状态: 黄灯
    
    return 0;
}
```

**优点**：简单直观，易于实现
**缺点**：状态和转移逻辑耦合，难以扩展

## 状态模式（State Pattern）

```cpp
#include <iostream>
#include <memory>

// 前向声明
class Context;

// 状态接口
class State {
public:
    virtual void handle(Context* context) = 0;
    virtual std::string toString() = 0;
    virtual ~State() = default;
};

// 上下文类
class Context {
private:
    std::unique_ptr<State> currentState;
    
public:
    Context(std::unique_ptr<State> state) : currentState(std::move(state)) {}
    
    void setState(std::unique_ptr<State> newState) {
        currentState = std::move(newState);
    }
    
    void request() {
        currentState->handle(this);
    }
    
    void display() {
        std::cout << "当前状态: " << currentState->toString() << std::endl;
    }
};

// 具体状态类
class RedState : public State {
public:
    void handle(Context* context) override;
    std::string toString() override { return "红灯"; }
};

class YellowState : public State {
public:
    void handle(Context* context) override;
    std::string toString() override { return "黄灯"; }
};

class GreenState : public State {
public:
    void handle(Context* context) override;
    std::string toString() override { return "绿灯"; }
};

// 状态转移实现
void RedState::handle(Context* context) {
    std::cout << "红灯 -> 绿灯" << std::endl;
    context->setState(std::make_unique<GreenState>());
}

void YellowState::handle(Context* context) {
    std::cout << "黄灯 -> 红灯" << std::endl;
    context->setState(std::make_unique<RedState>());
}

void GreenState::handle(Context* context) {
    std::cout << "绿灯 -> 黄灯" << std::endl;
    context->setState(std::make_unique<YellowState>());
}

int main() {
    Context context(std::make_unique<RedState>());
    
    context.display(); // 当前状态: 红灯
    context.request(); // 红灯 -> 绿灯
    context.display(); // 当前状态: 绿灯
    context.request(); // 绿灯 -> 黄灯
    context.display(); // 当前状态: 黄灯
    
    return 0;
}
```

**优点**：符合开闭原则，易于扩展新状态
**缺点**：类数量增加，实现稍复杂

## 基于函数指针/std::function 的状态机

```cpp
#include <iostream>
#include <functional>
#include <map>
#include <string>

class StateMachine {
private:
    // 状态处理函数类型
    using StateHandler = std::function<void(StateMachine*)>;
    
    // 状态定义
    enum class State {
        RED,
        YELLOW,
        GREEN
    };
    
    State currentState;
    std::map<State, StateHandler> handlers;
    std::map<State, std::string> stateNames;
    
public:
    StateMachine() : currentState(State::RED) {
        // 注册状态处理函数
        handlers[State::RED] = [](StateMachine* sm) {
            std::cout << "红灯 -> 绿灯" << std::endl;
            sm->currentState = State::GREEN;
        };
        
        handlers[State::YELLOW] = [](StateMachine* sm) {
            std::cout << "黄灯 -> 红灯" << std::endl;
            sm->currentState = State::RED;
        };
        
        handlers[State::GREEN] = [](StateMachine* sm) {
            std::cout << "绿灯 -> 黄灯" << std::endl;
            sm->currentState = State::YELLOW;
        };
        
        // 状态名称映射
        stateNames[State::RED] = "红灯";
        stateNames[State::YELLOW] = "黄灯";
        stateNames[State::GREEN] = "绿灯";
    }
    
    void transition() {
        handlers[currentState](this);
    }
    
    void display() {
        std::cout << "当前状态: " << stateNames[currentState] << std::endl;
    }
};

int main() {
    StateMachine sm;
    
    sm.display(); // 当前状态: 红灯
    sm.transition(); // 红灯 -> 绿灯
    sm.display(); // 当前状态: 绿灯
    sm.transition(); // 绿灯 -> 黄灯
    sm.display(); // 当前状态: 黄灯
    
    return 0;
}
```

**优点**：灵活，可以使用lambda表达式
**缺点**：状态转移逻辑分散，不易维护

## 基于表格的状态机（最灵活）

```cpp
#include <iostream>
#include <map>
#include <functional>
#include <string>

class TableDrivenStateMachine {
private:
    // 状态定义
    enum class State { RED, YELLOW, GREEN };
    
    // 事件定义
    enum class Event { TIMER_EXPIRED };
    
    // 转移条目
    struct Transition {
        State nextState;
        std::function<void()> action;
    };
    
    State currentState;
    std::map<std::pair<State, Event>, Transition> transitionTable;
    std::map<State, std::string> stateNames;
    
public:
    TableDrivenStateMachine() : currentState(State::RED) {
        // 初始化状态名称
        stateNames = {
            {State::RED, "红灯"},
            {State::YELLOW, "黄灯"},
            {State::GREEN, "绿灯"}
        };
        
        // 构建转移表
        transitionTable = {
            // 当前状态 + 事件 -> 转移
            {{State::RED, Event::TIMER_EXPIRED}, 
             {State::GREEN, []() { std::cout << "红灯 -> 绿灯" << std::endl; }}},
             
            {{State::YELLOW, Event::TIMER_EXPIRED}, 
             {State::RED, []() { std::cout << "黄灯 -> 红灯" << std::endl; }}},
             
            {{State::GREEN, Event::TIMER_EXPIRED}, 
             {State::YELLOW, []() { std::cout << "绿灯 -> 黄灯" << std::endl; }}}
        };
    }
    
    void handleEvent(Event event) {
        auto key = std::make_pair(currentState, event);
        auto it = transitionTable.find(key);
        
        if (it != transitionTable.end()) {
            // 执行动作并转移状态
            it->second.action();
            currentState = it->second.nextState;
        } else {
            std::cout << "无定义的状态转移: " 
                      << stateNames[currentState] << " + 事件" 
                      << static_cast<int>(event) << std::endl;
        }
    }
    
    void display() {
        std::cout << "当前状态: " << stateNames[currentState] << std::endl;
    }
};

int main() {
    TableDrivenStateMachine sm;
    
    sm.display(); // 当前状态: 红灯
    sm.handleEvent(TableDrivenStateMachine::Event::TIMER_EXPIRED); // 红灯 -> 绿灯
    sm.display(); // 当前状态: 绿灯
    sm.handleEvent(TableDrivenStateMachine::Event::TIMER_EXPIRED); // 绿灯 -> 黄灯
    sm.display(); // 当前状态: 黄灯
    
    return 0;
}
```

**优点**：非常灵活，转移逻辑集中管理，易于修改和扩展
**缺点**：实现相对复杂，需要额外数据结构

## 状态机的应用场景

1. **游戏开发**：角色AI、游戏流程管理
2. **网络协议**：TCP状态机、HTTP请求处理
3. **用户界面**：按钮状态、页面导航
4. **编译器**：词法分析、语法分析
5. **嵌入式系统**：设备控制流程

# 内存对齐

内存对齐是指数据在内存中的存储地址必须是某个值（通常是 2、4、8、16 等 2 的幂）的倍数。现代 CPU 并不是以字节为单位访问内存，而是以固定大小的块（通常是 4 或 8 字节）为单位进行访问。

1. **性能优化**：对齐的数据可以让 CPU 更高效地访问。未对齐的数据可能需要多次内存访问才能读取完整。
2. **硬件要求**：某些架构（如 ARM、RISC-V）要求特定类型的数据必须对齐，否则会导致硬件异常。
3. **原子操作**：许多处理器要求原子操作的对象必须对齐。
4. **SIMD 指令**：SIMD（单指令多数据）指令通常要求数据对齐到特定边界。

在 C++ 中，基本数据类型有自然的对齐要求，这通常与它们的大小相关：

| 数据类型      | 典型大小         | 典型对齐要求     |
| ------------- | ---------------- | ---------------- |
| `char`        | 1 字节           | 1 字节           |
| `short`       | 2 字节           | 2 字节           |
| `int`         | 4 字节           | 4 字节           |
| `long`        | 4 或 8 字节      | 4 或 8 字节      |
| `float`       | 4 字节           | 4 字节           |
| `double`      | 8 字节           | 8 字节           |
| `long double` | 8、12 或 16 字节 | 8、12 或 16 字节 |
| 指针          | 4 或 8 字节      | 4 或 8 字节      |

## 示例 ：嵌套结构体的对齐

```cpp
#include <iostream>

struct Inner {
    char a;     // 1 字节
    // 3 字节填充
    int b;      // 4 字节
}; // 总大小 8 字节

struct Outer {
    short a;    // 2 字节
    // 2 字节填充（使 Inner 对齐到 4 字节边界）
    Inner b;    // 8 字节
    char c;     // 1 字节
    // 3 字节填充（使总大小为 8 的倍数）
};

int main() {
    std::cout << "Size of Inner: " << sizeof(Inner) << std::endl;
    std::cout << "Size of Outer: " << sizeof(Outer) << std::endl;
    
    std::cout << "Offsets in Outer:" << std::endl;
    std::cout << "a: " << offsetof(Outer, a) << std::endl;
    std::cout << "b: " << offsetof(Outer, b) << std::endl;
    std::cout << "c: " << offsetof(Outer, c) << std::endl;
    
    return 0;
}
```

可能的输出：
```
Size of Inner: 8
Size of Outer: 16
Offsets in Outer:
a: 0
b: 4
c: 12
```

## 控制内存对齐

C++11 引入了 `alignas` 说明符和 `alignof` 运算符来控制和对齐查询。

### `alignof` 运算符

`alignof` 返回类型的对齐要求：

```cpp
#include <iostream>

int main() {
    std::cout << "alignof(char): " << alignof(char) << std::endl;
    std::cout << "alignof(int): " << alignof(int) << std::endl;
    std::cout << "alignof(double): " << alignof(double) << std::endl;
    
    struct MyStruct {
        char a;
        int b;
    };
    
    std::cout << "alignof(MyStruct): " << alignof(MyStruct) << std::endl;
    
    return 0;
}
```

### `alignas` 说明符

`alignas` 可以用于变量或类型声明，指定自定义对齐要求：

```cpp
#include <iostream>

// 指定结构体对齐到 16 字节边界
struct alignas(16) AlignedStruct {
    char a;      // 1 字节
    // 15 字节填充（使结构体大小为 16 的倍数）
}; // 总大小 16 字节

// 指定变量对齐到 32 字节边界
alignas(32) int aligned_int;

int main() {
    std::cout << "Size of AlignedStruct: " << sizeof(AlignedStruct) << std::endl;
    std::cout << "Align of AlignedStruct: " << alignof(AlignedStruct) << std::endl;
    
    std::cout << "Address of aligned_int: " << &aligned_int << std::endl;
    std::cout << "Is address aligned to 32 bytes? " 
              << (reinterpret_cast<uintptr_t>(&aligned_int) % 32 == 0) << std::endl;
    
    return 0;
}
```

## 内存对齐的注意事项

1. **跨平台兼容性**：不同平台可能有不同的默认对齐规则，需要注意可移植性。
2. **网络通信**：在网络传输中，通常需要使用打包的结构体以避免不同平台间的对齐差异。
3. **文件 I/O**：直接读写结构体到文件时，需要注意对齐和填充问题。
4. **性能权衡**：过度对齐会浪费内存，需要根据实际需求平衡内存使用和性能。