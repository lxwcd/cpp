C++ 内存管理


# 资源
> [虚拟内存](https://xiaolincoding.com/os/3_memory/vmem.html#虚拟内存)

# 每个进程的页表在物理内存中

每个进程的整个页表是一个非常庞大的数据结构，它存储在**物理内存 (RAM)** 中。操作系统负责在物理内存中为每个进程分配和维护其页表。

# MMU：翻译员和缓存员

MMU（内存管理单元）是 CPU 芯片上的一个硬件部件。可以把它想象成一个非常专业、速度极快的**翻译员**。这个翻译员自己并不携带整本字典（即整个页表），但它有：
*   **一个指向字典的书签**：一个叫做 **页表基址寄存器 (Page Table Base Register, PTBR)** 或 **CR3 (在 x86 体系结构中)** 的特殊寄存器。这个寄存器保存了**当前正在运行的进程的页表在物理内存中的起始地址**。
    当操作系统进行进程切换时，它所做的关键工作之一就是将 PTBR/CR3 的值更新为新进程的页表物理地址。
*   **一个高频词汇速查表**：**转址旁路缓存 (TLB)**。TLB 是 MMU 内部的一个小型、极快的缓存，它保存了最近使用过的**虚拟页号 (VPN)** 到**物理页帧号 (PFN)** 的映射关系。


**在任何一个给定的时刻，MMU 和 TLB 中存储的映射信息，只属于当前正在 CPU 上运行的那个进程（即当前活跃进程）。**

*   **角色**：MMU 是一个硬件单元，它的工作是执行翻译流程，但它本身**不“存储”所有页表**。
*   **工作依赖**：MMU 的翻译行为完全依赖于 **CR3 寄存器**的当前值。CR3 指向哪个进程的页表，MMU 就去查询哪个页表。
*   因此，和 TLB 一样，MMU 在**瞬间**的视角里，只“知道”当前一个进程的映射规则。它的工作是机械的：**“根据当前的 CR3 去翻译当前的虚拟地址”**。

# TLB (Translation Lookaside Buffer) 

**TLB（转址旁路缓存）是集成在MMU（内存管理单元）内部的**。它是MMU的一个关键组成部分，而不是一个独立的、位于CPU和MMU之外的组件。

1. 结构关系：TLB是MMU的“高速缓存部门”

*   **MMU**：是一个功能完整的硬件单元，它的核心职责是**完成虚拟地址到物理地址的转换**。为了实现这个功能，它内部包含了多种子组件，TLB就是其中最重要的一個。
*   **TLB**：是MMU内部的一个专用的、极快的**缓存（Cache）**。它的唯一工作就是缓存最近使用过的“虚拟页号”到“物理页帧号”的映射关系（即页表项PTE的内容）。

将它们想象成一个公司的组织架构：
*   **MMU** 是整个 **“地址翻译部门”**。
*   **TLB** 是这个部门里的 **“快速查询小组”**，这个小组拥有一本自己维护的高频词汇速查手册。
*   部门里还有其他“员工”负责当“快速查询小组”找不到时，去查总字典（即访问物理内存中的页表）。

当CPU需要将虚拟地址转换为物理地址时，流程如下，这清晰地表明了TLB是MMU工作的第一站：

1.  **CPU** 将**虚拟地址**发送给 **MMU**，要求进行翻译。
2.  **MMU** 收到请求后，第一步就是询问内部的**TLB**：“你缓存了这个虚拟页号的映射吗？”
3.  **TLB命中（TLB Hit）**：
    *   如果TLB中有这个映射，它立刻将**物理页帧号（PFN）** 返回给MMU。
    *   MMU将PFN和虚拟地址中的**页内偏移（Offset）** 组合成物理地址。任务完成，速度极快（通常1-2个时钟周期）。
4.  **TLB未命中（TLB Miss）**：
    *   如果TLB中没有这个映射，MMU就必须启动一个叫做**页表遍历（Page Walk）** 的过程。
    *   MMU根据**CR3寄存器**中存储的页表基址，去到**物理内存（RAM）** 中查找进程的页表，找到正确的页表项（PTE）。这个过程很慢，因为需要访问内存。
    *   MMU从PTE中获得PFN，并完成地址翻译。
    *   **关键一步**：MMU在返回物理地址之前，会**将这个新的VPN->PFN映射关系写入它内部的TLB中**。这样，下次再访问同一个虚拟页时，TLB就能命中了。

## 为什么TLB必须在MMU内部

1.  **速度要求**：地址翻译是CPU执行指令流水线中的一个关键步骤。每次内存访问（取指令、读数据、写数据）都需要翻译。为了不影响CPU主频，TLB的访问速度必须和CPU时钟周期相匹配。只有将其作为CPU芯片上的一个硬件组件，与MMU紧密集成，才能达到这种纳秒级的速度。
2.  **物理位置**：由于对速度的极致要求，TLB由**静态随机存取存储器（SRAM）** 制成，并直接物理集成在CPU芯片die上，与MMU和CPU核心紧挨在一起。访问片上的SRAM比访问板上的DRAM（物理内存）要快几个数量级。
3.  **协同工作**：TLB和MMU的页表遍历逻辑需要高度协同。TLB未命中会直接触发MMU的页表遍历硬件状态机。这种紧密的、硬件级别的交互只有在集成在一起时才能高效实现。

| 组件               | 角色           | 比喻                                                  |
| :----------------- | :------------- | :---------------------------------------------------- |
| **CPU核心**        | 工人           | 需要材料的工匠                                        |
| **虚拟地址**       | 材料名称       | “一个5号零件”                                         |
| **物理地址**       | 仓库货架位置   | “B区-3排-2架”                                         |
| **MMU**            | 仓库管理员     | 负责查货架位置的整体部门                              |
| **TLB**            | 管理员的速记本 | 记录最常用零件位置的便签本（**在管理员手边/脑子里**） |
| **页表（内存中）** | 总库存清单     | 记录所有零件位置的厚账本（在办公室的书架上）          |

**流程**：
工匠（CPU）喊：“给我一个5号零件！”（虚拟地址）。
管理员（MMU）**首先看自己手边的速记本（TLB）**。
*   如果速记本上有，立刻告诉工匠：“在B-3-2架！”（物理地址）。
*   如果速记本上没有，管理员就得跑去办公室翻阅厚厚的总账本（页表），找到位置后告诉工匠，同时**把这个记录抄到自己的速记本上**（更新TLB）。

所以，**TLB不仅是MMU的一部分，更是其提升性能最关键的核心部件**。它的存在使得在绝大多数情况下，地址翻译无需访问速度相对慢得多的物理内存。

## 当前进程的地址翻译缓存

*   **内容**：TLB 缓存的是**虚拟页号 (VPN) 到物理页帧号 (PFN) 的映射关系**。
*   **特性**：TLB 是非常高速但容量很小的硬件缓存。它的内容具有**局部性**，即它里面存放的只是当前进程**最近访问过**的少数页面的映射。
*   **问题**：如果两个不同的进程使用相同的虚拟地址（例如都访问 `0x400000`），它们应该映射到不同的物理地址。如果 TLB 混合存储所有进程的映射，就会发生严重的冲突和错误。

**解决方案：进程上下文切换时刷新 TLB**

当操作系统决定停止运行进程 A，转而运行进程 B 时（称为“上下文切换”），它必须执行一个关键操作：
1.  将 CPU 的 **CR3 寄存器** 的值从指向进程 A 的页表，改为指向进程 B 的页表。
2.  **使 TLB 中所有属于进程 A 的缓存条目失效**（称为 **TLB Flush** 或 **TLB Shootdown**）。

**为什么必须刷新？**
因为进程 B 的虚拟地址 `0x400000` 可能对应着与进程 A 完全不同的物理页。如果不刷新 TLB，TLB 中可能还残留着进程 A 的 `0x400000 -> PFN_X` 的旧映射。当进程 B 首次访问 `0x400000` 时，MMU 可能会错误地使用这个旧的、无效的映射，导致进程 B 访问到进程 A 的内存，造成数据泄露或崩溃。

**高级优化：ASID (Address Space ID)**
为了减少频繁刷新 TLB 带来的性能损失，现代 CPU 提供了一个功能：**地址空间标识符 (ASID)**。
*   每个进程被赋予一个唯一的 ASID。
*   TLB 中的每个条目不仅缓存 VPN->PFN，还会**打上当前进程的 ASID 标签**。
*   当 MMU 查找 TLB 时，它会同时检查 VPN 和当前 CR3 寄存器所对应的 ASID。
*   **好处**：这样，多个进程的映射可以共存于 TLB 中而不会相互干扰。切换进程时，操作系统只需要更改 CR3 寄存器和一个存储当前 ASID 的寄存器即可，**无需清空整个 TLB**。只有当 TLB 需要为新进程腾出空间时，旧的条目才会被逐渐替换掉。这大大提升了上下文切换的速度。

# 地址翻译的完整过程

当一个进程执行一条指令如 `mov eax, [0x12345678]`（访问虚拟地址 `0x12345678`）时：

1.  **MMU 接收虚拟地址**：CPU 将虚拟地址 `0x12345678` 交给 MMU 进行翻译。

2.  **检查 TLB（速查表）**：
    *   MMU 首先将虚拟地址中的页号部分（VPN）拿出来，在 TLB 中查找。
    *   **如果找到（TLB Hit）**：立刻获得物理页帧号 (PFN)，跳到第 5 步。这个过程极快，通常只需 1 个时钟周期。

3.  **TLB 未命中（TLB Miss）—— 需要查“字典”**：
    *   如果 TLB 中没有这个映射，MMU 就必须进行一次完整的页表遍历（Page Walk）。
    *   MMU 会**使用 PTBR/CR3 寄存器中的值作为基址**，加上虚拟页号 (VPN) 计算出的偏移量，**在物理内存中找到这个进程的页表项 (PTE)**。这个过程本身可能涉及多次内存访问（尤其是在多级页表结构中）。

4.  **处理页表项 (PTE)**：
    *   MMU 从物理内存中读取到 PTE。
    *   检查 PTE 的有效位：
        *   **如果有效（在内存中）**：MMU 从 PTE 中取出 PFN。同时，它**将这个 VPN->PFN 的映射关系缓存到 TLB 中**，以便下次快速访问。
        *   **如果无效（缺页）**：MMU 会触发一个**缺页异常 (Page Fault)**，CPU 切换到内核模式，让操作系统的缺页处理程序来解决问题（如从磁盘加载页），然后重试指令。

5.  **组成物理地址**：
    *   MMU 将得到的 PFN 和原始虚拟地址中的**页内偏移 (Offset)** 组合起来，形成最终的物理地址。

6.  **访问物理内存**：
    *   MMU 将这个物理地址发送到内存总线，从而从物理内存 RAM 中读取或写入数据。

# 页表的创建

在一个程序的主要部分被加载到物理内存之前，操作系统就已经为它创建并初始化好一个页表了。这个初始页表是进程能够开始运行的基础。

## 1. 进程的创建与页表的诞生

当在 shell 中输入 `./my_program` 或通过 `fork()` + `exec()` 系统调用启动一个新程序时，操作系统会执行以下步骤：

1.  **创建进程控制块（PCB）**：操作系统首先在内核中为这个新进程创建一个数据结构（在 Linux 中通常是 `task_struct`），用于管理进程的所有信息。
2.  **创建虚拟地址空间**：操作系统为新进程分配一个空的、独立的虚拟地址空间。
3.  **分配和初始化页表**：操作系统会**在物理内存中分配**并初始化这个新进程的页表结构。此时，这个页表几乎是“空的”。

## 2. 初始页表的内容：“空洞”的映射

这个新创建的页表并不是一片空白。它已经被精心设置，但其绝大部分页表项（PTE）的**有效位（Present Bit）都被设置为 0**。

这意味着什么？
*   它建立了虚拟地址到“ nowhere ”的映射。CPU 如果访问这些地址，会立即触发**缺页异常（Page Fault）**。
*   这是一种“占位符”。操作系统通过这种方式告诉 MMU：“这个虚拟地址空间是合法的，属于这个进程，但它的内容还没有准备好。”

然而，这个“空洞”的映射并非完全无信息。对于未来需要从磁盘文件（如 `my_program` 这个可执行文件）加载的页（如代码段 `.text`、已初始化数据段 `.data`），操作系统会在对应的 PTE 中预先记录下**这个虚拟页在磁盘上的位置**（例如，对应可执行文件中的偏移量），尽管此时有效位是 0。

## 3. 设置关键区域的映射

在进程开始执行**第一条指令之前**，操作系统必须确保一些关键区域是**真正可访问**的，即它们的 PTE 有效位必须为 1。这意味着操作系统需要预先分配物理页并建立映射。这些区域通常包括：

*   **程序的入口点（如 `_start`）**：CPU 必须能取到第一条指令，所以代码段的第一页通常会被立即加载。
*   **初始栈（Initial Stack）**：每个进程都需要一个栈来存储函数调用信息、局部变量等。操作系统会为栈顶分配物理页并建立映射。
*   **代码段（.text）和数据段（.data）的一部分**：出于效率考虑，操作系统可能会预加载最开头的几页代码和数据。

## 4. 开始执行与按需调页（Demand Paging）

现在，进程已经准备好了：
*   它的 PCB 已创建。
*   它的页表已建立，并且关键区域（如初始栈和入口代码页）已经映射到物理内存。
*   CPU 的 **CR3 寄存器**（页表基址寄存器）已经被设置为指向这个新进程的页表。

操作系统调度器选择该进程运行。CPU 从程序的入口点（一个虚拟地址）开始取指令。

*   **如果该页已在内存中**（有效位=1）：MMU 正常翻译，指令顺利执行。
*   **如果该页不在内存中**（有效位=0，这是绝大多数情况）：MMU 触发**缺页异常**。
    *   CPU 切换到内核模式。
    *   操作系统的缺页处理程序被调用。
    *   处理程序查看引发异常的虚拟地址，并在对应的 PTE 中找到之前记录好的“该页在磁盘上的位置”。
    *   操作系统分配一个空闲的物理页帧。
    *   操作系统将所需的内容（代码或数据）**从磁盘上的可执行文件读取**到刚分配的物理页帧中。
    *   操作系统**更新 PTE**：设置有效位为 1，并填入物理页帧号。
    *   操作系统返回到用户模式，并**重新执行**那条触发异常的指令。这次，指令就能成功执行了。

这个过程就是**按需调页（Demand Paging）**——只有真正需要访问一个页时，它才会被加载到物理内存中。这极大地提高了内存利用率和程序启动速度。

## 总结

| 阶段                        | 页表状态                                                                                                                           | 物理内存                                                                                                   |
| :-------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------- |
| **`exec()` 之后，执行之前** | **已创建并初始化**。大部分 PTE 标记为“无效”(Present=0)，但记录了磁盘位置。关键区域（栈、入口代码）的 PTE 标记为“有效”(Present=1)。 | 为**页表本身**、**进程内核栈**、以及**关键区域**分配了物理页。程序的绝大部分代码和数据**不在**物理内存中。 |
| **开始执行后**              | 通过**缺页异常**动态更新：将访问到的、之前无效的 PTE 标记为有效，并填入物理页帧号。                                                | 随着程序的执行，所需的代码和数据页被**按需加载**到物理内存中。                                             |

所以，**页表是进程虚拟地址空间的“蓝图”或“目录”**。它必须先于进程的主体内容存在，因为它定义了虚拟空间的布局和规则，并提供了当内容缺失时如何获取内容的“说明书”（磁盘位置）。没有这个初始的页表，进程根本无法开始运行，CPU 的 MMU 也无法进行任何有意义的地址翻译。

# 物理页和磁盘的映射

**这个映射是由操作系统内核通过软件数据结构来管理和维护的，而不是由MMU硬件来翻译的。**

物理页帧和磁盘块之间的映射关系，并不是像虚拟地址到物理地址那样有一个硬件“翻译器”。它是一系列**软件数据结构**，纯粹由操作系统内核创建和维护，用于记录物理页帧的“状态”和“来源”。

*   **操作系统内核** 的全权职责。具体来说，是内核中的**内存管理子系统** 和**虚拟文件系统（VFS）** 等模块。
*   **MMU硬件完全不参与这个过程**。MMU只负责虚拟->物理的翻译。当它发现一个页不在内存（有效位=0）时，它就通过触发缺页异常来“举手报告”，把控制权交给操作系统软件来处理。

这个映射是双向的，主要发生在两种场景下：

**场景一：首次从可执行文件加载一个页（Code/Data）**

1.  **记录来源（建立映射）**：
    *   当进程通过 `exec()` 系统调用启动时，操作系统加载器解析可执行文件的格式（如ELF）。
    *   它知道代码段（`.text`）和数据段（`.data`）在磁盘文件中的**偏移量（Offset）**。
    *   当它为这些段设置虚拟地址空间的页表项（PTE）时，它**将PTE的有效位设为0**，并在PTE内或关联的内核数据结构中，记录下该虚拟页对应的**磁盘信息**：`(文件句柄，文件内偏移)`。
    *   **此时，这个“映射”就建立了：虚拟页V <--> 磁盘文件F的位置P。**

2.  **使用映射（缺页时）**：
    *   当进程访问该虚拟页时，MMU触发缺页异常。
    *   内核的缺页处理程序查看PTE，发现有效位为0，并且看到它关联着一个磁盘文件（而不是交换空间）。
    *   处理程序根据之前记录的 `(文件句柄，文件内偏移)` 信息，**发起一个磁盘I/O操作**，从磁盘文件的指定位置读取**整个页（如4KB）** 的内容。
    *   同时，内核找到一个空闲的物理页帧（PF）。
    *   磁盘数据被读入这个物理页帧PF。
    *   **内核更新PTE**：将有效位置1，并填入物理页帧号PFN。现在映射变成了：虚拟页V <--> 物理页帧PF。
    *   **注意：此时，“虚拟页V <--> 磁盘文件F”这个映射关系的历史使命就完成了，可以被遗忘。** 物理页帧PF和磁盘之间并没有建立新的持久映射。

**场景二：将内存中的页换出到交换空间（Swap Out）**

当物理内存紧张时，内核需要将一些暂时不用的物理页帧的内容腾空，以便分配给更急需的页。

1.  **选择牺牲页**：内核的**页面置换算法**（如LRU）选择一个“最近最少使用”的物理页帧PF作为牺牲页。
2.  **检查脏位**：内核查看该物理页帧PF所对应的PTE中的**脏位（Dirty Bit）**。
    *   如果脏位为0（干净页），说明物理页中的内容与它的“来源”（如可执行文件）完全一致。既然磁盘上已有副本，内核可以直接丢弃这个物理页帧，无需写回。
    *   如果脏位为1（脏页），说明页已被修改（例如，进程堆上的数据），磁盘上的副本已过期。
3.  **换出到交换空间**：
    *   内核在**交换空间（Swap Space）**（磁盘上的专用区域，如Linux的swap分区或swap文件）中分配一个空闲的**槽位（Slot）**，记下这个槽位的地址 `swap_offset`。
    *   内核**发起一个磁盘I/O操作**，将物理页帧PF中的**整个内容**写入交换空间的这个槽位。
    *   **现在，关键的“映射”建立了：物理页帧PF <--> 交换空间位置S。**
    *   内核更新该物理页帧PF所对应的**所有进程的PTE**（因为物理内存可能被多个进程共享，如共享库）：
        *   将**有效位设为0**。
        *   在PTE中记录下它已被换出到了交换空间的哪个位置 `swap_offset`。
    *   最后，内核将物理页帧PF标记为空闲，可用于分配。

4.  **换入时（Swap In）**：
    *   当某个进程再次访问这个已被换出的虚拟页时，触发缺页异常。
    *   内核处理程序查看PTE，发现有效位为0，并且记录了一个交换空间的位置 `swap_offset`。
    *   内核找到一个空闲的物理页帧PF_new。
    *   内核**发起磁盘I/O**，从交换空间的 `swap_offset` 位置读取数据，加载到PF_new中。
    *   内核更新PTE：有效位置1，填入PF_new的页帧号。
    *   **映射关系再次改变：虚拟页V <--> 物理页帧PF_new。** 物理页帧PF_new和交换空间槽位S的映射是临时的，一旦页被换入，这个映射就可以被遗忘，交换空间的槽位S可以被未来其他的页使用。

## 存储映射关系的数据结构

这些“物理内存<->磁盘”的映射信息存储在操作系统内核的私有数据结构中，例如：

*   **每个物理页帧的元数据**：内核有一个名为 `struct page` 或类似的数据结构数组（称为**mem_map**），系统中的每个物理页帧都对应一项。这个结构可以记录：
    *   该物理页是否被占用？被谁占用？（引用计数）
    *   它是一个干净页还是脏页？
    *   如果它被换出，它被换到了哪个交换区的哪个槽位？（用于在需要时快速定位并换回）
*   **交换区缓存**：内核维护着交换空间的使用情况图，知道哪些槽位是空闲的。
*   **页表项（PTE）本身**：当页不在内存时，PTE的字段被操作系统**复用**来存储磁盘地址信息。MMU不会解读这些字段（因为有效位=0），但操作系统知道如何解析它们。

## 总结

| 特性         | 虚拟地址 -> 物理地址     | 物理地址 <-> 磁盘地址                            |
| :----------- | :----------------------- | :----------------------------------------------- |
| **管理方**   | **硬件（MMU）**          | **操作系统内核（软件）**                         |
| **机制**     | 硬件翻译（通过页表/TLB） | 软件记录和管理（通过内核数据结构）               |
| **触发**     | 每次内存访问自动触发     | 由缺页异常或页面置换算法触发                     |
| **数据结构** | 页表（Page Table）       | 页帧元数据数组（mem_map）、交换区映射表等        |
| **目的**     | 提供地址隔离和翻译       | 实现**按需调页**和**内存交换**，扩大可用内存空间 |

所以，**物理内存和磁盘的映射是一个由操作系统全权管理的、动态的、临时的“账本”**，它记录着页的“行踪”，以确保当硬件报告找不到页时，操作系统总能知道该去磁盘的哪个地方把它找回来。这个精妙的软硬件协同设计，是虚拟内存技术的基石。
