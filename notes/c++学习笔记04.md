C++ 学习笔记

# auto

`auto` 是 C++11 标准引入的一个关键字，用于**自动类型推导**。它让编译器根据初始化表达式来推导变量的类型，从而简化代码编写，提高可读性和可维护性。

`auto` 的核心思想是：**你负责初始化变量，编译器负责推断类型。**

```cpp
auto variable_name = initializer;
```

```cpp
auto i = 42;        // i 被推导为 int
auto d = 3.14;      // d 被推导为 double
auto s = "hello";   // s 被推导为 const char*
auto ch = 'a';      // ch 被推导为 char
```

在这些例子中，`auto` 的使用非常简单直观，它看起来似乎只是省略了类型名。但它的真正威力在于处理复杂类型。

1.  **避免冗长复杂的类型声明**
    这是 `auto` 最显著的优点。在处理迭代器、lambda 表达式、模板表达式等复杂类型时，类型名可能非常长且难以书写。

    **没有 auto (C++03):**
    ```cpp
    std::vector<std::string>::iterator it = my_vec.begin();
    ```

    **使用 auto (C++11及以后):**
    ```cpp
    auto it = my_vec.begin(); // 干净利落
    ```

2.  **保证初始化**
    使用 `auto` 声明的变量**必须被初始化**。这有助于避免未初始化变量导致的未定义行为错误。
    ```cpp
    int x;      // 可能未初始化，危险！
    auto y;     // 编译错误！必须初始化 ‘y’
    auto y = 0; // 正确
    ```

3.  **支持泛型编程**
    在模板函数和通用代码中，有时我们并不关心变量的具体类型，只关心它的操作。`auto` 让编写这类代码变得更加容易。
    ```cpp
    template<typename T, typename U>
    auto add(T t, U u) {
        return t + u; // 返回类型由 t+u 的结果决定
    }
    ```

4.  **适应未来变化**
    如果函数的返回类型改变了（例如从 `int` 改为 `long`），使用 `auto` 接收返回值的代码无需修改，编译器会自动推导出新的类型。

5.  **可读性**
    虽然有人认为显式写明类型更可读，但在很多情况下，`auto` 避免了繁琐的类型信息，让代码更专注于逻辑而非类型细节。变量名取得好（如 `it`, `index`）比类型更能表达意图。

## 编译时推导

当写下 `auto x = expression;` 时，编译器在编译阶段会做以下事情：
1.  分析 `expression` 的类型（包括值类别等）。
2.  应用 `auto` 的推导规则（例如，忽略顶层const和引用）。
3.  将推导出的类型“填入” `auto` 的位置。
4.  最终生成的机器码和你手动写出完整类型是完全一样的。

**示例：**
```cpp
int getValue() { return 42; }

int main() {
    auto x = getValue(); // 编译时，编译器推导出 getValue() 返回 int
                         // 所以 auto 被替换为 int
                         // 这行代码等价于 int x = getValue();
}
```
在编译后，`auto` 关键字就不存在了，它已经被确定的类型（这里是 `int`）所取代。运行时执行的只是 `getValue()` 函数的调用和将返回值赋给一个整型变量 `x` 的操作。

## 推导规则：与模板参数推导规则基本一致
`auto` 的类型推导遵循模板推导的规则。`auto` 关键字相当于模板参数 `T`。

```cpp
auto x = expression; // 类似于 template<typename T> void f(T x);
```

*   **值类型：** `auto` 会忽略顶层 `const` 和引用，推导出对象的类型。
    ```cpp
    const int ci = 10;
    auto a = ci;    // a 是 int (顶层const被忽略)
    a = 20;         // 正确，a 是可修改的 int

    int i = 0;
    int &ri = i;
    auto b = ri;    // b 是 int (引用被忽略，取的是引用的对象的值)
    b = 30;         // 修改 b 不影响 i
    ```

*   **引用和 const：** 使用 `auto&` 或 `const auto&` 来保留引用和 const 属性。
    ```cpp
    const int ci = 10;
    auto &c = ci;   // c 是 const int& (保留了const和引用)
    // c = 40;      // 错误！不能给常量赋值

    int i = 0;
    const auto &d = i; // d 是 const int&，常用于高效地读取而不修改
    ```

*   **万能引用：** 使用 `auto&&`，它会根据初始化表达式是左值还是右值进行推导（遵循引用折叠规则）。
    ```cpp
    int x = 1;
    auto&& rr1 = x;   // x是左值，rr1推导为 int&
    auto&& rr2 = 42;  // 42是右值，rr2推导为 int&&
    ```

## 与 const 和引用结合使用
可以手动为 `auto` 加上 `const` 或 `&` 来精确控制推导出的类型。

```cpp
int i = 50;
const auto *p = &i;    // p 是 const int*
auto *p = &i;          // p 是 int* (auto 被推导为 int)
const auto j = i;      // j 是 const int
auto &k = i;           // k 是 int&
const auto &l = i;     // l 是 const int&
```

```cpp
const int ci = 42;
const int *p = &ci;   // p 是一个指向常量整数的指针

// auto 推导：p 的类型是 const int*
// 这个类型包含底层const（指向的数据是const）
// 但指针本身（顶层）不是const。
auto p_auto = p;      // p_auto 的类型被推导为 const int*

// *p_auto = 10;     // 错误！不能通过 p_auto 修改它指向的常量
p_auto++;            // 正确！p_auto 这个指针本身可以改变，指向下一个地址
```

## 用于范围 for 循环
`auto` 使得范围 for 循环变得极其简洁和安全。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 值拷贝（修改v不影响vec中的元素）
for (auto v : vec) {
    v *= 2;
}

// 引用（可以修改vec中的元素）
for (auto &v : vec) {
    v *= 2;
}

// 常量引用（只读，效率高）
for (const auto &v : vec) {
    std::cout << v << std::endl;
}
```

## 用于函数返回类型 (C++14)
C++14 允许使用 `auto` 作为函数返回类型的占位符。编译器会根据函数体内的 `return` 语句来推导返回类型。

```cpp
// 简单例子
auto getValue() {
    return 42; // 返回类型推导为 int
}

// 更实用的例子：返回一个容器迭代器
auto findSomething(std::vector<int>& vec, int value) {
    return std::find(vec.begin(), vec.end(), value);
}
```
**注意：** 如果函数有多个 `return` 语句，它们必须推导出**相同的类型**。

## 用于 Lambda 表达式参数 (C++14)
C++14 允许在 lambda 表达式的参数中使用 `auto`，这创建了一个**泛型 lambda**。

```cpp
// 一个可以接受任何类型参数的lambda
auto adder = [](auto a, auto b) {
    return a + b;
};

std::cout << adder(1, 2) << std::endl;      // 3
std::cout << adder(1.1, 2.2) << std::endl;  // 3.3
std::string s1 = "Hello, ";
std::string s2 = "World!";
std::cout << adder(s1, s2) << std::endl;    // "Hello, World!"
```

## 注意事项与陷阱

1.  **`auto` 推导出的是基础类型**
    对于 `std::vector<bool>` 这样的容器，使用 `auto` 要小心。因为 `std::vector<bool>` 的 `operator[]` 返回的是一个代理对象（`std::vector<bool>::reference`），而不是 `bool&`。

    ```cpp
    std::vector<bool> vec_bool = {true, false, true};
    auto b = vec_bool[0]; // b 被推导为 std::vector<bool>::reference，不是一个简单的bool！
    // 如果vec_bool后续被修改或销毁，b的行为可能是未定义的！

    // 正确的做法是进行显式转换
    bool b2 = vec_bool[0]; // 或者 static_cast<bool>(vec_bool[0])
    ```

2.  **`auto` 与初始化列表 `{}`**
    ```cpp
    auto a = {1, 2, 3}; // a 被推导为 std::initializer_list<int>
    // auto b{1, 2, 3}; // C++17 起错误：直接列表初始化不能推导出多个值
    auto c = {42};      // c 是 std::initializer_list<int>
    auto d{42};         // C++17 起，d 被推导为 int (而不是 initializer_list)
    ```
    在 C++17 中，规则发生了变化，使得 `auto d{42}` 推导为 `int` 更符合直觉。如果需要 `initializer_list`，应使用 `=`。

3.  ** readability vs. Obscurity**
    虽然 `auto` 很好，但并非所有地方都适用。如果一个变量的类型对于理解代码逻辑至关重要，而它的名字或初始化表达式又不能清晰地表达它，那么显式写出类型可能更好。
    ```cpp
    // 好的例子：类型显而易见或无关紧要
    auto it = my_map.find("key");
    auto customer = getCustomerById(123);

    // 可能不好的例子：类型不明确
    auto result = someComplexFunction(); // result 是什么类型？double? int?
    // 在这种情况下，显式写出类型可能更有助于阅读：
    // double result = someComplexFunction();
    ```

## 总结

| 场景                 | 推荐用法                                  | 说明                   |
| :------------------- | :---------------------------------------- | :--------------------- |
| **迭代器**           | `auto it = vec.begin();`                  | 避免冗长的类型名       |
| **范围 for 循环**    | `for (const auto& element : container)`   | 高效且简洁             |
| **Lambda 表达式**    | `auto func = [](){};`                     | 存储 lambda 的唯一方式 |
| **模板函数返回类型** | `auto func() { return ...; }`             | 简化返回复杂类型的函数 |
| **避免未初始化**     | `auto x = getValue();`                    | 强制初始化             |
| **类型名冗长**       | `auto ptr = std::make_shared<MyClass>();` | 提高可读性             |

# decltype

`decltype`（即 "declare type"）是 C++11 引入的关键字，用于**查询表达式或实体的类型**。它与 `auto` 都是用于类型推导，但它们的**目标和规则截然不同**。

*   **`auto`**： 根据初始化器**推导变量**的类型。它遵循模板参数推导规则，会忽略顶层 `const` 和引用。
*   **`decltype`**： 返回给定表达式或变量名的**确切类型**，包括所有 `const` 和引用限定符。

`decltype` 的使用主要有两种形式：

1.  `decltype(entity)`
2.  `decltype(expression)`

它们的推导规则有所不同。

`decltype` 的核心价值在于**获取表达式精确的类型信息**，常用于 `auto` 无法胜任的场景。

## 编译时推导
`decltype` 是编译时行为。它不是一个变量声明，而是一个**类型说明符**。编译器在编译时分析给定的表达式，计算出它的类型，然后就把 `decltype(...)` 替换成那个具体的类型。

```cpp
int i;
const int& cr = i;

// 编译时计算：
using Type1 = decltype(i);   // 编译器计算 -> Type1 是 int
using Type2 = decltype(cr);  // 编译器计算 -> Type2 是 const int&
using Type3 = decltype(i+0); // 编译器计算 -> i+0 是纯右值 -> Type3 是 int
using Type4 = decltype((i)); // 编译器计算 -> (i)是左值表达式 -> Type4 是 int&

// 这些using语句在编译后也不会留下任何痕迹，
// 它们只是为编译器内部的符号表提供了类型别名。
```

## 规则 1: `decltype(entity)` （例如变量名）
当参数是一个**未加括号的变量名或类成员访问**（`e.g. x` 或 `obj.member`）时，`decltype` 直接返回该实体**声明时的类型**，包括 `const` 和引用。

```cpp
int x = 10;
const int cx = 20;
int& rx = x;
const int& crx = cx;

decltype(x)     a = x;    // a 的类型是 int
decltype(cx)    b = cx;   // b 的类型是 const int
decltype(rx)    c = x;    // c 的类型是 int& (并且绑定到 x)
decltype(crx)   d = cx;   // d 的类型是 const int& (并且绑定到 cx)

// 类成员访问同理
struct MyStruct { double d; };
MyStruct ms;
decltype(ms.d) e = ms.d;  // e 的类型是 double
```

## 规则 2: `decltype(expression)` （例如 `(x)` 或 `x + y`）
当参数是一个**表达式**（特别是加了括号的变量名）时，`decltype` 返回表达式结果的**值类别（Value Category）** 所对应的类型：
*   如果表达式的结果是**纯右值（prvalue）**（例如一个临时值），`decltype` 返回 **`T`**。
*   如果表达式的结果是**将亡值（xvalue）**（例如 `std::move(x)`），`decltype` 返回 **`T&&`**。
*   如果表达式的结果是**左值（lvalue）**（例如 `++x`, `(x)`），`decltype` 返回 **`T&`**。

**最重要的例子：给变量加括号**
```cpp
int x = 10;

decltype(x)    var1 = x;  // var1 是 int (规则1)
decltype((x))  var2 = x;  // var2 是 int& (规则2，因为 (x) 是一个左值表达式)

// var2 是一个引用，绑定到了 x
var2 = 100; // 这行代码修改了 x 的值！
std::cout << x; // 输出 100
```
**这是 `decltype` 最容易让人困惑的地方，务必牢记 `(x)` 和 `x` 的区别。**

## 在模板元编程中获取依赖类型
当编写模板代码时，类型可能是未知的（依赖于模板参数 `T`），`decltype` 可以帮助你基于表达式计算出需要的类型。

```cpp
#include <vector>
#include <list>
#include <iostream>

// 一个泛型函数，我们想声明一个与容器元素同类型的变量
template<typename Container>
void processContainer(const Container& c) {
    // 我们不知道 Container::value_type 是否存在（比如C数组就没有）
    // 使用 decltype 来推导 c[0] 或 *c.begin() 的类型
    using ElementType = decltype(*std::begin(c)); 
    // *std::begin(c) 对于标准容器返回的是 T&
    // 所以 ElementType 是 T&

    // 如果我们只想要值类型，需要 std::remove_reference
    using ValueType = typename std::remove_reference<ElementType>::type;

    ValueType local_var{};
    // ... 使用 local_var ...
}

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::list<double> lst = {1.1, 2.2, 3.3};
    int arr[] = {4, 5, 6};

    processContainer(vec); // ElementType 是 int&, ValueType 是 int
    processContainer(lst); // ElementType 是 double&, ValueType 是 double
    processContainer(arr); // ElementType 是 int&, ValueType 是 int
}
```

## 声明返回类型依赖于参数的函数 (C++11 尾随返回类型)
在 C++11 中，`decltype` 与 **尾随返回类型（Trailing Return Type）** 语法结合，可以声明那些返回类型需要根据参数表达式来计算的函数。

```cpp
template<typename T, typename U>
// auto 是返回类型的占位符，真正的返回类型在 -> 后面指定
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}

int main() {
    auto a = add(1, 2);       // a 的类型是 int
    auto b = add(1, 2.5);     // b 的类型是 double
    auto c = add(1, 'A');     // c 的类型是 int ('A' 提升为 int)
}
```
在 C++14 中，可以省略尾随返回类型，只写 `auto`，编译器会自动从 `return` 语句推导类型。但在复杂表达式中，有时仍需 `decltype` 来精确控制。

## 在编译时检查表达式是否有效 (SFINAE)
`decltype` 常用于 **SFINAE（Substitution Failure Is Not An Error）** 技术，来在编译期基于某个表达式是否有效选择不同的函数重载或模板特化。

**示例：检查类型是否有 `size()` 成员函数**
```cpp
#include <iostream>
#include <vector>

// 辅助工具：void_t
template<typename...>
using void_t = void;

// 主模板，默认没有 type 成员，继承自 false_type
template<typename T, typename = void>
struct has_size_member : std::false_type {};

// 特化版本：如果表达式 decltype(std::declval<T>().size()) 是有效的，则匹配此版本
template<typename T>
struct has_size_member<T, void_t<decltype(std::declval<T>().size())>> : std::true_type {};

// 用法
struct Foo { int size() { return 42; } };
struct Bar {};

int main() {
    std::cout << std::boolalpha;
    std::cout << has_size_member<std::vector<int>>::value << std::endl; // true
    std::cout << has_size_member<Foo>::value << std::endl;              // true
    std::cout << has_size_member<Bar>::value << std::endl;              // false
    std::cout << has_size_member<int>::value << std::endl;              // false
}
```
`std::declval<T>()` 允许我们在不构造对象的情况下假想一个 `T` 类型的值，以便在其上使用成员函数如 `.size()`。`decltype` 则检查这个表达式是否形成良好类型。

## `decltype(auto)` (C++14)
C++14 引入了 `decltype(auto)`，它结合了两者的特点：它使用 `auto` 的语法进行占位，但使用 `decltype` 的规则进行推导。

*   `auto`： 使用模板推导规则（忽略顶层 `const` 和引用）。
*   `decltype(auto)`： 使用 `decltype` 规则（保留所有类型信息）。

```cpp
int x = 0;
const int& crx = x;

auto a1 = crx;           // a1 是 int (顶层const和引用被auto规则忽略)
decltype(auto) a2 = crx; // a2 是 const int& (decltype规则保留了crx的全部信息)

// 在函数返回类型中极其有用
template<typename Container, typename Index>
auto get_value_old(Container& c, Index i) -> decltype(c[i]) {
    return c[i]; // 返回类型是 T&
}
// C++14 等价写法
template<typename Container, typename Index>
decltype(auto) get_value_new(Container& c, Index i) {
    return c[i]; // 返回类型完美推导为 c[i] 的类型 (T&)
}

std::vector<int> vec = {1, 2, 3};
get_value_old(vec, 1) = 10; // 正确，返回的是引用，可以赋值
get_value_new(vec, 1) = 20; // 同样正确
```

## 总结与对比

| 特性         | `auto`                                      | `decltype`                                       |
| :----------- | :------------------------------------------ | :----------------------------------------------- |
| **目的**     | 推导**变量**的类型                          | 查询**表达式**的类型                             |
| **推导规则** | 模板参数推导规则（忽略顶层 `const` 和引用） | 精确反映表达式或实体的声明类型（保留所有限定符） |
| **主要用途** | 简化变量声明，范围 for 循环                 | 模板元编程，尾随返回类型，SFINAE                 |
| **与括号**   | `auto x = (y);` // 括号不影响               | `decltype((y))` // 至关重要，决定值类别          |

# auto vs decltype

| 特性             | `auto`                   | `decltype`                         |
| :--------------- | :----------------------- | :--------------------------------- |
| **设计目的**     | **声明并初始化一个变量** | **查询一个表达式或实体的类型**     |
| **工作结果**     | **产生一个新变量**       | **产生一个类型说明符**             |
| **核心用途**     | 简化代码，避免冗长类型名 | 元编程、泛型编程、精确匹配类型     |
| **推导规则**     | 忽略顶层`const`和引用    | 完全保留表达式或实体的所有类型信息 |
| **与初始化关系** | **必须立即初始化**       | **不需要初始化**，它只查询类型     |

```cpp
int x = 10;
const int y = 20;

// 使用 auto：简单、直观、正确
auto a1 = x; // a1 是 int
auto a2 = y; // a2 是 int (顶层const被忽略)

// 尝试用 decltype 做同样的事：繁琐、容易出错
decltype(x) d1 = x;     // d1 是 int, 正确但啰嗦
decltype(y) d2 = y;     // d2 是 const int! 这和auto行为不同！
decltype((y)) d3 = y;   // d3 是 const int&! 这更不一样了！

int getValue(); // 一个函数声明

// 使用 auto：完美
auto result = getValue(); // 正确，调用函数，用返回值初始化result

// 尝试用 decltype 做同样的事：完全错误！
// decltype(getValue()) result; // 错误！decltype只查询返回类型，它不会调用函数！
                               // 这只是一条声明语句，相当于写了 `int result;`，但未初始化。
// result = getValue();         // 需要再写一行来调用和赋值
```

从上例可以看出：
1.  **`auto` 的初衷是“定义变量”**，它和初始化表达式紧密绑定，会执行表达式、计算值，然后用推导出的类型**创建一个新变量**。
2.  **`decltype` 的初衷是“查询类型”**，它**不会执行表达式**，只是静态地分析“如果这个表达式被求值，它的类型是什么”，然后给你这个类型结果。你需要再用这个结果去手动声明变量。

## `auto` 使用场景

1.  **迭代器**
    ```cpp
    // 没有 auto
    std::vector<std::map<int, std::string>>::iterator it = my_container.begin();

    // 有 auto
    auto it = my_container.begin(); // 清晰明了
    ```

2.  **范围 for 循环**
    ```cpp
    for (auto& element : container) { ... } // 遍历容器
    ```

3.  **避免冗长类型名**
    ```cpp
    auto ptr = std::make_shared<MyVeryLongClassName>(); // 类型名又长又复杂
    ```

4.  **Lambda 表达式**
    ```cpp
    auto func = [](int x) { return x * 2; }; // 存储lambda的唯一方式
    ```

在这些场景下，用 `decltype` 会变得非常啰嗦和反人类。

## `decltype` 使用场景

1.  **模板元编程中获取依赖类型**
    ```cpp
    template<typename Container>
    void foo(Container& c) {
        // 我们需要一个和容器元素类型相同的变量
        // auto 做不到，因为这里没有初始化器
        using ValueType = typename Container::value_type; // 方法1，但不是所有容器都有
        using ValueType = decltype(*c.begin());           // 方法2，更通用！(推导出T&)
        using ValueTypeNoRef = std::remove_reference_t<decltype(*c.begin())>; // 得到 T

        ValueTypeNoRef local_var; // 现在可以声明变量了
    }
    ```

2.  **尾随返回类型（C++11）**
    ```cpp
    template<typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) { // 返回类型依赖参数t和u
        return t + u;
    }
    ```

3.  **编译期检查（SFINAE）**
    ```cpp
    // 检查一个类型是否有`empty`成员函数
    template<typename T, typename = decltype(std::declval<T>().empty())>
    std::true_type has_empty_helper(T*);

    template<typename>
    std::false_type has_empty_helper(...);
    ```

在这些场景下，`auto` 无能为力，必须使用 `decltype`。

# using

## 类型别名（Type Aliases）

这是 `using` 最常见的用途之一，类似于 `typedef`，但更清晰和强大。

### 基本类型别名
```cpp
// 等价于: typedef int MyInt;
using MyInt = int;

// 等价于: typedef double Distance;
using Distance = double;

MyInt x = 42;
Distance d = 3.14;
```

### 模板类型别名（`using` 比 `typedef` 更强大的地方）
```cpp
// 使用 typedef 无法直接创建模板别名
// 使用 using 可以
template<typename T>
using MyVector = std::vector<T>;

// 使用
MyVector<int> intVector;
MyVector<std::string> stringVector;

// 更复杂的例子
template<typename T, int Size>
using MyArray = std::array<T, Size>;

MyArray<double, 10> doubleArray;
```

### 函数指针别名
```cpp
// 使用 typedef 的传统方式
typedef void (*OldFuncPtr)(int, int);

// 使用 using 的更清晰方式
using FuncPtr = void (*)(int, int);

// 使用
void add(int a, int b) { std::cout << a + b << std::endl; }
FuncPtr ptr = add;
ptr(3, 4); // 输出 7
```

## 命名空间的使用

### 引入整个命名空间
```cpp
#include <iostream>

// 引入整个 std 命名空间
using namespace std;

int main() {
    // 现在可以直接使用 cout 和 endl，不需要 std::
    cout << "Hello, World!" << endl;
    return 0;
}
```

### 引入特定名称
```cpp
#include <iostream>

// 只引入特定的名称
using std::cout;
using std::endl;

int main() {
    cout << "Hello, World!" << endl;
    // string s = "test"; // 错误！string 没有被引入
    return 0;
}
```

### 在函数内部使用（推荐方式）
```cpp
#include <iostream>

int main() {
    // 在最小作用域内使用 using
    using std::cout;
    using std::endl;
    
    cout << "Hello, World!" << endl;
    return 0;
}
```

## 在类继承中的使用

### 引入基类成员到派生类
当派生类中的成员名称隐藏了基类的同名成员时，可以使用 `using` 引入基类成员。

```cpp
class Base {
public:
    void func() { std::cout << "Base::func()" << std::endl; }
    void func(int x) { std::cout << "Base::func(" << x << ")" << std::endl; }
    int value = 10;
};

class Derived : public Base {
public:
    // 使用 using 引入 Base 的所有 func 重载
    using Base::func;
    
    // 这会隐藏 Base 的 func，但 using  above 解决了这个问题
    void func() { std::cout << "Derived::func()" << std::endl; }
    
    // 使用 using 引入基类成员变量
    using Base::value;
    
    int value = 20; // 隐藏基类的 value
};

int main() {
    Derived d;
    d.func();    // 调用 Derived::func()
    d.func(42);  // 调用 Base::func(int)，因为使用了 using
    std::cout << d.value << std::endl;       // 输出 20 (派生类的 value)
    std::cout << d.Base::value << std::endl; // 输出 10 (基类的 value)
    return 0;
}
```

## 在模板编程中的使用

### 结合 decltype 使用
```cpp
template<typename Container>
auto getValueType(const Container& c) {
    // 使用 using 和 decltype 创建类型别名
    using ValueType = typename std::remove_reference<decltype(*c.begin())>::type;
    return ValueType{};
}

int main() {
    std::vector<int> v = {1, 2, 3};
    auto x = getValueType(v); // x 的类型是 int
    return 0;
}
```