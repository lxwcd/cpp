C++ 学习笔记

# 闭包 (Closure)

闭包是一个可以捕获并存储其所在作用域中的变量的**函数对象**。它不仅仅是函数本身，还包含了函数被创建时所处的“环境”（即那些被捕获的变量）。

**闭包 (Closure)**：记住 **“函数 + 环境 = 闭包”**。它是一个打包好的、自包含的、可以带着“干粮”（捕获的变量）到处跑的“函数工具包”。

闭包的核心组成：
1.  **函数体 (Function Body)**: 要执行的代码。
2.  **捕获列表 (Capture List)**: `[]` 中的部分，定义了哪些外部变量将被捕获到闭包中，以及是以何种方式（值捕获 `[=]` 或引用捕获 `[&]`）捕获的。

## Lambda 表达式实现闭包

**Lambda 表达式是创建闭包的语法糖，而闭包是 lambda 表达式产生的函数对象。**
- **Lambda 表达式**：是一种语法结构，用于定义匿名函数
- **闭包**：是 lambda 表达式实例化后创建的具体对象

```cpp
[&self]() { return self.handler_true(); }
```

这行代码定义了一个 **lambda 表达式**，它会产生一个**闭包**。

- **`[&self]`**: 这是**捕获列表**。`&` 表示以**引用方式**捕获变量 `self`。这意味着闭包内部使用的 `self` 是外部那个 `self` 对象的引用，任何修改都会影响到外部对象。
- **`()`**: 这是**参数列表**。这个lambda没有参数。
- **`{ return self.handler_true(); }`**: 这是**函数体**。调用 `self` 的 `handler_true()` 成员函数并返回其结果。

**这个lambda表达式本身是一个表达式，当它被执行时（通常是在定义的时候），就会产生一个闭包对象。这个对象可以像函数一样被调用，并且它内部持有了对外部 `self` 的引用。**

通常会把它赋给一个变量（例如 `std::function`）或者直接传递给一个接受可调用对象的函数。

```cpp
// 假设 self 是某个类的对象
// 1. 直接调用
bool result = [&self]() { return self.handler_true(); }(); // 注意最后的 ()，表示立即调用

// 2. 赋值给 std::function 并保存以备后用
#include <functional>
std::function<bool()> my_closure = [&self]() { return self.handler_true(); };

// ... 在未来的某个时间 ...
bool result = my_closure(); // 调用闭包，它仍然可以访问当初捕获的 self 引用
```

## 生命周期问题

```cpp
#include <iostream>
#include <functional>

std::function<int()> createClosure() {
    int local_var = 42;
    
    // 危险：捕获了局部变量的引用
    return [&local_var]() {
        return local_var; // 悬空引用！
    };
}

int main() {
    auto closure = createClosure();
    // 这里调用 closure() 会导致未定义行为
    // 因为 local_var 已经被销毁
    
    return 0;
}
```

正确的做法
```cpp
#include <iostream>
#include <functional>

std::function<int()> createSafeClosure() {
    int local_var = 42;
    
    // 安全：通过值捕获
    return [local_var]() { // 复制 local_var
        return local_var;
    };
}

int main() {
    auto safe_closure = createSafeClosure();
    std::cout << safe_closure() << std::endl; // 安全，输出 42
    
    return 0;
}
```

## 函数对象（仿函数）实现闭包

在 C++11 之前，主要通过函数对象（重载了 operator() 的类）来实现闭包功能。

```cpp
#include <iostream>

// 示例 1: 基本函数对象
class Multiplier {
private:
    int factor;
public:
    Multiplier(int f) : factor(f) {}
    
    int operator()(int x) const {
        return x * factor;
    }
};

// 示例 2: 更复杂的函数对象
class Counter {
private:
    int count;
    int step;
public:
    Counter(int initial = 0, int s = 1) : count(initial), step(s) {}
    
    int operator()() {
        int old_count = count;
        count += step;
        return old_count;
    }
    
    void reset() {
        count = 0;
    }
    
    int get() const {
        return count;
    }
};

int main() {
    // 使用函数对象
    Multiplier timesTwo(2);
    Multiplier timesFive(5);
    
    std::cout << "2 * 10 = " << timesTwo(10) << std::endl; // 20
    std::cout << "5 * 10 = " << timesFive(10) << std::endl; // 50
    
    Counter myCounter(0, 2);
    std::cout << "计数: " << myCounter() << std::endl; // 0
    std::cout << "计数: " << myCounter() << std::endl; // 2
    std::cout << "计数: " << myCounter() << std::endl; // 4
    
    return 0;
}
```

## std::function 和 std::bind 结合实现闭包

C++11 还提供了 std::function 和 std::bind，可以用于创建和存储闭包。

```cpp
#include <iostream>
#include <functional>

void printSum(int a, int b) {
    std::cout << a << " + " << b << " = " << a + b << std::endl;
}

class Printer {
public:
    void printMessage(const std::string& message) {
        std::cout << "消息: " << message << std::endl;
    }
};

int main() {
    // 使用 std::bind 创建闭包
    auto addFive = std::bind(printSum, std::placeholders::_1, 5);
    addFive(10); // 输出: 10 + 5 = 15
    
    // 绑定成员函数
    Printer printer;
    auto printHello = std::bind(&Printer::printMessage, &printer, "Hello");
    printHello(); // 输出: 消息: Hello
    
    // 使用 std::function 存储闭包
    std::function<int(int)> multiplier;
    
    int factor = 3;
    multiplier = [factor](int x) { return x * factor; };
    
    std::cout << "3 * 7 = " << multiplier(7) << std::endl; // 21
    
    // 修改 factor 不会影响已捕获的值
    factor = 5;
    std::cout << "仍然: 3 * 7 = " << multiplier(7) << std::endl; // 21
    
    return 0;
}
```

# 函数指针

函数指针是一个指向函数而非数据的指针。与数据指针类似，但它指向的是代码而不是数据。

```cpp
return_type (*pointer_name)(parameter_types);
```

## 初始化函数指针

```cpp
// 声明一个指向函数的指针，该函数接受两个int参数并返回int
int (*funcPtr)(int, int);
```

```cpp
int add(int a, int b) {
    return a + b;
}

// 将函数地址赋给指针
funcPtr = add;
// 或者使用取地址运算符（可选）
funcPtr = &add;
```

## 通过函数指针调用函数

```cpp
// 直接使用指针调用函数
int result = funcPtr(3, 4);

// 或者使用解引用运算符（可选）
int result = (*funcPtr)(3, 4);
```

## 函数指针作为参数

函数指针可以作为参数传递给其他函数，这使得回调函数成为可能。

```cpp
#include <iostream>
#include <vector>

// 回调函数类型
typedef void (*Callback)(int);

// 处理数据的函数，接受一个回调函数
void processData(const std::vector<int>& data, Callback callback) {
    for (int value : data) {
        callback(value);
    }
}

// 几个不同的回调函数
void printValue(int value) {
    std::cout << "Value: " << value << std::endl;
}

void printSquare(int value) {
    std::cout << "Square: " << value * value << std::endl;
}

void printCube(int value) {
    std::cout << "Cube: " << value * value * value << std::endl;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    std::cout << "Printing values:" << std::endl;
    processData(numbers, printValue);
    
    std::cout << "\nPrinting squares:" << std::endl;
    processData(numbers, printSquare);
    
    std::cout << "\nPrinting cubes:" << std::endl;
    processData(numbers, printCube);
    
    return 0;
}
```

## 函数指针数组

可以创建函数指针数组，实现类似调度表的功能。

```cpp
#include <iostream>

// 几个简单的函数
void func1() { std::cout << "Function 1 called" << std::endl; }
void func2() { std::cout << "Function 2 called" << std::endl; }
void func3() { std::cout << "Function 3 called" << std::endl; }

int main() {
    // 声明并初始化函数指针数组
    void (*functions[3])() = {func1, func2, func3};
    
    int choice;
    std::cout << "Enter a number between 1 and 3 (0 to exit): ";
    std::cin >> choice;
    
    while (choice != 0) {
        if (choice >= 1 && choice <= 3) {
            // 调用数组中的函数
            functions[choice - 1]();
        } else {
            std::cout << "Invalid choice!" << std::endl;
        }
        
        std::cout << "Enter a number between 1 and 3 (0 to exit): ";
        std::cin >> choice;
    }
    
    return 0;
}
```

## 使用typedef简化函数指针

使用typedef可以使函数指针类型更易读。

```cpp
#include <iostream>

// 使用typedef定义函数指针类型
typedef int (*MathOperation)(int, int);

// 数学函数
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

// 接受函数指针作为参数的函数
int calculate(int a, int b, MathOperation op) {
    return op(a, b);
}

int main() {
    int x = 10, y = 5;
    
    // 使用typedef定义的类型
    MathOperation operation;
    
    operation = add;
    std::cout << x << " + " << y << " = " << calculate(x, y, operation) << std::endl;
    
    operation = subtract;
    std::cout << x << " - " << y << " = " << calculate(x, y, operation) << std::endl;
    
    return 0;
}
```

## C++11及以后：使用std::function和lambda

在现代C++中，通常有比原始函数指针更好的选择：

```cpp
#include <iostream>
#include <functional>
#include <vector>

// 使用std::function而不是原始函数指针
void processData(const std::vector<int>& data, 
                 const std::function<void(int)>& callback) {
    for (int value : data) {
        callback(value);
    }
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 使用lambda表达式而不是函数指针
    std::cout << "Values and their squares:" << std::endl;
    processData(numbers, [](int value) {
        std::cout << value << " -> " << value * value << std::endl;
    });
    
    // 另一个lambda示例
    int multiplier = 3;
    std::cout << "\nValues multiplied by " << multiplier << ":" << std::endl;
    processData(numbers, [multiplier](int value) {
        std::cout << value << " * " << multiplier << " = " << value * multiplier << std::endl;
    });
    
    return 0;
}
```

## 普通函数指针与成员函数指针

- **普通函数指针**：指向独立的函数，不需要特定的对象上下文
- **成员函数指针**：指向类的成员函数，必须通过类的对象来调用（因为它需要 `this` 指针）

### 普通函数指针声明

```cpp
// 指向普通函数的指针
return_type (*pointer_name)(parameter_types);

// 示例
int (*func_ptr)(int, int); // 指向接受两个int参数返回int的函数
```

### 成员函数指针声明

```cpp
// 指向成员函数的指针
return_type (Class_name::*pointer_name)(parameter_types);

// 示例
int (MyClass::*member_func_ptr)(int, int); // 指向MyClass的成员函数
```

### 普通函数指针示例

```cpp
#include <iostream>

// 普通函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 声明并初始化普通函数指针
    int (*func_ptr)(int, int) = add;
    
    // 直接调用
    int result = func_ptr(3, 4);
    std::cout << "Result: " << result << std::endl; // 输出 7
    
    return 0;
}
```

### 成员函数指针示例

```cpp
#include <iostream>

class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
    
    int multiply(int a, int b) {
        return a * b;
    }
};

int main() {
    Calculator calc;
    
    // 声明成员函数指针
    int (Calculator::*member_func_ptr)(int, int);
    
    // 初始化成员函数指针
    member_func_ptr = &Calculator::add;
    
    // 通过对象调用成员函数指针
    int result = (calc.*member_func_ptr)(3, 4);
    std::cout << "Addition: " << result << std::endl; // 输出 7
    
    // 指向另一个成员函数
    member_func_ptr = &Calculator::multiply;
    result = (calc.*member_func_ptr)(3, 4);
    std::cout << "Multiplication: " << result << std::endl; // 输出 12
    
    return 0;
}
```

### 成员函数指针调用方式

通过对象调用
```cpp
// 对象.*成员函数指针
Calculator calc;
int (Calculator::*func_ptr)(int, int) = &Calculator::add;
int result = (calc.*func_ptr)(3, 4);
```

通过指针调用
```cpp
// 指针->*成员函数指针
Calculator* calc_ptr = new Calculator();
int (Calculator::*func_ptr)(int, int) = &Calculator::add;
int result = (calc_ptr->*func_ptr)(3, 4);
delete calc_ptr;
```

### 使用typedef/using简化

由于成员函数指针的语法比较复杂，通常使用类型别名来简化：

```cpp
#include <iostream>

class MathOperations {
public:
    double square(double x) { return x * x; }
    double cube(double x) { return x * x * x; }
};

int main() {
    // 使用using简化成员函数指针类型
    using MathFuncPtr = double (MathOperations::*)(double);
    
    MathOperations math;
    MathFuncPtr operation;
    
    operation = &MathOperations::square;
    std::cout << "Square: " << (math.*operation)(5.0) << std::endl; // 输出 25
    
    operation = &MathOperations::cube;
    std::cout << "Cube: " << (math.*operation)(5.0) << std::endl; // 输出 125
    
    return 0;
}
```

### 实现回调机制

```cpp
#include <iostream>
#include <vector>

class Button {
public:
    // 使用using定义成员函数指针类型
    using ClickHandler = void (Button::*)();
    
    void setHandler(ClickHandler handler) {
        clickHandler = handler;
    }
    
    void click() {
        if (clickHandler) {
            (this->*clickHandler)(); // 调用成员函数指针
        }
    }
    
    void onClick() {
        std::cout << "Button clicked!" << std::endl;
    }
    
    void onDoubleClick() {
        std::cout << "Button double clicked!" << std::endl;
    }
    
private:
    ClickHandler clickHandler = nullptr;
};

int main() {
    Button btn;
    
    // 设置不同的处理函数
    btn.setHandler(&Button::onClick);
    btn.click(); // 输出 "Button clicked!"
    
    btn.setHandler(&Button::onDoubleClick);
    btn.click(); // 输出 "Button double clicked!"
    
    return 0;
}
```

### 实现命令模式

```cpp
#include <iostream>
#include <map>
#include <string>

class Document {
public:
    using Command = void (Document::*)();
    
    void newDocument() {
        std::cout << "Creating new document" << std::endl;
    }
    
    void openDocument() {
        std::cout << "Opening document" << std::endl;
    }
    
    void saveDocument() {
        std::cout << "Saving document" << std::endl;
    }
    
    void executeCommand(const std::string& commandName) {
        auto it = commands.find(commandName);
        if (it != commands.end()) {
            (this->*(it->second))(); // 执行命令
        } else {
            std::cout << "Unknown command: " << commandName << std::endl;
        }
    }
    
    // 命令映射表
    std::map<std::string, Command> commands = {
        {"new", &Document::newDocument},
        {"open", &Document::openDocument},
        {"save", &Document::saveDocument}
    };
};

int main() {
    Document doc;
    
    doc.executeCommand("new");   // 输出 "Creating new document"
    doc.executeCommand("open");  // 输出 "Opening document"
    doc.executeCommand("save");  // 输出 "Saving document"
    doc.executeCommand("exit");  // 输出 "Unknown command: exit"
    
    return 0;
}
```

### 现代C++的替代方案

虽然成员函数指针很强大，但在现代C++中，通常有更简洁的替代方案：

#### 使用std::function和std::bind

```cpp
#include <iostream>
#include <functional>

class Processor {
public:
    void process(int value) {
        std::cout << "Processing: " << value << std::endl;
    }
};

int main() {
    Processor proc;
    
    // 使用std::bind绑定成员函数和对象
    auto bound_func = std::bind(&Processor::process, &proc, std::placeholders::_1);
    
    bound_func(42); // 输出 "Processing: 42"
    
    // 使用std::function存储
    std::function<void(int)> func = std::bind(&Processor::process, &proc, std::placeholders::_1);
    func(100); // 输出 "Processing: 100"
    
    return 0;
}
```

#### 使用Lambda表达式

```cpp
#include <iostream>
#include <functional>

class Formatter {
public:
    std::string format(const std::string& input) {
        return "[" + input + "]";
    }
};

int main() {
    Formatter fmt;
    
    // 使用lambda捕获对象并调用成员函数
    auto format_lambda = [&fmt](const std::string& input) {
        return fmt.format(input);
    };
    
    std::cout << format_lambda("hello") << std::endl; // 输出 "[hello]"
    
    return 0;
}
```

### 成员函数指针赋值

**在给成员函数指针赋值时，必须使用 `&` 取地址运算符。**

- 成员函数名称本身（如 `ClassName::functionName`）并不直接表示函数的地址
- 必须使用 `&` 运算符来明确表示我们要获取该成员函数的地址
- 这是语法规定，与普通函数指针不同（普通函数名在大多数情况下会隐式转换为函数指针）

```cpp
class MyClass {
public:
    void myFunction() {}
    int anotherFunction(int x) { return x * 2; }
};

int main() {
    // 正确：必须使用 & 取地址
    void (MyClass::*funcPtr)() = &MyClass::myFunction;
    int (MyClass::*anotherFuncPtr)(int) = &MyClass::anotherFunction;
    
    // 错误：不能省略 &
    // void (MyClass::*wrongPtr)() = MyClass::myFunction; // 编译错误
    
    return 0;
}
```

### 调用成员函数指针

**在调用成员函数指针时，`*` 解引用运算符是必须的，但语法比较特殊。**

```cpp
// 通过对象调用
(object.*memberFunctionPointer)(arguments);

// 通过对象指针调用
(objectPointer->*memberFunctionPointer)(arguments);
```

- `.*` 和 `->*` 是特殊的运算符，专门用于通过成员指针调用成员函数
- 它们将对象/对象指针与成员函数指针结合起来
- 括号是必须的，因为函数调用运算符 `()` 的优先级高于 `.*` 和 `->*`

```cpp
#include <iostream>

class Calculator {
public:
    int add(int a, int b) {
        std::cout << "Adding: " << a << " + " << b << " = " << a + b << std::endl;
        return a + b;
    }
    
    int multiply(int a, int b) {
        std::cout << "Multiplying: " << a << " * " << b << " = " << a * b << std::endl;
        return a * b;
    }
};

int main() {
    Calculator calc;
    Calculator* calcPtr = &calc;
    
    // 定义成员函数指针
    int (Calculator::*operation)(int, int);
    
    // 赋值（必须使用 &）
    operation = &Calculator::add;
    
    // 调用（必须使用 .* 或 ->*）
    (calc.*operation)(3, 4);        // 通过对象调用
    (calcPtr->*operation)(5, 6);    // 通过指针调用
    
    // 切换到另一个函数
    operation = &Calculator::multiply;
    (calc.*operation)(3, 4);        // 通过对象调用
    (calcPtr->*operation)(5, 6);    // 通过指针调用
    
    return 0;
}
```

### 普通函数指针赋值与调用

```cpp
#include <iostream>

// 普通函数
void normalFunction() {
    std::cout << "Normal function called" << std::endl;
}

int main() {
    // 声明和赋值（& 是可选的）
    void (*funcPtr)() = normalFunction;  // 可以省略 &
    void (*funcPtr2)() = &normalFunction; // 也可以加上 &
    
    // 调用（* 是可选的）
    funcPtr();        // 可以直接调用
    (*funcPtr)();     // 也可以解引用后调用
    
    return 0;
}
```

# lambda 表达式，std::bind 和 std::function

| 特性              | Lambda 表达式      | std::bind              | std::function        |
| ----------------- | ------------------ | ---------------------- | -------------------- |
| **本质**          | 匿名函数对象       | 参数绑定器             | 通用包装器           |
| **创建内容**      | 新的可调用对象     | 现有可调用对象的适配器 | 可调用对象的容器     |
| **编译时/运行时** | 编译时多态         | 编译时生成适配器       | 运行时多态           |
| **性能**          | 通常最高（可内联） | 中等                   | 较低（虚函数调用）   |
| **主要用途**      | 定义匿名函数逻辑   | 适配函数参数接口       | 存储和传递可调用对象 |

## Lambda 表达式：创建新的可调用对象

**本质**：编译器生成的匿名函数对象（仿函数）

```cpp
// Lambda 示例
auto lambda = [](int a, int b) { return a + b; };
int result = lambda(3, 4); // 返回 7

// 编译器大致生成类似这样的代码
class __Lambda_123 {
public:
    int operator()(int a, int b) const {
        return a + b;
    }
};
__Lambda_123 lambda;
```

**特点**：
- 定义全新的函数逻辑
- 可以捕获上下文变量
- 编译时确定类型，性能最优
- 现代C++首选方式

## std::bind：参数绑定和适配器

**本质**：创建现有函数的适配器，固定部分参数

```cpp
#include <functional>

// 原始函数
void print_sum(int a, int b, int c) {
    std::cout << a + b + c << std::endl;
}

// 使用 bind 固定部分参数
auto bound_func = std::bind(print_sum, 10, std::placeholders::_1, std::placeholders::_2);
bound_func(20, 30); // 相当于 print_sum(10, 20, 30) → 输出60

// 重新排序参数
auto reordered = std::bind(print_sum, std::placeholders::_2, std::placeholders::_1, 100);
reordered(50, 200); // 相当于 print_sum(200, 50, 100) → 输出350
```

**特点**：
- 适配现有函数，不创建新逻辑
- 主要用于参数绑定和重新排序
- 在现代C++中逐渐被Lambda替代

## std::function：通用包装器

**本质**：类型擦除的容器，可以存储任何可调用对象

```cpp
#include <functional>

// 存储不同类型的可调用对象
std::function<int(int, int)> func;

// 存储Lambda
func = [](int a, int b) { return a * b; };
std::cout << func(3, 4); // 输出12

// 存储函数指针
int add(int a, int b) { return a + b; }
func = add;
std::cout << func(3, 4); // 输出7

// 存储bind结果
auto bound = std::bind(add, std::placeholders::_1, 10);
func = bound;
std::cout << func(5); // 输出15 (5 + 10)
```

**特点**：
- 运行时多态，可以存储任何签名匹配的可调用对象
- 有性能开销（虚函数调用+可能的内存分配）
- 用于需要统一接口的场景

## 实际应用场景对比

### 场景1：回调函数注册

```cpp
// 使用 std::function 作为回调接口（最合适）
class Button {
    std::function<void()> onClick;
public:
    void setCallback(std::function<void()> callback) {
        onClick = std::move(callback);
    }
    void click() { if (onClick) onClick(); }
};

// 使用 Lambda（推荐）
button.setCallback([]() { 
    std::cout << "Button clicked!"; 
});

// 使用 std::bind（旧式风格）
void handleClick(int times) { /*...*/ }
button.setCallback(std::bind(handleClick, 5));
```

### 场景2：参数适配

```cpp
// 有一个旧式API
void old_api(int a, const std::string& b, double c) {
    // 复杂逻辑
}

// 需要适配到新接口：void new_api(const std::string&, int)

// 使用 std::bind（适合参数适配）
auto adapted = std::bind(old_api, 
    std::placeholders::_2,  // 第二个参数作为a
    std::placeholders::_1,  // 第一个参数作为b  
    3.14                    // 固定c=3.14
);

new_api("hello", 42); // 内部调用 old_api(42, "hello", 3.14)

// 使用 Lambda（更现代的方式）
auto adapted_lambda = [](const std::string& b, int a) {
    old_api(a, b, 3.14);
};
```

### 场景3：算法中的谓词

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// 使用 Lambda（最简洁）
std::remove_if(numbers.begin(), numbers.end(), 
    [threshold = 3](int x) { return x > threshold; });

// 使用 std::function（需要类型擦除时）
std::function<bool(int)> predicate = [](int x) { return x > 3; };
std::remove_if(numbers.begin(), numbers.end(), predicate);

// 使用 std::bind（较繁琐）
bool greater_than(int x, int threshold) { return x > threshold; }
auto bound = std::bind(greater_than, std::placeholders::_1, 3);
std::remove_if(numbers.begin(), numbers.end(), bound);
```

## 性能比较

```cpp
// 测试代码示例
void benchmark() {
    // 1. 直接调用（最快）
    auto direct = [](int x) { return x * x; };
    
    // 2. Lambda + std::function（有开销）
    std::function<int(int)> wrapped = direct;
    
    // 3. std::bind（中等开销）
    auto bound = std::bind(direct, std::placeholders::_1);
    
    // 性能: 直接调用 > Lambda > std::bind > std::function
}
```

## 现代C++的最佳实践

1. **优先使用Lambda表达式**
   - 语法更简洁清晰
   - 性能更好
   - 类型安全

2. **谨慎使用std::bind**
   - 主要在需要参数重排序时使用
   - 适配旧代码接口时使用
   - 新代码中通常可以用Lambda替代

3. **在需要类型擦除时使用std::function**
   - 存储回调函数
   - 作为函数参数接受各种可调用对象
   - 实现运行时多态

# 指针数组 (Array of Pointers)

指针数组是一个**数组**，其**元素都是指针**。

```cpp
type *array_name[size];
```

- 首先是一个数组
- 数组的每个元素都是指针
- 在内存中占用 `size * sizeof(pointer)` 的空间

```cpp
#include <iostream>

int main() {
    int a = 10, b = 20, c = 30;
    
    // 声明并初始化指针数组
    int *ptr_array[3] = {&a, &b, &c};
    
    // 访问指针数组的元素
    std::cout << "指针数组元素:" << std::endl;
    for(int i = 0; i < 3; i++) {
        std::cout << "ptr_array[" << i << "] = " << ptr_array[i] 
                  << ", *ptr_array[" << i << "] = " << *ptr_array[i] << std::endl;
    }
    
    return 0;
}
```

输出结果：
```
指针数组元素:
ptr_array[0] = 0x7ffd5a1a2a0c, *ptr_array[0] = 10
ptr_array[1] = 0x7ffd5a1a2a10, *ptr_array[1] = 20
ptr_array[2] = 0x7ffd5a1a2a14, *ptr_array[2] = 30
```

```cpp
#include <iostream>

int main() {
    // 指针数组存储多个字符串
    const char *fruits[] = {"Apple", "Banana", "Cherry", "Date"};
    
    std::cout << "水果列表:" << std::endl;
    for(int i = 0; i < 4; i++) {
        std::cout << i+1 << ". " << fruits[i] << std::endl;
    }
    
    return 0;
}
```

## 指针数组作为函数参数

```cpp
#include <iostream>

void printStrings(const char *strings[], int count) {
    for(int i = 0; i < count; i++) {
        std::cout << strings[i] << std::endl;
    }
}

int main() {
    const char *fruits[] = {"Apple", "Banana", "Cherry"};
    printStrings(fruits, 3);
    return 0;
}
```

# 数组指针 (Pointer to Array)

数组指针是一个**指针**，它**指向一个数组**。

```cpp
type (*pointer_name)[size];
```

- 首先是一个指针
- 指向一个特定大小的数组
- 对指针进行加减运算时，会移动整个数组的大小

```cpp
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 声明数组指针并指向数组
    int (*arr_ptr)[5] = &arr;
    
    std::cout << "数组指针演示:" << std::endl;
    std::cout << "arr_ptr = " << arr_ptr << std::endl;
    std::cout << "*arr_ptr = " << *arr_ptr << std::endl;
    std::cout << "**arr_ptr = " << **arr_ptr << std::endl;
    
    // 通过数组指针访问数组元素
    std::cout << "数组元素:" << std::endl;
    for(int i = 0; i < 5; i++) {
        std::cout << "(*arr_ptr)[" << i << "] = " << (*arr_ptr)[i] << std::endl;
    }
    
    return 0;
}
```

输出结果：
```
数组指针演示:
arr_ptr = 0x7ffc5e2a8a20
*arr_ptr = 0x7ffc5e2a8a20
**arr_ptr = 1
数组元素:
(*arr_ptr)[0] = 1
(*arr_ptr)[1] = 2
(*arr_ptr)[2] = 3
(*arr_ptr)[3] = 4
(*arr_ptr)[4] = 5
```

## 数组指针作为函数参数

```cpp
#include <iostream>

void printMatrix(int (*matrix)[3], int rows) {
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < 3; j++) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    printMatrix(matrix, 2);
    return 0;
}
```