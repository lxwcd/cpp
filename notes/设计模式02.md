C++ 设计模式

# 建造者模式

建造者模式就像是一个**专业的乐高大师**，它帮助我们将复杂对象的构建过程分解成多个步骤，使得同样的构建过程可以创建不同的表示。

想象一下要建造一座房子，房子有很多部分：地基、墙壁、屋顶、门窗等。建造者模式就是将这个建造过程分解，让不同的建造者可以按照相同的步骤建造出不同风格的房子。

- **产品（Product）**：要构建的复杂对象（如房子）
- **建造者（Builder）**：定义构建产品的各个步骤的接口
- **具体建造者（Concrete Builder）**：实现构建步骤，提供产品的具体实现
- **指挥者（Director）**：使用建造者接口来构建产品，控制构建过程

## 房子建造示例

### 1. 产品类：房子

```cpp
#include <iostream>
#include <string>
#include <vector>

// 产品：房子
class House {
public:
    void setFoundation(const std::string& foundation) {
        foundation_ = foundation;
    }
    
    void setWalls(const std::vector<std::string>& walls) {
        walls_ = walls;
    }
    
    void setRoof(const std::string& roof) {
        roof_ = roof;
    }
    
    void setWindows(const std::vector<std::string>& windows) {
        windows_ = windows;
    }
    
    void setDoors(const std::vector<std::string>& doors) {
        doors_ = doors;
    }
    
    void show() const {
        std::cout << "房子组成部分：" << std::endl;
        std::cout << "地基: " << foundation_ << std::endl;
        
        std::cout << "墙壁: ";
        for (const auto& wall : walls_) {
            std::cout << wall << " ";
        }
        std::cout << std::endl;
        
        std::cout << "屋顶: " << roof_ << std::endl;
        
        std::cout << "窗户: ";
        for (const auto& window : windows_) {
            std::cout << window << " ";
        }
        std::cout << std::endl;
        
        std::cout << "门: ";
        for (const auto& door : doors_) {
            std::cout << door << " ";
        }
        std::cout << std::endl;
    }

private:
    std::string foundation_;
    std::vector<std::string> walls_;
    std::string roof_;
    std::vector<std::string> windows_;
    std::vector<std::string> doors_;
};
```

### 2. 抽象建造者

```cpp
// 抽象建造者
class HouseBuilder {
public:
    virtual ~HouseBuilder() = default;
    
    virtual void buildFoundation() = 0;
    virtual void buildWalls() = 0;
    virtual void buildRoof() = 0;
    virtual void buildWindows() = 0;
    virtual void buildDoors() = 0;
    
    House getHouse() {
        return house_;
    }

protected:
    House house_;
};
```

### 3. 具体建造者：普通房子建造者

```cpp
// 具体建造者：普通房子
class SimpleHouseBuilder : public HouseBuilder {
public:
    void buildFoundation() override {
        house_.setFoundation("普通混凝土地基");
    }
    
    void buildWalls() override {
        house_.setWalls({"砖墙", "砖墙", "砖墙", "砖墙"});
    }
    
    void buildRoof() override {
        house_.setRoof("瓦片屋顶");
    }
    
    void buildWindows() override {
        house_.setWindows({"普通玻璃窗", "普通玻璃窗", "普通玻璃窗"});
    }
    
    void buildDoors() override {
        house_.setDoors({"木门"});
    }
};
```

### 4. 具体建造者：豪华房子建造者

```cpp
// 具体建造者：豪华房子
class LuxuryHouseBuilder : public HouseBuilder {
public:
    void buildFoundation() override {
        house_.setFoundation("加固混凝土地基");
    }
    
    void buildWalls() override {
        house_.setWalls({"大理石墙", "大理石墙", "大理石墙", "大理石墙"});
    }
    
    void buildRoof() override {
        house_.setRoof("琉璃瓦屋顶");
    }
    
    void buildWindows() override {
        house_.setWindows({"落地窗", "落地窗", "观景窗", "天窗"});
    }
    
    void buildDoors() override {
        house_.setDoors({"防盗门", "玻璃推拉门"});
    }
};
```

### 5. 指挥者：建筑工程师

```cpp
// 指挥者
class ConstructionEngineer {
public:
    void setBuilder(HouseBuilder* builder) {
        builder_ = builder;
    }
    
    House constructHouse() {
        builder_->buildFoundation();
        builder_->buildWalls();
        builder_->buildRoof();
        builder_->buildWindows();
        builder_->buildDoors();
        return builder_->getHouse();
    }

private:
    HouseBuilder* builder_;
};
```

### 6. 使用示例

```cpp
int main() {
    ConstructionEngineer engineer;
    
    // 建造普通房子
    SimpleHouseBuilder simpleBuilder;
    engineer.setBuilder(&simpleBuilder);
    House simpleHouse = engineer.constructHouse();
    
    std::cout << "普通房子：" << std::endl;
    simpleHouse.show();
    
    std::cout << "\n====================\n" << std::endl;
    
    // 建造豪华房子
    LuxuryHouseBuilder luxuryBuilder;
    engineer.setBuilder(&luxuryBuilder);
    House luxuryHouse = engineer.constructHouse();
    
    std::cout << "豪华房子：" << std::endl;
    luxuryHouse.show();
    
    return 0;
}
```

## 建造者模式的核心优势

### 1. 分离构建过程和表示
- 构建过程（ConstructionEngineer）保持不变
- 最终表示（House）可以根据不同的建造者而变化

### 2. 更好的控制构建过程
- 指挥者确保构建步骤按照正确的顺序执行
- 可以精细控制构建过程的每个步骤

### 3. 代码复用性高
- 相同的构建过程可以创建不同的产品表示
- 添加新的建造者很容易，无需修改现有代码

## 建造者模式 vs 工厂模式

| 工厂模式           | 建造者模式         |
| ------------------ | ------------------ |
| 一次性创建完整对象 | 分步骤构建复杂对象 |
| 适合创建简单对象   | 适合创建复杂对象   |
| 不关心构建过程     | 精确控制构建过程   |
| 返回具体产品       | 返回最终构建的产品 |

## 总结

建造者模式就像是一个**专业的建筑团队**：

1. **产品（House）**：要建造的房子
2. **建造者（HouseBuilder）**：建筑工人，知道如何建造各个部分
3. **指挥者（ConstructionEngineer）**：建筑师，指导建造过程

**适用场景**：
- 需要创建复杂对象，对象由多个部分组成
- 对象的构建过程需要保持不变，但表示可以不同
- 需要精确控制对象的构建过程

**优点**：
- 封装了复杂对象的构建过程
- 允许通过不同的具体建造者改变产品的内部表示
- 更好地控制构建过程

**缺点**：
- 产品必须有共同点，限制在同一个接口或产品族
- 如果产品之间的差异很大，建造者模式会变得很复杂

建造者模式让复杂对象的创建变得像搭积木一样简单有序！

# 原型模式 (Prototype)

原型模式就像是一个**细胞分裂**的过程，它允许你通过复制现有对象来创建新对象，而不是通过新建类的方式。这种模式在需要创建相似对象但初始化成本较高时特别有用。

想象一下有一个非常复杂的对象，创建这个对象需要很多步骤和资源。现在你需要创建多个类似的对象。

1. **传统方式**：每次都重新执行复杂的创建过程
2. **原型模式**：复制一个现有的对象，然后根据需要稍作修改

- **原型接口（Prototype）**：声明克隆方法的接口
- **具体原型（Concrete Prototype）**：实现克隆方法的具体类
- **客户端（Client）**：通过复制原型来创建新对象

## 1. 原型接口

```cpp
#include <iostream>
#include <string>
#include <memory>

// 原型接口
class Prototype {
public:
    virtual ~Prototype() = default;
    virtual std::unique_ptr<Prototype> clone() const = 0;
    virtual void print() const = 0;
    virtual void setValue(const std::string& value) = 0;
};
```

## 2. 具体原型类

```cpp
// 具体原型类
class ConcretePrototype : public Prototype {
public:
    ConcretePrototype(const std::string& value, int number) 
        : value_(value), number_(number) {
        std::cout << "创建原型对象，成本较高的操作..." << std::endl;
    }
    
    // 拷贝构造函数（用于克隆）
    ConcretePrototype(const ConcretePrototype& other)
        : value_(other.value_), number_(other.number_) {
        std::cout << "通过克隆创建新对象（成本低）" << std::endl;
    }
    
    std::unique_ptr<Prototype> clone() const override {
        return std::make_unique<ConcretePrototype>(*this);
    }
    
    void print() const override {
        std::cout << "值: " << value_ << ", 数字: " << number_ << std::endl;
    }
    
    void setValue(const std::string& value) override {
        value_ = value;
    }
    
    void setNumber(int number) {
        number_ = number;
    }

private:
    std::string value_;
    int number_;
};
```

## 3. 使用示例

```cpp
int main() {
    // 创建一个原型对象（成本较高）
    std::cout << "创建原型对象：" << std::endl;
    ConcretePrototype original("初始值", 100);
    original.print();
    
    std::cout << "\n通过克隆创建新对象：" << std::endl;
    // 通过克隆创建新对象（成本低）
    auto clone1 = original.clone();
    clone1->print();
    
    std::cout << "\n修改克隆对象：" << std::endl;
    // 修改克隆对象
    clone1->setValue("修改后的值");
    clone1->print();
    
    std::cout << "\n再次克隆：" << std::endl;
    // 再次克隆
    auto clone2 = original.clone();
    clone2->print();
    
    // 原始对象保持不变
    std::cout << "\n原始对象保持不变：" << std::endl;
    original.print();
    
    return 0;
}
```

## 原型模式的核心优势

1. 避免重复初始化成本
当对象创建过程很复杂或成本很高时，通过复制现有对象可以节省大量资源。

2. 动态配置对象
可以在运行时通过复制和修改来创建不同配置的对象。

3. 简化对象创建
客户端代码不需要知道对象的具体类，只需要知道原型接口。

## 原型模式 vs 其他创建型模式

| 模式           | 特点                       | 适用场景                         |
| -------------- | -------------------------- | -------------------------------- |
| **原型模式**   | 通过复制现有对象创建新对象 | 对象创建成本高，需要相似对象     |
| **工厂模式**   | 通过工厂方法创建新对象     | 需要隐藏对象创建细节             |
| **建造者模式** | 分步骤构建复杂对象         | 对象有很多组成部分，构建过程复杂 |
| **单例模式**   | 确保只有一个实例           | 需要全局唯一对象                 |

## 总结

原型模式就像是一个**生物克隆**过程：

1. **原型接口**：定义了克隆的能力
2. **具体原型**：实现克隆的具体对象
3. **客户端**：通过复制来创建新对象

**适用场景**：
- 对象创建成本高，需要创建相似对象时
- 需要避免使用与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合时

**优点**：
- 可以动态添加和删除产品
- 避免重复执行高成本的初始化操作
- 提供简化的创建结构

**缺点**：
- 每个类都需要实现克隆方法
- 深拷贝可能比较复杂，特别是对象包含循环引用时

# 适配器模式

适配器模式就像是一个**电源转换插头**，它让原本不兼容的接口能够一起工作。想象一下从国外买了一个电器，插头形状和国内的插座不匹配，这时需要一个转换插头来让这个电器能在国内使用。

适配器模式将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。

- **目标接口（Target）**：客户端期望的接口
- **适配者（Adaptee）**：需要被适配的现有接口
- **适配器（Adapter）**：将适配者接口转换成目标接口

## 示例：电源插头转换

### 1. 现有接口（欧洲插头）

```cpp
#include <iostream>
#include <string>

// 欧洲插头（需要被适配的类）
class EuropeanPlug {
public:
    virtual std::string supplyPower() const {
        return "提供220V交流电";
    }
    
    virtual ~EuropeanPlug() = default;
};
```

### 2. 目标接口（中国插座）

```cpp
// 中国插座（目标接口）
class ChineseSocket {
public:
    virtual std::string providePower() const {
        return "提供220V交流电";
    }
    
    virtual ~ChineseSocket() = default;
};
```

### 3. 适配器（转换插头）

```cpp
// 适配器：将欧洲插头适配到中国插座
class PlugAdapter : public ChineseSocket {
private:
    EuropeanPlug* europeanPlug;
    
public:
    PlugAdapter(EuropeanPlug* plug) : europeanPlug(plug) {}
    
    std::string providePower() const override {
        // 转换接口：调用欧洲插头的方法，但提供中国插座期望的接口
        std::string power = europeanPlug->supplyPower();
        return "通过转换插头：" + power;
    }
    
    ~PlugAdapter() {
        delete europeanPlug;
    }
};
```

### 4. 使用示例

```cpp
int main() {
    // 创建欧洲插头
    EuropeanPlug* europeanPlug = new EuropeanPlug();
    std::cout << "欧洲插头: " << europeanPlug->supplyPower() << std::endl;
    
    // 创建适配器，让欧洲插头能在中国插座上使用
    PlugAdapter adapter(europeanPlug);
    std::cout << "转换后: " << adapter.providePower() << std::endl;
    
    return 0;
}
```

## 示例：数据格式转换

### 1. 现有接口（XML格式）

```cpp
// XML数据处理类（需要被适配的类）
class XMLDataProcessor {
public:
    std::string processXML(const std::string& xmlData) {
        std::cout << "处理XML数据: " << xmlData << std::endl;
        return "<result>处理成功</result>";
    }
};
```

### 2. 目标接口（JSON格式）

```cpp
// JSON数据处理接口（目标接口）
class JSONProcessor {
public:
    virtual std::string processJSON(const std::string& jsonData) = 0;
    virtual ~JSONProcessor() = default;
};
```

### 3. 适配器（XML转JSON）

```cpp
// 适配器：将XML处理器适配到JSON接口
class XMLToJSONAdapter : public JSONProcessor {
private:
    XMLDataProcessor xmlProcessor;
    
public:
    std::string processJSON(const std::string& jsonData) override {
        // 将JSON转换为XML（简化示例）
        std::string xmlData = convertJSONtoXML(jsonData);
        
        // 使用XML处理器处理数据
        std::string result = xmlProcessor.processXML(xmlData);
        
        // 将XML结果转换回JSON
        return convertXMLtoJSON(result);
    }
    
private:
    std::string convertJSONtoXML(const std::string& jsonData) {
        // 简化的JSON转XML逻辑
        std::cout << "将JSON转换为XML: " << jsonData << std::endl;
        return "<data>" + jsonData + "</data>";
    }
    
    std::string convertXMLtoJSON(const std::string& xmlData) {
        // 简化的XML转JSON逻辑
        std::cout << "将XML转换为JSON: " << xmlData << std::endl;
        return "{\"result\": \"处理成功\"}";
    }
};
```

### 4. 使用示例

```cpp
int main() {
    // 创建适配器
    XMLToJSONAdapter adapter;
    
    // 使用JSON接口处理数据
    std::string jsonData = "{\"name\": \"张三\", \"age\": 30}";
    std::string result = adapter.processJSON(jsonData);
    
    std::cout << "最终结果: " << result << std::endl;
    
    return 0;
}
```

## 适配器模式的应用场景

### 1. 第三方库集成

```cpp
// 第三方库的接口
class ThirdPartyLibrary {
public:
    void specificRequest(const std::string& data) {
        std::cout << "第三方库处理: " << data << std::endl;
    }
};

// 我们的系统接口
class OurSystem {
public:
    virtual void processData(const std::string& data) = 0;
    virtual ~OurSystem() = default;
};

// 适配器：让第三方库符合我们的系统接口
class LibraryAdapter : public OurSystem {
private:
    ThirdPartyLibrary thirdPartyLib;
    
public:
    void processData(const std::string& data) override {
        // 转换接口，调用第三方库的方法
        thirdPartyLib.specificRequest("适配后的数据: " + data);
    }
};
```

### 2. 新旧系统兼容

```cpp
// 旧系统接口
class LegacySystem {
public:
    std::string oldFormatRequest(int id, const std::string& name) {
        return "ID: " + std::to_string(id) + ", Name: " + name;
    }
};

// 新系统接口
class ModernSystem {
public:
    virtual std::string newFormatRequest(const std::string& jsonData) = 0;
    virtual ~ModernSystem() = default;
};

// 适配器：让旧系统支持新接口
class LegacyAdapter : public ModernSystem {
private:
    LegacySystem legacySystem;
    
public:
    std::string newFormatRequest(const std::string& jsonData) override {
        // 解析JSON数据（简化）
        // 假设JSON格式为: {"id": 123, "name": "John"}
        size_t idPos = jsonData.find("\"id\":");
        size_t namePos = jsonData.find("\"name\":");
        
        int id = 0;
        std::string name;
        
        if (idPos != std::string::npos && namePos != std::string::npos) {
            // 简化的JSON解析
            id = std::stoi(jsonData.substr(idPos + 5, 3));
            name = jsonData.substr(namePos + 8, 4);
        }
        
        // 调用旧系统接口
        return legacySystem.oldFormatRequest(id, name);
    }
};
```

## 总结

适配器模式就像是一个**万能转换器**：

1. **目标接口（Target）**：你需要的接口（如中国插座）
2. **适配者（Adaptee）**：现有的接口（如欧洲插头）
3. **适配器（Adapter）**：转换器（如电源转换插头）

**适用场景**：
- 需要使用现有的类，但其接口与你的需求不匹配时
- 想要创建一个可重用的类，与不相关的类或不可预见的类协同工作时
- 需要多个子类来实现接口，但只想要匹配它们的父类时

**优点**：
- 可以让任何两个没有关联的类一起运行
- 提高了类的复用性
- 增加了类的透明度
- 灵活性好

**缺点**：
- 过多使用适配器会让系统变得混乱
- 某些语言（如Java、C#）不支持多重继承，类适配器有一定限制

# 装饰器模式

装饰器模式就像给**手机加配件**的过程。有一个基础手机，可以不断添加保护壳、贴膜、镜头配件等，每个配件都增强了手机的功能，但手机的核心功能保持不变。

装饰器模式允许**动态地给对象添加新功能**，而不改变其结构。它通过将对象包装在装饰器类中来实现这一功能，提供了比继承更灵活的功能扩展方式。

- **组件接口（Component）**：定义对象的通用接口
- **具体组件（Concrete Component）**：需要被装饰的基础对象
- **装饰器（Decorator）**：持有一个组件对象并定义与组件接口一致的接口
- **具体装饰器（Concrete Decorator）**：实际添加功能的装饰器

## 咖啡加料示例

### 1. 组件接口：饮料

```cpp
#include <iostream>
#include <string>
#include <memory>

// 组件接口：饮料
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual std::string getDescription() const = 0;
    virtual double cost() const = 0;
};
```

### 2. 具体组件：基础咖啡

```cpp
// 具体组件：浓缩咖啡
class Espresso : public Beverage {
public:
    std::string getDescription() const override {
        return "浓缩咖啡";
    }
    
    double cost() const override {
        return 2.0; // 基础价格
    }
};

// 具体组件：黑咖啡
class HouseBlend : public Beverage {
public:
    std::string getDescription() const override {
        return "黑咖啡";
    }
    
    double cost() const override {
        return 1.5; // 基础价格
    }
};
```

### 3. 装饰器基类

```cpp
// 装饰器基类
class CondimentDecorator : public Beverage {
protected:
    std::unique_ptr<Beverage> beverage;
    
public:
    CondimentDecorator(std::unique_ptr<Beverage> beverage) 
        : beverage(std::move(beverage)) {}
    
    // 装饰器委托给被装饰的对象
    std::string getDescription() const override {
        return beverage->getDescription();
    }
    
    double cost() const override {
        return beverage->cost();
    }
};
```

### 4. 具体装饰器：各种调料

```cpp
// 具体装饰器：摩卡
class Mocha : public CondimentDecorator {
public:
    Mocha(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 摩卡";
    }
    
    double cost() const override {
        return beverage->cost() + 0.5;
    }
};

// 具体装饰器：牛奶
class Milk : public CondimentDecorator {
public:
    Milk(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 牛奶";
    }
    
    double cost() const override {
        return beverage->cost() + 0.3;
    }
};

// 具体装饰器：奶泡
class Whip : public CondimentDecorator {
public:
    Whip(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 奶泡";
    }
    
    double cost() const override {
        return beverage->cost() + 0.4;
    }
};

// 具体装饰器：巧克力
class Chocolate : public CondimentDecorator {
public:
    Chocolate(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 巧克力";
    }
    
    double cost() const override {
        return beverage->cost() + 0.6;
    }
};
```

### 5. 使用示例

```cpp
int main() {
    // 1. 基础浓缩咖啡
    std::cout << "=== 基础咖啡 ===" << std::endl;
    auto espresso = std::make_unique<Espresso>();
    std::cout << espresso->getDescription() << " 价格: ¥" << espresso->cost() << std::endl;
    
    // 2. 浓缩咖啡 + 摩卡 + 奶泡
    std::cout << "\n=== 加料咖啡 ===" << std::endl;
    auto fancyCoffee = std::make_unique<Mocha>(
        std::make_unique<Whip>(
            std::make_unique<Espresso>()
        )
    );
    std::cout << fancyCoffee->getDescription() << " 价格: ¥" << fancyCoffee->cost() << std::endl;
    
    // 3. 黑咖啡 + 牛奶 + 巧克力 + 奶泡
    std::cout << "\n=== 豪华咖啡 ===" << std::endl;
    auto deluxeCoffee = std::make_unique<Milk>(
        std::make_unique<Chocolate>(
            std::make_unique<Whip>(
                std::make_unique<HouseBlend>()
            )
        )
    );
    std::cout << deluxeCoffee->getDescription() << " 价格: ¥" << deluxeCoffee->cost() << std::endl;
    
    return 0;
}
```

### 链式结构

在装饰器模式中，链式结构是通过**对象组合**和**所有权转移**实现的。每个装饰器对象都包含一个指向被装饰对象的指针，从而形成一条链。

步骤1：创建基础对象

```cpp
auto coffee = make_unique<Espresso>();
```

此时内存结构：
```
coffee → [Espresso对象]
```

步骤2：添加第一个装饰器

```cpp
coffee = make_unique<MilkDecorator>(move(coffee));
```

1. **`move(coffee)`**：
   - 将`coffee`从左值转换为右值引用
   - 表示愿意放弃`coffee`的所有权
   - `coffee`现在处于"可移动但无效"状态

2. **`make_unique<MilkDecorator>(...)`**：
   - 在堆上分配`MilkDecorator`对象
   - 调用`MilkDecorator`构造函数，传入移动后的`coffee`

3. **`MilkDecorator`构造函数**：
   ```cpp
   MilkDecorator(unique_ptr<Beverage> beverage) 
       : beverage(move(beverage)) {
       // 这里将传入的beverage移动到成员变量中
   }
   ```
   - 参数`beverage`接收了外部`coffee`的所有权
   - `move(beverage)`将参数的所有权转移到成员变量`beverage`
   - 现在`MilkDecorator`对象内部的`beverage`成员指向原来的`Espresso`

4. **赋值操作**：
   - `make_unique`返回管理`MilkDecorator`的`unique_ptr`
   - 这个`unique_ptr`赋值给`coffee`变量
   - 现在`coffee`指向新创建的`MilkDecorator`对象

此时内存结构：
```
coffee → [MilkDecorator对象]
               │
               └── beverage → [Espresso对象]
```

步骤3：添加第二个装饰器

```cpp
coffee = make_unique<SugarDecorator>(move(coffee));
```

这个过程与步骤2类似，但关键区别在于：

1. **`move(coffee)`**：
   - 现在`coffee`指向的是`MilkDecorator`对象
   - 移动操作表示愿意放弃`MilkDecorator`的所有权

2. **`SugarDecorator`构造函数**：
   ```cpp
   SugarDecorator(unique_ptr<Beverage> beverage) 
       : beverage(move(beverage)) {
       // 接收MilkDecorator的所有权
   }
   ```
   - 参数`beverage`接收了`MilkDecorator`的所有权
   - 成员变量`beverage`现在指向`MilkDecorator`对象

3. **赋值操作**：
   - `make_unique`返回管理`SugarDecorator`的`unique_ptr`
   - 赋值给`coffee`变量
   - 现在`coffee`指向新创建的`SugarDecorator`对象

此时内存结构：
```
coffee → [SugarDecorator对象]
               │
               └── beverage → [MilkDecorator对象]
                                │
                                └── beverage → [Espresso对象]
```

当调用装饰器链上的方法时，调用会沿着链传递：

```cpp
// SugarDecorator::getDescription()
string getDescription() const override {
    // 先调用被装饰对象的getDescription()
    string desc = beverage->getDescription();
    // 然后添加自己的功能
    return desc + ", 糖";
}

// MilkDecorator::getDescription()
string getDescription() const override {
    // 先调用被装饰对象的getDescription()
    string desc = beverage->getDescription();
    // 然后添加自己的功能
    return desc + ", 牛奶";
}

// Espresso::getDescription()
string getDescription() const override {
    return "浓缩咖啡";
}
```

调用`coffee->getDescription()`时：
1. 调用`SugarDecorator::getDescription()`
2. 它调用`beverage->getDescription()`（即`MilkDecorator::getDescription()`）
3. 它调用`beverage->getDescription()`（即`Espresso::getDescription()`）
4. `Espresso::getDescription()`返回"浓缩咖啡"
5. `MilkDecorator::getDescription()`返回"浓缩咖啡, 牛奶"
6. `SugarDecorator::getDescription()`返回"浓缩咖啡, 牛奶, 糖"

从C++语法角度来看，装饰器模式能形成链式结构的关键在于：

1. **统一的接口**：所有装饰器和被装饰对象都实现相同的接口
2. **组合关系**：装饰器包含一个指向接口的指针/智能指针
3. **移动语义**：使用`std::move`和`std::unique_ptr`实现所有权转移
4. **多态性**：通过基类指针调用派生类的方法


装饰器模式的链式结构是基于以下C++语法特性实现的：

1. **继承和多态**：装饰器和被装饰对象有共同的基类
2. **对象组合**：装饰器包含指向被装饰对象的指针
3. **移动语义**：使用`std::move`转移`std::unique_ptr`的所有权
4. **RAII**：`std::unique_ptr`自动管理内存生命周期
5. **堆分配**：使用`new`或`make_unique`在堆上创建对象

## 装饰器模式的核心优势

1. 动态添加功能
可以在运行时根据需要组合各种功能，而不是在编译时通过继承确定。

2. 避免类爆炸
使用继承时，每增加一种功能组合就需要创建一个新的子类，而装饰器模式避免了这种情况。

3. 符合开闭原则
对扩展开放，对修改关闭。可以添加新的装饰器而不修改现有代码。

## 装饰器模式 vs 继承

| 继承                     | 装饰器模式             |
| ------------------------ | ---------------------- |
| 静态地在编译时添加功能   | 动态地在运行时添加功能 |
| 会导致类爆炸（组合爆炸） | 避免类爆炸，灵活组合   |
| 功能绑定到具体类         | 功能可以独立添加和移除 |
| 修改需要创建新子类       | 可以随时添加新装饰器   |

## 总结

装饰器模式就像给**基础对象穿衣服**：

1. **组件接口**：定义对象的基本功能
2. **具体组件**：基础对象（如裸机手机、基础咖啡）
3. **装饰器**：可以添加的配件（如手机壳、咖啡调料）
4. **具体装饰器**：具体的配件实现

**适用场景**：
- 需要动态、透明地给对象添加职责
- 需要撤销的功能
- 用继承扩展功能不现实时（可能导致子类爆炸）

**优点**：
- 比继承更灵活
- 可以动态添加和移除功能
- 符合开闭原则

**缺点**：
- 会产生很多小对象
- 装饰器顺序会影响结果
- 调试比较复杂
