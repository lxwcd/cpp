
C++ 学习笔记

# =delete
> [C++11之前拷贝禁令：私有化真的“拷贝禁得住”吗？](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484119&idx=1&sn=6f5839f4d31fe7a9994f68cd2e49d076&chksm=c520f888987422dd35e18c27128359280b7e087ef95f4d619efba2bd735acd408a4e898051ab&scene=126&sessionid=1756280232#rd) 

`= delete` 是 C++11 引入的重要特性，它允许显式地禁止某些函数的使用，提供更明确的接口控制和更好的编译错误信息。

```cpp
return_type function_name(parameters) = delete;
```

**优点：**
1. 错误信息更清晰友好
2. 可以在public区域声明，明确表达设计意图
3. 可以应用于任何函数，不仅仅是成员函数
4. 编译时检查，而不是链接时错误


## 禁用拷贝类

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    
    // 禁用拷贝构造函数
    NonCopyable(const NonCopyable&) = delete;
    
    // 禁用拷贝赋值运算符
    NonCopyable& operator=(const NonCopyable&) = delete;
    
    // 允许移动操作
    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
    
    ~NonCopyable() = default;
};
```

## 禁用特定函数重载

```cpp
class MathUtils {
public:
    // 允许double类型的参数
    static double calculate(double value) {
        return value * 2;
    }
    
    // 禁用int类型的参数
    static double calculate(int value) = delete;
    
    // 禁用float类型的参数
    static double calculate(float value) = delete;
};

// 使用示例
int main() {
    MathUtils::calculate(5.0);  // OK
    // MathUtils::calculate(5);   // 错误：int版本被删除
    // MathUtils::calculate(5.0f); // 错误：float版本被删除
    return 0;
}
```

## 禁用隐式转换

```cpp
class SafeInteger {
private:
    int value;
    
public:
    // 允许从int构造
    explicit SafeInteger(int val) : value(val) {}
    
    // 禁用从double构造（防止隐式转换）
    SafeInteger(double) = delete;
    
    // 禁用从bool构造
    SafeInteger(bool) = delete;
    
    int getValue() const { return value; }
};

// 使用示例
int main() {
    SafeInteger si1(42);      // OK
    SafeInteger si2(42.0);    // 错误：double版本被删除
    SafeInteger si3(true);    // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用模板特化

```cpp
template<typename T>
class Container {
public:
    void process(T value) {
        // 通用实现
    }
};

// 禁用void类型的特化
template<>
void Container<void>::process(void) = delete;

// 禁用指针类型的特化
template<typename T>
void Container<T*>::process(T* value) = delete;

// 使用示例
int main() {
    Container<int> ci;
    ci.process(42);  // OK
    
    Container<void> cv;
    // cv.process();   // 错误：void版本被删除
    
    Container<int*> cip;
    int x = 42;
    // cip.process(&x); // 错误：指针版本被删除
    
    return 0;
}
```

## 禁用函数

```cpp
// 通用函数模板
template<typename T>
void processValue(T value) {
    // 通用实现
}

// 禁用特定类型的实例化
void processValue(void*) = delete;
void processValue(const void*) = delete;
void processValue(bool) = delete;

// 使用示例
int main() {
    processValue(42);    // OK：使用模板
    processValue(3.14);  // OK：使用模板
    
    void* ptr = nullptr;
    // processValue(ptr);      // 错误：void*版本被删除
    // processValue(true);     // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用运算符重载

```cpp
class SecureString {
private:
    std::string data;
    
public:
    SecureString(const std::string& str) : data(str) {}
    
    // 允许一些运算符
    SecureString operator+(const SecureString& other) const {
        return SecureString(data + other.data);
    }
    
    // 禁用一些可能不安全的运算符
    bool operator==(const SecureString& other) const = delete;
    bool operator!=(const SecureString& other) const = delete;
    
    // 禁用流运算符（可能泄露数据）
    friend std::ostream& operator<<(std::ostream& os, const SecureString&) = delete;
    friend std::istream& operator>>(std::istream& is, SecureString&) = delete;
};

// 使用示例
int main() {
    SecureString s1("hello"), s2("world");
    SecureString s3 = s1 + s2;  // OK
    
    // if (s1 == s2) {}        // 错误：==被删除
    // std::cout << s1;        // 错误：<<被删除
    
    return 0;
}
```

## 注意事项

1. **删除的函数必须被声明**：你不能删除一个没有声明的函数
2. **删除的函数仍然参与重载决议**：它会被考虑但在选择时被拒绝
3. **构造函数可以被删除**：但需要确保仍有可用的构造方式
4. **析构函数不能被删除**：除非你有特殊的需求和替代方案