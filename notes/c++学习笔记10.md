C++ 学习笔记

# =delete
> [C++11之前拷贝禁令：私有化真的“拷贝禁得住”吗？](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484119&idx=1&sn=6f5839f4d31fe7a9994f68cd2e49d076&chksm=c520f888987422dd35e18c27128359280b7e087ef95f4d619efba2bd735acd408a4e898051ab&scene=126&sessionid=1756280232#rd) 

`= delete` 是 C++11 引入的重要特性，它允许显式地禁止某些函数的使用，提供更明确的接口控制和更好的编译错误信息。

```cpp
return_type function_name(parameters) = delete;
```

**优点：**
1. 错误信息更清晰友好
2. 可以在public区域声明，明确表达设计意图
3. 可以应用于任何函数，不仅仅是成员函数
4. 编译时检查，而不是链接时错误

## 禁用拷贝类

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    
    // 禁用拷贝构造函数
    NonCopyable(const NonCopyable&) = delete;
    
    // 禁用拷贝赋值运算符
    NonCopyable& operator=(const NonCopyable&) = delete;
    
    // 允许移动操作
    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
    
    ~NonCopyable() = default;
};
```

## 禁用特定函数重载

```cpp
class MathUtils {
public:
    // 允许double类型的参数
    static double calculate(double value) {
        return value * 2;
    }
    
    // 禁用int类型的参数
    static double calculate(int value) = delete;
    
    // 禁用float类型的参数
    static double calculate(float value) = delete;
};

// 使用示例
int main() {
    MathUtils::calculate(5.0);  // OK
    // MathUtils::calculate(5);   // 错误：int版本被删除
    // MathUtils::calculate(5.0f); // 错误：float版本被删除
    return 0;
}
```

## 禁用隐式转换

```cpp
class SafeInteger {
private:
    int value;
    
public:
    // 允许从int构造
    explicit SafeInteger(int val) : value(val) {}
    
    // 禁用从double构造（防止隐式转换）
    SafeInteger(double) = delete;
    
    // 禁用从bool构造
    SafeInteger(bool) = delete;
    
    int getValue() const { return value; }
};

// 使用示例
int main() {
    SafeInteger si1(42);      // OK
    SafeInteger si2(42.0);    // 错误：double版本被删除
    SafeInteger si3(true);    // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用模板特化

```cpp
template<typename T>
class Container {
public:
    void process(T value) {
        // 通用实现
    }
};

// 禁用void类型的特化
template<>
void Container<void>::process(void) = delete;

// 禁用指针类型的特化
template<typename T>
void Container<T*>::process(T* value) = delete;

// 使用示例
int main() {
    Container<int> ci;
    ci.process(42);  // OK
    
    Container<void> cv;
    // cv.process();   // 错误：void版本被删除
    
    Container<int*> cip;
    int x = 42;
    // cip.process(&x); // 错误：指针版本被删除
    
    return 0;
}
```

## 禁用函数

```cpp
// 通用函数模板
template<typename T>
void processValue(T value) {
    // 通用实现
}

// 禁用特定类型的实例化
void processValue(void*) = delete;
void processValue(const void*) = delete;
void processValue(bool) = delete;

// 使用示例
int main() {
    processValue(42);    // OK：使用模板
    processValue(3.14);  // OK：使用模板
    
    void* ptr = nullptr;
    // processValue(ptr);      // 错误：void*版本被删除
    // processValue(true);     // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用运算符重载

```cpp
class SecureString {
private:
    std::string data;
    
public:
    SecureString(const std::string& str) : data(str) {}
    
    // 允许一些运算符
    SecureString operator+(const SecureString& other) const {
        return SecureString(data + other.data);
    }
    
    // 禁用一些可能不安全的运算符
    bool operator==(const SecureString& other) const = delete;
    bool operator!=(const SecureString& other) const = delete;
    
    // 禁用流运算符（可能泄露数据）
    friend std::ostream& operator<<(std::ostream& os, const SecureString&) = delete;
    friend std::istream& operator>>(std::istream& is, SecureString&) = delete;
};

// 使用示例
int main() {
    SecureString s1("hello"), s2("world");
    SecureString s3 = s1 + s2;  // OK
    
    // if (s1 == s2) {}        // 错误：==被删除
    // std::cout << s1;        // 错误：<<被删除
    
    return 0;
}
```

## 注意事项

1. **删除的函数必须被声明**：你不能删除一个没有声明的函数
2. **删除的函数仍然参与重载决议**：它会被考虑但在选择时被拒绝
3. **构造函数可以被删除**：但需要确保仍有可用的构造方式
4. **析构函数不能被删除**：除非你有特殊的需求和替代方案

# noexcept
> [noexcept specifier (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/language/noexcept_spec.html) 
> [90%的C++程序员，都答不全noexcept的这两种用法和三大收益](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484073&idx=1&sn=66759d45be723878094a4fe741d0c4b3&chksm=c4735ed0f304d7c6c1da2eaf466543121ab4062eb09189acc2894e53a24be0207d998129fbe0&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 


`noexcept` 是一个**说明符（specifier）** 和**运算符（operator）**，它有两个主要用途：

1.  **作为说明符**：在函数声明中指定该函数**不会抛出任何异常**。
2.  **作为运算符**：在编译时检查一个表达式**是否声明为不抛出异常**，返回一个 `bool` 值。

它的核心目的是在函数和编译器之间建立一份关于异常行为的“契约”，从而允许编译器进行更深层次的优化，并为程序员提供更强的代码安全保障。

## 与 `throw()` 的对比

在 C++11 之前，使用**动态异常规范（Dynamic Exception Specification）** `throw(...)` 来声明函数可能抛出的异常类型。

```cpp
// C++03 的方式（已废弃！）
void old_func() throw(std::runtime_error); // 可能只抛出 runtime_error
void might_throw() throw();                // 承诺不抛出任何异常
```

这种方式存在严重问题：
*   **运行时检查**：编译器必须在运行时检查抛出的异常是否符合规范。如果违反，则会调用 `std::unexpected()`，这通常会导致程序终止。这是一种**运行时开销**。
*   **糟糕的可用性**：如果函数签名中漏掉了某个异常类型，程序就会在运行时崩溃，而不是在编译期报错。
*   **与模板协作困难**：模板函数几乎不可能列出所有可能抛出的异常类型。

`noexcept` 解决了所有这些问题：
*   **编译时契约**：`noexcept` 是一个**编译时承诺**。如果你在一个标记为 `noexcept` 的函数中抛出了异常，程序会立即调用 `std::terminate()` 来终止，**没有任何栈展开（stack unwinding）的保证**。这没有运行时检查开销。
*   **布尔条件**：它可以是无条件的（`noexcept`）或有条件的（`noexcept(expr)`），更加灵活。
*   **优化友好**：编译器可以基于这份“契约”进行大量优化。

## 作为函数说明符（无条件）

声明一个函数保证不会抛出任何异常。

```cpp
// 1. 在函数声明和定义中都要加上 noexcept
void my_function() noexcept; // 声明

void my_function() noexcept { // 定义
    // ... 这个函数绝不会抛出异常
    // 如果内部抛出了异常，程序会直接调用 std::terminate() 终止
}

// 2. 对于构造函数、析构函数、运算符等同样适用
class MyClass {
public:
    MyClass() noexcept;        // 默认构造函数
    ~MyClass() noexcept;       // 析构函数
    MyClass(MyClass&&) noexcept; // 移动构造函数（非常重要！）
    MyClass& operator=(MyClass&&) noexcept; // 移动赋值运算符

    void some_method() noexcept;
};
```

## 条件性 `noexcept`

声明一个函数是否抛出异常取决于某个编译时表达式的结果。

```cpp
template<typename T>
void swap(T& a, T& b) noexcept(noexcept(a.swap(b))) {
    a.swap(b);
}
```

1.  外层的 `noexcept(...)` 是函数说明符，它接受一个布尔表达式。
2.  内层的 `noexcept(a.swap(b))` 是 `noexcept` 运算符。它在编译时计算表达式 `a.swap(b)` 是否声明为不抛出异常。
3.  如果 `a.swap(b)` 是 `noexcept` 的，那么 `noexcept(noexcept(a.swap(b)))` 就等价于 `noexcept(true)`，即整个 `swap` 函数也是 `noexcept` 的。
4.  否则，等价于 `noexcept(false)`。

这常用于模板元编程，让模板函数根据其模板参数的类型特性自动继承其异常规范。

## 作为运算符

在编译时查询一个表达式是否可能抛出异常。
不真的执行表达式。

```cpp
void non_except_func() noexcept {}
void except_func() {}

int main() {
    // noexcept(expression) 返回 bool
    std::cout << std::boolalpha;
    std::cout << noexcept(non_except_func()) << std::endl; // 输出: true
    std::cout << noexcept(except_func()) << std::endl;     // 输出: false

    int x = 10;
    std::cout << noexcept(x + 5) << std::endl;             // 输出: true (基本类型的操作通常不抛出)

    // 常用于 static_assert 或 if constexpr 中进行编译期检查
    static_assert(noexcept(non_except_func()), "This function should be noexcept!");

    return 0;
}
```

## 使用场景

### 移动语义和 STL 优化

这是 `noexcept` **最重要的应用场景**。STL 容器（如 `std::vector`）在重新分配内存（reallocate）时，需要将旧元素移动或拷贝到新内存中。

为了保证**强异常安全保证**（操作失败时不会改变原始状态），容器必须遵循：
*   如果元素的**移动构造函数是 `noexcept` 的**，容器会安全地使用它，因为你知道它不会失败。
*   否则，容器会**保守地使用拷贝构造函数**，因为拷贝通常更慢但能保证异常安全。

```cpp
class MyClass {
public:
    // 关键的移动构造函数！
    MyClass(MyClass&& other) noexcept { ... } // <-- 这个 noexcept 会让 vector 使用移动而非拷贝

    // 如果没有 noexcept，vector 在扩容时会被迫进行拷贝，性能下降！
    // MyClass(MyClass&& other) { ... } // 没有 noexcept，对 vector 不友好
};

int main() {
    std::vector<MyClass> vec;
    // ... 填充 vec
    vec.push_back(MyClass{}); // 如果 vector 需要扩容，noexcept 在此决定是移动还是拷贝旧元素
    return 0;
}
```

**最佳实践：为所有的移动构造函数和移动赋值运算符加上 `noexcept`。**

### 析构函数

**析构函数默认就是 `noexcept` 的**，除非显式地将其标记为 `noexcept(false)`。

在析构函数中抛出异常是极其危险的，很容易导致程序直接终止。所以你应该永远避免从析构函数中抛出异常。让它们保持默认的 `noexcept` 状态是最好的。

```cpp
~MyClass() { ... } // 这实际上是 ~MyClass() noexcept(true) { ... }
```

### 默认和删除

可以对特殊成员函数使用 `= default` 的同时指定异常规范。

```cpp
class MyClass {
public:
    ~MyClass() noexcept = default; // 显式声明默认析构为 noexcept
    MyClass(MyClass&&) noexcept = default; // 显式声明默认移动构造为 noexcept
    MyClass& operator=(MyClass&&) noexcept = default;

    // 也可以删除
    MyClass(const MyClass&) noexcept = delete;
};
```

## 总结与决策流程

| 场景                            | 是否使用 `noexcept`             | 理由                                                                         |
| :------------------------------ | :------------------------------ | :--------------------------------------------------------------------------- |
| **移动构造函数/移动赋值运算符** | **必须使用**                    | 使 STL 容器能高效地使用移动操作，极大提升性能。                              |
| **析构函数**                    | **通常不写（隐式 `noexcept`）** | 默认就是 `noexcept`。绝不应在析构函数中抛出异常。                            |
| **简单、不会失败的函数**        | **推荐使用**                    | 如 getters、简单计算等。给编译器优化机会，明确契约。                         |
| **函数会调用可能抛出的代码**    | **避免使用**                    | 如果你无法保证函数内部的所有操作都不抛出，就不要用。否则会直接 `terminate`。 |
| **模板函数**                    | **考虑使用条件 `noexcept`**     | 根据模板参数的特性来动态决定，非常强大。                                     |
| **遗留代码或第三方库接口**      | **谨慎使用**                    | 确保你完全了解其异常行为后再添加。                                           |