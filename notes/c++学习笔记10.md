C++ 学习笔记

# =delete
> [C++11之前拷贝禁令：私有化真的“拷贝禁得住”吗？](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484119&idx=1&sn=6f5839f4d31fe7a9994f68cd2e49d076&chksm=c520f888987422dd35e18c27128359280b7e087ef95f4d619efba2bd735acd408a4e898051ab&scene=126&sessionid=1756280232#rd) 

`= delete` 是 C++11 引入的重要特性，它允许显式地禁止某些函数的使用，提供更明确的接口控制和更好的编译错误信息。

```cpp
return_type function_name(parameters) = delete;
```

**优点：**
1. 错误信息更清晰友好
2. 可以在public区域声明，明确表达设计意图
3. 可以应用于任何函数，不仅仅是成员函数
4. 编译时检查，而不是链接时错误

## 禁用拷贝类

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    
    // 禁用拷贝构造函数
    NonCopyable(const NonCopyable&) = delete;
    
    // 禁用拷贝赋值运算符
    NonCopyable& operator=(const NonCopyable&) = delete;
    
    // 允许移动操作
    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
    
    ~NonCopyable() = default;
};
```

## 禁用特定函数重载

```cpp
class MathUtils {
public:
    // 允许double类型的参数
    static double calculate(double value) {
        return value * 2;
    }
    
    // 禁用int类型的参数
    static double calculate(int value) = delete;
    
    // 禁用float类型的参数
    static double calculate(float value) = delete;
};

// 使用示例
int main() {
    MathUtils::calculate(5.0);  // OK
    // MathUtils::calculate(5);   // 错误：int版本被删除
    // MathUtils::calculate(5.0f); // 错误：float版本被删除
    return 0;
}
```

## 禁用隐式转换

```cpp
class SafeInteger {
private:
    int value;
    
public:
    // 允许从int构造
    explicit SafeInteger(int val) : value(val) {}
    
    // 禁用从double构造（防止隐式转换）
    SafeInteger(double) = delete;
    
    // 禁用从bool构造
    SafeInteger(bool) = delete;
    
    int getValue() const { return value; }
};

// 使用示例
int main() {
    SafeInteger si1(42);      // OK
    SafeInteger si2(42.0);    // 错误：double版本被删除
    SafeInteger si3(true);    // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用模板特化

```cpp
template<typename T>
class Container {
public:
    void process(T value) {
        // 通用实现
    }
};

// 禁用void类型的特化
template<>
void Container<void>::process(void) = delete;

// 禁用指针类型的特化
template<typename T>
void Container<T*>::process(T* value) = delete;

// 使用示例
int main() {
    Container<int> ci;
    ci.process(42);  // OK
    
    Container<void> cv;
    // cv.process();   // 错误：void版本被删除
    
    Container<int*> cip;
    int x = 42;
    // cip.process(&x); // 错误：指针版本被删除
    
    return 0;
}
```

## 禁用函数

```cpp
// 通用函数模板
template<typename T>
void processValue(T value) {
    // 通用实现
}

// 禁用特定类型的实例化
void processValue(void*) = delete;
void processValue(const void*) = delete;
void processValue(bool) = delete;

// 使用示例
int main() {
    processValue(42);    // OK：使用模板
    processValue(3.14);  // OK：使用模板
    
    void* ptr = nullptr;
    // processValue(ptr);      // 错误：void*版本被删除
    // processValue(true);     // 错误：bool版本被删除
    
    return 0;
}
```

## 禁用运算符重载

```cpp
class SecureString {
private:
    std::string data;
    
public:
    SecureString(const std::string& str) : data(str) {}
    
    // 允许一些运算符
    SecureString operator+(const SecureString& other) const {
        return SecureString(data + other.data);
    }
    
    // 禁用一些可能不安全的运算符
    bool operator==(const SecureString& other) const = delete;
    bool operator!=(const SecureString& other) const = delete;
    
    // 禁用流运算符（可能泄露数据）
    friend std::ostream& operator<<(std::ostream& os, const SecureString&) = delete;
    friend std::istream& operator>>(std::istream& is, SecureString&) = delete;
};

// 使用示例
int main() {
    SecureString s1("hello"), s2("world");
    SecureString s3 = s1 + s2;  // OK
    
    // if (s1 == s2) {}        // 错误：==被删除
    // std::cout << s1;        // 错误：<<被删除
    
    return 0;
}
```

## 注意事项

1. **删除的函数必须被声明**：你不能删除一个没有声明的函数
2. **删除的函数仍然参与重载决议**：它会被考虑但在选择时被拒绝
3. **构造函数可以被删除**：但需要确保仍有可用的构造方式
4. **析构函数不能被删除**：除非你有特殊的需求和替代方案

# noexcept
> [noexcept specifier (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/language/noexcept_spec.html) 
> [90%的C++程序员，都答不全noexcept的这两种用法和三大收益](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484073&idx=1&sn=66759d45be723878094a4fe741d0c4b3&chksm=c4735ed0f304d7c6c1da2eaf466543121ab4062eb09189acc2894e53a24be0207d998129fbe0&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 


`noexcept` 是一个**说明符（specifier）** 和**运算符（operator）**，它有两个主要用途：

1.  **作为说明符**：在函数声明中指定该函数**不会抛出任何异常**。
2.  **作为运算符**：在编译时检查一个表达式**是否声明为不抛出异常**，返回一个 `bool` 值。

它的核心目的是在函数和编译器之间建立一份关于异常行为的“契约”，从而允许编译器进行更深层次的优化，并为程序员提供更强的代码安全保障。

## 与 `throw()` 的对比

在 C++11 之前，使用**动态异常规范（Dynamic Exception Specification）** `throw(...)` 来声明函数可能抛出的异常类型。

```cpp
// C++03 的方式（已废弃！）
void old_func() throw(std::runtime_error); // 可能只抛出 runtime_error
void might_throw() throw();                // 承诺不抛出任何异常
```

这种方式存在严重问题：
*   **运行时检查**：编译器必须在运行时检查抛出的异常是否符合规范。如果违反，则会调用 `std::unexpected()`，这通常会导致程序终止。这是一种**运行时开销**。
*   **糟糕的可用性**：如果函数签名中漏掉了某个异常类型，程序就会在运行时崩溃，而不是在编译期报错。
*   **与模板协作困难**：模板函数几乎不可能列出所有可能抛出的异常类型。

`noexcept` 解决了所有这些问题：
*   **编译时契约**：`noexcept` 是一个**编译时承诺**。如果你在一个标记为 `noexcept` 的函数中抛出了异常，程序会立即调用 `std::terminate()` 来终止，**没有任何栈展开（stack unwinding）的保证**。这没有运行时检查开销。
*   **布尔条件**：它可以是无条件的（`noexcept`）或有条件的（`noexcept(expr)`），更加灵活。
*   **优化友好**：编译器可以基于这份“契约”进行大量优化。

## 作为函数说明符（无条件）

声明一个函数保证不会抛出任何异常。

```cpp
// 1. 在函数声明和定义中都要加上 noexcept
void my_function() noexcept; // 声明

void my_function() noexcept { // 定义
    // ... 这个函数绝不会抛出异常
    // 如果内部抛出了异常，程序会直接调用 std::terminate() 终止
}

// 2. 对于构造函数、析构函数、运算符等同样适用
class MyClass {
public:
    MyClass() noexcept;        // 默认构造函数
    ~MyClass() noexcept;       // 析构函数
    MyClass(MyClass&&) noexcept; // 移动构造函数（非常重要！）
    MyClass& operator=(MyClass&&) noexcept; // 移动赋值运算符

    void some_method() noexcept;
};
```

## 条件性 `noexcept`

声明一个函数是否抛出异常取决于某个编译时表达式的结果。

```cpp
template<typename T>
void swap(T& a, T& b) noexcept(noexcept(a.swap(b))) {
    a.swap(b);
}
```

1.  外层的 `noexcept(...)` 是函数说明符，它接受一个布尔表达式。
2.  内层的 `noexcept(a.swap(b))` 是 `noexcept` 运算符。它在编译时计算表达式 `a.swap(b)` 是否声明为不抛出异常。
3.  如果 `a.swap(b)` 是 `noexcept` 的，那么 `noexcept(noexcept(a.swap(b)))` 就等价于 `noexcept(true)`，即整个 `swap` 函数也是 `noexcept` 的。
4.  否则，等价于 `noexcept(false)`。

这常用于模板元编程，让模板函数根据其模板参数的类型特性自动继承其异常规范。

## 作为运算符

在编译时查询一个表达式是否可能抛出异常。
不真的执行表达式。

```cpp
void non_except_func() noexcept {}
void except_func() {}

int main() {
    // noexcept(expression) 返回 bool
    std::cout << std::boolalpha;
    std::cout << noexcept(non_except_func()) << std::endl; // 输出: true
    std::cout << noexcept(except_func()) << std::endl;     // 输出: false

    int x = 10;
    std::cout << noexcept(x + 5) << std::endl;             // 输出: true (基本类型的操作通常不抛出)

    // 常用于 static_assert 或 if constexpr 中进行编译期检查
    static_assert(noexcept(non_except_func()), "This function should be noexcept!");

    return 0;
}
```

## 使用场景

### 移动语义和 STL 优化

这是 `noexcept` **最重要的应用场景**。STL 容器（如 `std::vector`）在重新分配内存（reallocate）时，需要将旧元素移动或拷贝到新内存中。

为了保证**强异常安全保证**（操作失败时不会改变原始状态），容器必须遵循：
*   如果元素的**移动构造函数是 `noexcept` 的**，容器会安全地使用它，因为你知道它不会失败。
*   否则，容器会**保守地使用拷贝构造函数**，因为拷贝通常更慢但能保证异常安全。

```cpp
class MyClass {
public:
    // 关键的移动构造函数！
    MyClass(MyClass&& other) noexcept { ... } // <-- 这个 noexcept 会让 vector 使用移动而非拷贝

    // 如果没有 noexcept，vector 在扩容时会被迫进行拷贝，性能下降！
    // MyClass(MyClass&& other) { ... } // 没有 noexcept，对 vector 不友好
};

int main() {
    std::vector<MyClass> vec;
    // ... 填充 vec
    vec.push_back(MyClass{}); // 如果 vector 需要扩容，noexcept 在此决定是移动还是拷贝旧元素
    return 0;
}
```

**最佳实践：为所有的移动构造函数和移动赋值运算符加上 `noexcept`。**

### 析构函数

**析构函数默认就是 `noexcept` 的**，除非显式地将其标记为 `noexcept(false)`。

在析构函数中抛出异常是极其危险的，很容易导致程序直接终止。所以你应该永远避免从析构函数中抛出异常。让它们保持默认的 `noexcept` 状态是最好的。

```cpp
~MyClass() { ... } // 这实际上是 ~MyClass() noexcept(true) { ... }
```

### 默认和删除

可以对特殊成员函数使用 `= default` 的同时指定异常规范。

```cpp
class MyClass {
public:
    ~MyClass() noexcept = default; // 显式声明默认析构为 noexcept
    MyClass(MyClass&&) noexcept = default; // 显式声明默认移动构造为 noexcept
    MyClass& operator=(MyClass&&) noexcept = default;

    // 也可以删除
    MyClass(const MyClass&) noexcept = delete;
};
```

## 总结与决策流程

| 场景                            | 是否使用 `noexcept`             | 理由                                                                         |
| :------------------------------ | :------------------------------ | :--------------------------------------------------------------------------- |
| **移动构造函数/移动赋值运算符** | **必须使用**                    | 使 STL 容器能高效地使用移动操作，极大提升性能。                              |
| **析构函数**                    | **通常不写（隐式 `noexcept`）** | 默认就是 `noexcept`。绝不应在析构函数中抛出异常。                            |
| **简单、不会失败的函数**        | **推荐使用**                    | 如 getters、简单计算等。给编译器优化机会，明确契约。                         |
| **函数会调用可能抛出的代码**    | **避免使用**                    | 如果你无法保证函数内部的所有操作都不抛出，就不要用。否则会直接 `terminate`。 |
| **模板函数**                    | **考虑使用条件 `noexcept`**     | 根据模板参数的特性来动态决定，非常强大。                                     |
| **遗留代码或第三方库接口**      | **谨慎使用**                    | 确保你完全了解其异常行为后再添加。                                           |

# 函数包装器

在 C++ 中，包装器（Wrapper）是一种将其他编程元素（如函数、对象或类型）封装起来的构造，目的是提供更统一的接口、添加额外功能或改变行为。函数包装器特指那些包装函数或可调用对象的工具。

函数包装器的主要目的是：
1. 统一不同类型的可调用对象的接口
2. 添加额外的功能（如日志、计时、缓存）
3. 延迟执行或部分应用参数
4. 管理函数对象的生命周期

C++ 提供了几种主要的函数包装机制：
- `std::function`：通用函数包装器
- 函数指针：传统的函数包装方式
- Lambda 表达式：匿名函数包装器
- `std::bind`：参数绑定包装器
- 自定义函数对象：通过重载 `operator()`

## `std::function` - 通用函数包装器

`std::function` 是 C++11 引入的最重要的函数包装器，它可以存储、复制和调用任何可调用对象。

```cpp
#include <iostream>
#include <functional> // 必需的头文件

// 1. 普通函数
int add(int a, int b) {
    return a + b;
}

// 2. 函数对象（仿函数）
struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

// 3. Lambda 表达式
auto subtract = [](int a, int b) { return a - b; };

int main() {
    // 声明 std::function 类型：返回值类型(参数类型...)
    std::function<int(int, int)> func;
    
    // 包装普通函数
    func = add;
    std::cout << "Add: " << func(10, 5) << std::endl; // 输出: 15
    
    // 包装函数对象
    func = Multiply();
    std::cout << "Multiply: " << func(10, 5) << std::endl; // 输出: 50
    
    // 包装 Lambda 表达式
    func = subtract;
    std::cout << "Subtract: " << func(10, 5) << std::endl; // 输出: 5
    
    // 包装带捕获的 Lambda
    int base = 100;
    auto add_base = [base](int a, int b) { return base + a + b; };
    func = add_base;
    std::cout << "Add with base: " << func(10, 5) << std::endl; // 输出: 115
    
    return 0;
}
```

### 检查是否为空

```cpp
#include <iostream>
#include <functional>

void print_hello() {
    std::cout << "Hello!" << std::endl;
}

int main() {
    std::function<void()> func;
    
    // 检查是否包装了可调用对象
    if (!func) {
        std::cout << "func is empty" << std::endl;
    }
    
    func = print_hello;
    
    if (func) {
        std::cout << "func is not empty" << std::endl;
        func(); // 调用包装的函数
    }
    
    // 重置为空
    func = nullptr;
    if (!func) {
        std::cout << "func is empty again" << std::endl;
    }
    
    return 0;
}
```

## 函数指针包装器

函数指针是 C++ 中最基础的函数包装方式：

```cpp
#include <iostream>

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 声明函数指针类型
    int (*func_ptr)(int, int);
    
    // 包装 add 函数
    func_ptr = add;
    std::cout << "Add: " << func_ptr(10, 5) << std::endl; // 输出: 15
    
    // 包装 multiply 函数
    func_ptr = multiply;
    std::cout << "Multiply: " << func_ptr(10, 5) << std::endl; // 输出: 50
    
    return 0;
}
```

## Lambda 表达式包装器

Lambda 表达式本质上是匿名函数对象，可以捕获上下文变量：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    int threshold = 3;
    
    // Lambda 包装器：捕获 threshold
    auto is_above_threshold = [threshold](int x) {
        return x > threshold;
    };
    
    // 使用包装器
    int count = std::count_if(numbers.begin(), numbers.end(), is_above_threshold);
    std::cout << "Numbers above " << threshold << ": " << count << std::endl;
    
    // 修改捕获的变量（需要 mutable）
    int counter = 0;
    auto incrementer = [counter]() mutable {
        return ++counter;
    };
    
    std::cout << "Counter: " << incrementer() << std::endl; // 输出: 1
    std::cout << "Counter: " << incrementer() << std::endl; // 输出: 2
    
    return 0;
}
```

## `std::bind` - 参数绑定包装器

`std::bind` 可以创建函数包装器，其中一些参数被绑定到特定值：

```cpp
#include <iostream>
#include <functional>

void print_sum(int a, int b, int c) {
    std::cout << "Sum: " << (a + b + c) << std::endl;
}

void print_product(int a, int b, int c) {
    std::cout << "Product: " << (a * b * c) << std::endl;
}

class Printer {
public:
    void print_message(const std::string& msg, int times) const {
        for (int i = 0; i < times; ++i) {
            std::cout << msg << std::endl;
        }
    }
};

int main() {
    using namespace std::placeholders; // 对于 _1, _2, _3...
    
    // 绑定第一个参数为10，其余参数留空
    auto bound_print = std::bind(print_sum, 10, _1, _2);
    bound_print(5, 3); // 相当于 print_sum(10, 5, 3)
    
    // 重新排列参数顺序
    auto reordered = std::bind(print_product, _2, _1, 10);
    reordered(5, 3); // 相当于 print_product(3, 5, 10)
    
    // 绑定成员函数
    Printer printer;
    auto print_hello = std::bind(&Printer::print_message, &printer, "Hello", _1);
    print_hello(3); // 打印 "Hello" 3次
    
    return 0;
}
```

## 自定义函数对象包装器

通过重载 `operator()` 创建自定义函数对象：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 自定义函数对象：求幂
class Power {
    int exponent;
public:
    Power(int exp) : exponent(exp) {}
    
    int operator()(int base) const {
        int result = 1;
        for (int i = 0; i < exponent; ++i) {
            result *= base;
        }
        return result;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 创建平方函数包装器
    Power square(2);
    
    // 应用函数包装器
    for (int num : numbers) {
        std::cout << num << "^2 = " << square(num) << std::endl;
    }
    
    // 使用 STL 算法
    std::vector<int> squared_numbers;
    squared_numbers.resize(numbers.size());
    
    std::transform(numbers.begin(), numbers.end(), 
                  squared_numbers.begin(), 
                  Power(3)); // 立方函数
    
    std::cout << "Cubed numbers: ";
    for (int num : squared_numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 高级应用：带状态的函数包装器

创建可以维护状态的函数包装器：

```cpp
#include <iostream>
#include <functional>

// 带状态的函数包装器：计数器
class Counter {
    int count;
public:
    Counter() : count(0) {}
    
    int operator()() {
        return ++count;
    }
    
    void reset() {
        count = 0;
    }
};

// 函数包装器，添加日志功能
template<typename Func>
class LoggingWrapper {
    Func func;
    std::string name;
public:
    LoggingWrapper(Func f, const std::string& n) : func(f), name(n) {}
    
    template<typename... Args>
    auto operator()(Args&&... args) {
        std::cout << "Calling " << name << " with " << sizeof...(args) << " arguments" << std::endl;
        auto result = func(std::forward<Args>(args)...);
        std::cout << name << " returned: " << result << std::endl;
        return result;
    }
};

// 辅助函数创建日志包装器
template<typename Func>
auto make_logger(Func func, const std::string& name) {
    return LoggingWrapper<Func>(func, name);
}

int add(int a, int b) {
    return a + b;
}

int main() {
    // 使用带状态的函数包装器
    Counter counter;
    std::cout << "Count: " << counter() << std::endl; // 1
    std::cout << "Count: " << counter() << std::endl; // 2
    
    // 创建带日志的函数包装器
    auto logged_add = make_logger(add, "add");
    int result = logged_add(5, 3); // 输出调用和返回信息
    
    return 0;
}
```

## 函数包装器在回调机制中的应用

函数包装器常用于实现回调机制：

```cpp
#include <iostream>
#include <functional>
#include <vector>

class Button {
    std::function<void()> onClick;
public:
    void setOnClick(const std::function<void()>& handler) {
        onClick = handler;
    }
    
    void click() {
        if (onClick) {
            onClick();
        }
    }
};

class TextBox {
    std::string text;
public:
    void setText(const std::string& newText) {
        text = newText;
    }
    
    const std::string& getText() const {
        return text;
    }
};

int main() {
    Button button;
    TextBox textBox;
    
    // 使用 Lambda 包装器设置回调
    button.setOnClick([&textBox]() {
        std::cout << "Button clicked! Text: " << textBox.getText() << std::endl;
    });
    
    textBox.setText("Hello World");
    button.click(); // 输出: Button clicked! Text: Hello World
    
    return 0;
}
```

## 性能考虑

虽然函数包装器提供了极大的灵活性，但也需要注意性能影响：

1. **`std::function` 的开销**：由于类型擦除，`std::function` 调用比直接函数调用稍慢
2. **小对象优化**：`std::function` 通常会对小对象使用栈存储，对大对象使用堆存储
3. **内联优化**：直接函数调用和 Lambda 表达式更容易被编译器内联优化

在性能关键的代码中，可以考虑使用函数指针或模板来代替 `std::function`。

## 总结

C++ 中的函数包装器提供了强大而灵活的方式来处理各种可调用对象：

1. **`std::function`**：通用函数包装器，适合存储和传递各种可调用对象
2. **函数指针**：最简单的函数包装方式，但功能有限
3. **Lambda 表达式**：创建匿名函数包装器，可以捕获上下文变量
4. **`std::bind`**：创建参数绑定包装器，支持部分应用参数
5. **自定义函数对象**：通过重载 `operator()` 创建有状态的函数包装器

函数包装器是现代 C++ 编程中不可或缺的工具，广泛应用于回调机制、事件处理、算法定制化和函数组合等场景。正确使用函数包装器可以大大提高代码的灵活性和可维护性。

# 类实例大小
> [C++对象大小远不止成员相加，这4大隐藏因素你知道几个？](https://mp.weixin.qq.com/s?__biz=Mzk2NDUyOTQzMA==&mid=2247484148&idx=1&sn=063ebec6fcfbe78f1b609d48282e4be7&chksm=c4735e8df304d79b3854a97ecf773f34084d83f4a69b8c2d477838a69d12b295a7d33c260ad7&cur_album_id=4104376609422147595&scene=189#wechat_redirect) 

# 空类

空类是指没有非静态数据成员的类。它可以有构造函数、析构函数、成员函数、静态数据成员等，但不能有普通的实例变量。

```cpp
// 最简单的空类
class EmptyClass {};

// 包含成员函数的空类
class EmptyWithFunctions {
public:
    void doSomething() {}
    static void staticFunction() {}
};

// 包含构造函数和析构函数的空类
class EmptyWithCtorDtor {
public:
    EmptyWithCtorDtor() {}
    ~EmptyWithCtorDtor() {}
};

// 包含静态成员的空类
class EmptyWithStatic {
public:
    static int staticMember;
};
int EmptyWithStatic::staticMember = 0;
```

## 空类的特性

### 1. 大小（Size）

空类的大小通常为 **1 字节**，而不是 0 字节。这是因为 C++ 标准要求每个对象都必须有唯一的地址。

```cpp
#include <iostream>

class Empty {};

int main() {
    Empty e1, e2;
    
    std::cout << "Size of Empty: " << sizeof(Empty) << " bytes" << std::endl;
    std::cout << "Address of e1: " << &e1 << std::endl;
    std::cout << "Address of e2: " << &e2 << std::endl;
    
    return 0;
}
```

输出可能类似于：
```
Size of Empty: 1 bytes
Address of e1: 0x7ffd4d2a5a2f
Address of e2: 0x7ffd4d2a5a2e
```

### 2. 空基类优化（Empty Base Optimization, EBO）

当空类作为基类时，编译器可以进行优化，使得基类不占用额外的空间。这是 C++ 中重要的优化技术。

```cpp
#include <iostream>

class Empty {};

class Derived : public Empty {
    int value;
};

class Composite {
    Empty e;
    int value;
};

int main() {
    std::cout << "Size of Empty: " << sizeof(Empty) << std::endl;
    std::cout << "Size of Derived: " << sizeof(Derived) << std::endl;
    std::cout << "Size of Composite: " << sizeof(Composite) << std::endl;
    
    return 0;
}
```

可能的输出：
```
Size of Empty: 1
Size of Derived: 4  // 空基类优化，不占用额外空间
Size of Composite: 8 // 包含空类成员，需要保持唯一地址
```

### 3. 默认成员函数

即使没有明确定义，空类也会自动生成以下特殊成员函数：
- 默认构造函数
- 默认析构函数
- 默认拷贝构造函数
- 默认拷贝赋值运算符
- 默认移动构造函数 (C++11)
- 默认移动赋值运算符 (C++11)

```cpp
class Empty {
    // 编译器自动生成：
    // Empty() {}
    // ~Empty() {}
    // Empty(const Empty&) {}
    // Empty& operator=(const Empty&) { return *this; }
    // Empty(Empty&&) {}              // C++11
    // Empty& operator=(Empty&&) {}   // C++11
};
```

## 空类的实际应用

### 1. 标签类（Tag Classes）

标签类是一种**不包含任何数据，只用于传递类型信息**的空类。它们就像"类型标签"，帮助编译器在编译时选择正确的代码路径。

空类常用于作为标签，用于区分不同的模板实例或函数重载。

```cpp
#include <iostream>

// 标签类
struct SerializeAsBinary {};
struct SerializeAsText {};

// 使用标签的函数
template<typename T>
void serialize(const T& obj, SerializeAsBinary) {
    std::cout << "Serializing as binary" << std::endl;
    // 二进制序列化实现
}

template<typename T>
void serialize(const T& obj, SerializeAsText) {
    std::cout << "Serializing as text" << std::endl;
    // 文本序列化实现
}

// 主函数
template<typename T>
void serialize(const T& obj) {
    serialize(obj, SerializeAsText{}); // 默认使用文本序列化
}

int main() {
    int value = 42;
    serialize(value);                    // 使用默认序列化
    serialize(value, SerializeAsBinary{}); // 显式指定二进制序列化
    
    return 0;
}
```

#### 为什么不用枚举而用空类？

**使用标签类的优势**：

1. **编译时决策**：标签类在编译时就确定了调用哪个函数，没有运行时的if-else判断
2. **类型安全**：编译器会检查标签类型，避免传错参数
3. **可扩展性**：添加新格式时，只需要添加新的标签类和对应的函数重载
4. **代码分离**：不同格式的处理逻辑完全分离，更清晰

#### 标签类在模板中的应用

标签类真正强大的地方在于与模板的结合：

```cpp
#include <iostream>
#include <type_traits>

// 标签定义
struct FastAlgorithm {};
struct SafeAlgorithm {};
struct MemoryEfficientAlgorithm {};

// 模板函数使用标签
template<typename AlgorithmTag>
void processAlgorithm() {
    if constexpr (std::is_same_v<AlgorithmTag, FastAlgorithm>) {
        std::cout << "使用快速算法（可能不太安全）" << std::endl;
        // 实现快速算法
    } else if constexpr (std::is_same_v<AlgorithmTag, SafeAlgorithm>) {
        std::cout << "使用安全算法（速度较慢）" << std::endl;
        // 实现安全算法
    } else if constexpr (std::is_same_v<AlgorithmTag, MemoryEfficientAlgorithm>) {
        std::cout << "使用内存高效算法" << std::endl;
        // 实现内存高效算法
    }
}

// 也可以特化模板类
template<typename Tag>
class Algorithm;

template<>
class Algorithm<FastAlgorithm> {
public:
    void execute() {
        std::cout << "执行快速算法" << std::endl;
    }
};

template<>
class Algorithm<SafeAlgorithm> {
public:
    void execute() {
        std::cout << "执行安全算法" << std::endl;
    }
};

int main() {
    // 使用函数模板
    processAlgorithm<FastAlgorithm>();
    processAlgorithm<SafeAlgorithm>();
    
    // 使用类模板
    Algorithm<FastAlgorithm> fastAlgo;
    Algorithm<SafeAlgorithm> safeAlgo;
    
    fastAlgo.execute();
    safeAlgo.execute();
    
    return 0;
}
```

### 2. 策略类（Policy Classes）

空类常用于实现策略模式，作为模板参数提供行为策略。

```cpp
#include <iostream>

// 策略类：空类
struct DefaultDelete {
    template<typename T>
    void operator()(T* ptr) const {
        std::cout << "Deleting with default delete" << std::endl;
        delete ptr;
    }
};

struct ArrayDelete {
    template<typename T>
    void operator()(T* ptr) const {
        std::cout << "Deleting with array delete" << std::endl;
        delete[] ptr;
    }
};

// 使用策略的智能指针
template<typename T, typename DeletionPolicy = DefaultDelete>
class SimpleUniquePtr {
    T* ptr;
    DeletionPolicy deleter;
    
public:
    explicit SimpleUniquePtr(T* p = nullptr) : ptr(p) {}
    
    ~SimpleUniquePtr() {
        if (ptr) {
            deleter(ptr);
        }
    }
    
    // 禁用拷贝
    SimpleUniquePtr(const SimpleUniquePtr&) = delete;
    SimpleUniquePtr& operator=(const SimpleUniquePtr&) = delete;
    
    // 允许移动
    SimpleUniquePtr(SimpleUniquePtr&& other) : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    SimpleUniquePtr& operator=(SimpleUniquePtr&& other) {
        if (this != &other) {
            if (ptr) {
                deleter(ptr);
            }
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    T* get() const { return ptr; }
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
};

int main() {
    // 使用默认删除策略
    SimpleUniquePtr<int> ptr1(new int(42));
    
    // 使用数组删除策略
    SimpleUniquePtr<int, ArrayDelete> ptr2(new int[5]{1, 2, 3, 4, 5});
    
    return 0;
}
```

这是一个**自定义智能指针**的实现，它使用**策略模式**通过模板参数来控制如何删除指针。空类在这里作为策略的实现载体。

**关键点解析：**
- 这两个结构体都是**空类**，没有数据成员
- 它们都重载了 **`operator()`**，这使得它们的实例可以像函数一样被调用（称为**函数对象**或**仿函数**）
- 使用**模板成员函数**，可以处理任何类型的指针
- `DefaultDelete` 使用 `delete ptr`（删除单个对象）
- `ArrayDelete` 使用 `delete[] ptr`（删除对象数组）

**空类的优势：**
1. **零内存开销**：空类没有数据成员，不占用额外空间
2. **编译时多态**：通过模板实现，没有运行时开销（不像虚函数）
3. **内联优化**：编译器可以内联策略代码，提高性能
4. **类型安全**：每种策略都是不同的类型，编译时检查

#### 实际应用场景

这种模式在C++标准库和许多开源库中广泛应用：

1. **STL智能指针**：`std::unique_ptr` 允许自定义删除器
2. **内存分配器**：STL容器允许自定义内存分配策略
3. **算法策略**：排序、查找等算法可以自定义比较策略
4. **IO处理**：不同的数据格式处理策略

### 3. 特征类（Trait Classes）

空类常用于实现类型特征，提供关于类型的编译时信息。

```cpp
#include <iostream>
#include <type_traits>

// 自定义类型特征
struct MyType {};
struct YourType {};

// 特征类：空类
template<typename T>
struct is_my_type : std::false_type {}; // 继承自 std::false_type

template<>
struct is_my_type<MyType> : std::true_type {}; // 继承自 std::true_type

template<typename T>
void process(const T& value) {
    if constexpr (is_my_type<T>::value) {
        std::cout << "Processing MyType" << std::endl;
    } else {
        std::cout << "Processing other type" << std::endl;
    }
}

int main() {
    MyType my;
    YourType your;
    int num = 42;
    
    process(my);   // 输出: Processing MyType
    process(your); // 输出: Processing other type
    process(num);  // 输出: Processing other type
    
    return 0;
}
```

### 4. 空基类优化（EBO）的应用

EBO 常用于实现大小优化的类，特别是在标准库中。

```cpp
#include <iostream>

// 空函数对象
struct Compare {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

// 不使用 EBO
class WithoutEBO {
    Compare comp;
    int value;
};

// 使用 EBO
class WithEBO : private Compare {
    int value;
};

int main() {
    std::cout << "Size without EBO: " << sizeof(WithoutEBO) << std::endl;
    std::cout << "Size with EBO: " << sizeof(WithEBO) << std::endl;
    
    // 在标准库中的类似应用
    // std::vector<bool, std::allocator<bool>> 使用 EBO 来避免分配器占用额外空间
    
    return 0;
}
```

### 几种应用区别

想象一个物流系统：

- **标签类**：像是一个**目的地标签**（如"易碎品"、"冷链"、"普通货物"）。它告诉系统"这是什么类型的货物"，但本身不包含处理逻辑。
  
- **策略类**：像是具体的**运输方案**（如"空运"、"陆运"、"海运"）。它包含具体的"如何运输"的实现逻辑。
  
- **特征类**：像是货物的**属性检测器**（如"检测是否为易碎品"、"检测是否需要冷藏"）。它用来查询货物具有什么特性。

| 特性          | 标签类       | 策略类         | 特征类       |
| ------------- | ------------ | -------------- | ------------ |
| **主要目的**  | 选择代码路径 | 提供算法实现   | 查询类型属性 |
| **包含行为**  | 通常无       | 总是有         | 通常无       |
| **使用方式**  | 函数参数     | 模板参数/组合  | 模板特化     |
| **典型问题**  | "该用哪个？" | "怎么做？"     | "是什么？"   |
| **编译/运行** | 编译时决策   | 通常运行时可用 | 编译时查询   |

#### 1. 标签类 (Tag Classes)

**目的**：在编译时**选择**不同的代码路径或函数重载。

**特点**：
- 通常是空类，没有成员变量和成员函数
- 用于函数重载决议或模板特化选择
- 回答的问题是："应该使用哪个实现？"

```cpp
// 标签类：空结构体，只用于标识类型
struct JsonFormat {};  // JSON格式标签
struct XmlFormat {};   // XML格式标签

// 函数重载：根据标签选择不同实现
void serialize(const Data& data, JsonFormat) {
    // JSON序列化实现
}

void serialize(const Data& data, XmlFormat) {
    // XML序列化实现
}

// 使用：通过传递不同的标签对象选择函数
Data data;
serialize(data, JsonFormat{});  // 调用JSON版本
serialize(data, XmlFormat{});   // 调用XML版本
```

#### 2. 策略类 (Strategy Classes)

**目的**：提供可替换的**算法或行为实现**。

**特点**：
- 通常包含具体的成员函数实现
- 通过模板参数或组合方式注入到主类中
- 回答的问题是："这个功能具体怎么做？"

```cpp
// 策略类：包含具体的行为实现
struct BubbleSort {
    template<typename Container>
    void operator()(Container& c) const {
        // 冒泡排序的具体实现
        std::cout << "Using bubble sort" << std::endl;
    }
};

struct QuickSort {
    template<typename Container>
    void operator()(Container& c) const {
        // 快速排序的具体实现  
        std::cout << "Using quick sort" << std::endl;
    }
};

// 使用策略的类
template<typename SortStrategy>
class Sorter {
    SortStrategy strategy;  // 策略对象
public:
    void sort(Container& c) {
        strategy(c);  // 使用注入的策略
    }
};

// 使用：注入不同的排序策略
Sorter<BubbleSort> bubbleSorter;
Sorter<QuickSort> quickSorter;
```

#### 3. 特征类 (Trait Classes)

**目的**：在编译时**查询类型的属性或特性**。

**特点**：
- 通常是模板类，包含静态常量或类型定义
- 用于编译时类型检查和元编程
- 回答的问题是："这个类型有什么特性？"

```cpp
// 特征类：查询类型特性
template<typename T>
struct is_pointer : std::false_type {};  // 默认不是指针

template<typename T>
struct is_pointer<T*> : std::true_type {};  // 特化：指针类型

template<typename T>
struct type_info {
    using type = T;
    static constexpr size_t size = sizeof(T);
};

// 使用：在编译时查询类型信息
static_assert(is_pointer<int*>::value, "Should be pointer");
static_assert(!is_pointer<int>::value, "Should not be pointer");

// 根据类型特性选择不同实现
template<typename T>
void process(const T& value) {
    if constexpr (is_pointer<T>::value) {
        std::cout << "Processing pointer" << std::endl;
    } else {
        std::cout << "Processing value" << std::endl;
    }
}
```

### 实际项目中的综合应用

在实际项目中，这三种模式经常结合使用：

```cpp
#include <iostream>
#include <type_traits>

// 标签类
struct FastTag {};
struct SafeTag {};

// 特征类：检测算法特性
template<typename Algorithm>
struct is_fast_algorithm : std::false_type {};

template<>
struct is_fast_algorithm<FastTag> : std::true_type {};

// 策略类
struct FastAlgorithm {
    void execute() const {
        std::cout << "Executing fast algorithm" << std::endl;
    }
};

struct SafeAlgorithm {
    void execute() const {
        std::cout << "Executing safe algorithm" << std::endl;
    }
};

// 使用所有概念的处理器
template<typename AlgorithmTag, typename AlgorithmStrategy>
class Processor {
    AlgorithmStrategy strategy;
public:
    void process() {
        std::cout << "Algorithm type: ";
        if constexpr (is_fast_algorithm<AlgorithmTag>::value) {
            std::cout << "Fast" << std::endl;
        } else {
            std::cout << "Safe" << std::endl;
        }
        strategy.execute();
    }
};

int main() {
    // 标签选择类型，策略提供实现
    Processor<FastTag, FastAlgorithm> fastProcessor;
    Processor<SafeTag, SafeAlgorithm> safeProcessor;
    
    fastProcessor.process();
    safeProcessor.process();
    
    return 0;
}
```

## 空类的注意事项

1. **空类大小**：空类大小至少为 1 字节，以确保对象有唯一地址。
2. **继承与组合**：
   - 继承空类可能通过 EBO 不占用空间
   - 组合空类至少占用 1 字节空间
3. **标准布局**：空类可能影响类的标准布局属性，这会影响与其他语言（如 C）的互操作性。
4. **内存布局**：在涉及内存布局敏感的操作时（如序列化、网络传输），需要注意空类的影响。
