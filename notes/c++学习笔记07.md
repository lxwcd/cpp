C++ 学习笔记

# 全局变量

## 两个.cpp文件中的同名全局变量会报错

1. **编译阶段**：每个.cpp文件被单独编译成目标文件(.obj或.o)
2. **链接阶段**：所有目标文件被链接器合并成一个可执行文件

在编译器中，变量和函数名称都被称为"符号"。全局变量会生成一个全局符号。

- **强符号**：已初始化的全局变量（如 `int x = 5;`）
- **弱符号**：未初始化的全局变量（如 `int x;`）

**链接器的黄金规则**：不允许有多个同名的强符号。

```cpp
// file1.cpp
int globalVar = 42;  // 强符号

// file2.cpp  
int globalVar = 100; // 另一个强符号，同名！
```

当链接器尝试将两个目标文件合并时，它会发现两个同名的强符号，不知道应该使用哪一个，因此报错。

### 编译阶段（单独编译每个文件）

```bash
# 编译第一个文件（不会报错）
g++ -c file1.cpp -o file1.o

# 编译第二个文件（不会报错）  
g++ -c file2.cpp -o file2.o
```

在每个.cpp文件单独编译时，编译器并不知道其他文件的存在，所以不会报错。

### 链接阶段（合并所有目标文件）

```bash
# 链接时报错
g++ file1.o file2.o -o program
```

链接器会报错：`multiple definition of 'globalVar'`

### 解决方案1：使用 `extern` 关键字（最常用）

```cpp
// file1.cpp
int globalVar = 42;  // 定义（强符号）

// file2.cpp
extern int globalVar; // 声明（不是定义，不创建强符号）

void func() {
    globalVar = 100; // 使用 file1.cpp 中的定义
}
```

### 解决方案2：使用 `static` 关键字

```cpp
// file1.cpp
static int globalVar = 42;  // 只在 file1.cpp 中可见

// file2.cpp
static int globalVar = 100; // 只在 file2.cpp 中可见，不会冲突
```

`static` 使全局变量具有内部链接性，只在当前文件内有效。

### 解决方案3：使用匿名命名空间（现代C++）

```cpp
// file1.cpp
namespace {
    int globalVar = 42;  // 只在当前文件可见
}

// file2.cpp
namespace {
    int globalVar = 100; // 只在当前文件可见，不会冲突
}
```

## 特殊情况：const 全局变量

const 全局变量默认具有内部链接性（相当于隐式 static），所以不会冲突：

```cpp
// file1.cpp
const int MAX_SIZE = 100; // 不会冲突

// file2.cpp
const int MAX_SIZE = 200; // 不会冲突
```

如果想要 const 变量具有外部链接性，需要使用 extern：

```cpp
// file1.cpp
extern const int MAX_SIZE = 100; // 具有外部链接

// file2.cpp
extern const int MAX_SIZE; // 声明
```
