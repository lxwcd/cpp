C++ 学习笔记

# 全局变量

## 两个.cpp文件中的同名全局变量会报错

1. **编译阶段**：每个.cpp文件被单独编译成目标文件(.obj或.o)
2. **链接阶段**：所有目标文件被链接器合并成一个可执行文件

在编译器中，变量和函数名称都被称为"符号"。全局变量会生成一个全局符号。

- **强符号**：已初始化的全局变量（如 `int x = 5;`）
- **弱符号**：未初始化的全局变量（如 `int x;`）

**链接器的黄金规则**：不允许有多个同名的强符号。

```cpp
// file1.cpp
int globalVar = 42;  // 强符号

// file2.cpp  
int globalVar = 100; // 另一个强符号，同名！
```

当链接器尝试将两个目标文件合并时，它会发现两个同名的强符号，不知道应该使用哪一个，因此报错。

### 编译阶段（单独编译每个文件）

```bash
# 编译第一个文件（不会报错）
g++ -c file1.cpp -o file1.o

# 编译第二个文件（不会报错）  
g++ -c file2.cpp -o file2.o
```

在每个.cpp文件单独编译时，编译器并不知道其他文件的存在，所以不会报错。

### 链接阶段（合并所有目标文件）

```bash
# 链接时报错
g++ file1.o file2.o -o program
```

链接器会报错：`multiple definition of 'globalVar'`

### 解决方案1：使用 `extern` 关键字（最常用）

```cpp
// file1.cpp
int globalVar = 42;  // 定义（强符号）

// file2.cpp
extern int globalVar; // 声明（不是定义，不创建强符号）

void func() {
    globalVar = 100; // 使用 file1.cpp 中的定义
}
```

### 解决方案2：使用 `static` 关键字

```cpp
// file1.cpp
static int globalVar = 42;  // 只在 file1.cpp 中可见

// file2.cpp
static int globalVar = 100; // 只在 file2.cpp 中可见，不会冲突
```

`static` 使全局变量具有内部链接性，只在当前文件内有效。

### 解决方案3：使用匿名命名空间（现代C++）

```cpp
// file1.cpp
namespace {
    int globalVar = 42;  // 只在当前文件可见
}

// file2.cpp
namespace {
    int globalVar = 100; // 只在当前文件可见，不会冲突
}
```

## 特殊情况：const 全局变量

const 全局变量默认具有内部链接性（相当于隐式 static），所以不会冲突：

```cpp
// file1.cpp
const int MAX_SIZE = 100; // 不会冲突

// file2.cpp
const int MAX_SIZE = 200; // 不会冲突
```

如果想要 const 变量具有外部链接性，需要使用 extern：

```cpp
// file1.cpp
extern const int MAX_SIZE = 100; // 具有外部链接

// file2.cpp
extern const int MAX_SIZE; // 声明
```

# static 

## static 局部变量

在函数内部声明的静态局部变量具有以下特性：
- 生命周期贯穿整个程序运行期间
- 只在第一次进入函数时初始化
- 作用域仍限于函数内部

```cpp
#include <iostream>
using namespace std;

void counter() {
    static int count = 0; // 静态局部变量
    count++;
    cout << "Count: " << count << endl;
}

int main() {
    counter(); // 输出 Count: 1
    counter(); // 输出 Count: 2
    counter(); // 输出 Count: 3
    return 0;
}
```

## static 全局变量

在全局作用域中使用 `static` 声明的变量：
- 具有文件作用域（只在当前文件内可见）
- 避免命名冲突
- 生命周期贯穿整个程序

```cpp
// file1.cpp
static int fileLocalVar = 42; // 只在当前文件可见

// file2.cpp
extern int fileLocalVar; // 链接错误，无法访问另一个文件的静态全局变量
```

1. **声明时初始化的 static 全局变量**：使用指定的值进行初始化
2. **声明时未初始化的 static 全局变量**：
   - 基本类型：进行零初始化（0, 0.0, false, nullptr等）
   - 类类型：调用默认构造函数
3. **初始化时机**：
   - 在程序启动时（main函数执行前）初始化
   - 在程序结束时（main函数执行后）销毁
4. **初始化顺序**：不同编译单元中的static全局变量初始化顺序未定义
5. **解决方案**：对于需要跨文件访问的静态数据，使用函数包装器或单例模式

### 初始化

static 全局变量的初始化分为两种类型：

1. **静态初始化**（零初始化）：在编译时确定初始值，如果没用初始化，则初始化为 0
2. **动态初始化**：需要在运行时执行代码来确定初始值

```cpp
#include <iostream>
#include <ctime>
using namespace std;

// 静态初始化（编译时）
static int staticInitialized = 100;
static const char* staticString = "Compile-time";

// 动态初始化（运行时）
static time_t currentTime = time(nullptr); // 需要在运行时调用函数
static int dynamicValue = []() {
    cout << "Initializing dynamicValue..." << endl;
    return 42;
}(); // 使用lambda表达式初始化

int main() {
    cout << "staticInitialized: " << staticInitialized << endl;
    cout << "staticString: " << staticString << endl;
    cout << "currentTime: " << currentTime << endl;
    cout << "dynamicValue: " << dynamicValue << endl;
    
    return 0;
}
```

### constexpr 与 static 结合

C++11 引入了 constexpr，可以与 static 结合使用：

```cpp
#include <iostream>
using namespace std;

// constexpr 静态变量必须在编译时初始化
static constexpr int compileTimeValue = 100;
static constexpr double compileTimePI = 3.14159;

// 错误：constexpr 变量必须初始化
// static constexpr int uninitializedConstexpr;

int main() {
    // 可以在编译时使用这些值
    int array[compileTimeValue]; // 合法，因为compileTimeValue是编译时常量
    
    cout << "compileTimeValue: " << compileTimeValue << endl;
    cout << "compileTimePI: " << compileTimePI << endl;
    
    return 0;
}
```

## static 成员变量

类的静态成员变量：
- 属于类本身，而不是类的实例
- 所有实例共享同一份拷贝
- 需要在类外进行定义和初始化

```cpp
#include <iostream>
using namespace std;

class MyClass {
public:
    static int staticVar; // 声明静态成员变量
    int normalVar;
    
    MyClass(int val) : normalVar(val) {}
};

// 定义和初始化静态成员变量
int MyClass::staticVar = 0;

int main() {
    MyClass obj1(10), obj2(20);
    
    cout << "obj1.normalVar: " << obj1.normalVar << endl; // 10
    cout << "obj2.normalVar: " << obj2.normalVar << endl; // 20
    
    // 静态变量通过类名访问
    cout << "MyClass::staticVar: " << MyClass::staticVar << endl; // 0
    
    // 修改静态变量
    MyClass::staticVar = 100;
    
    // 所有实例看到相同的值
    cout << "obj1.staticVar: " << obj1.staticVar << endl; // 100
    cout << "obj2.staticVar: " << obj2.staticVar << endl; // 100
    
    return 0;
}
```

## static 成员函数

静态成员函数：
- 属于类本身，而不是类的实例
- 不能访问类的非静态成员
- 没有 `this` 指针
- 可以直接通过类名调用

```cpp
#include <iostream>
using namespace std;

class MathUtils {
public:
    static int add(int a, int b) {
        return a + b;
    }
    
    static double PI() {
        return 3.14159;
    }
    
    // 错误示例：静态函数不能访问非静态成员
    // static void printNormalVar() {
    //     cout << normalVar; // 编译错误
    // }
    
private:
    int normalVar;
};

int main() {
    // 直接通过类名调用静态函数
    cout << "5 + 3 = " << MathUtils::add(5, 3) << endl;
    cout << "PI: " << MathUtils::PI() << endl;
    
    return 0;
}
```

## static 在普通函数前

在普通函数前使用 `static`：
- 使函数具有文件作用域（只在当前文件内可见）
- 避免命名冲突

```cpp
// file1.cpp
#include <iostream>
using namespace std;

static void fileLocalFunction() {
    cout << "This function is only visible in this file" << endl;
}

void publicFunction() {
    fileLocalFunction(); // 可以调用
}

// file2.cpp
extern void fileLocalFunction(); // 链接错误，无法访问另一个文件的静态函数
```

## 总结

| static 用法 | 作用域   | 生命周期 | 特点                             |
| ----------- | -------- | -------- | -------------------------------- |
| 局部变量    | 函数内部 | 整个程序 | 只初始化一次，保持值不变         |
| 全局变量    | 文件内部 | 整个程序 | 避免命名冲突                     |
| 成员变量    | 类范围   | 整个程序 | 所有实例共享，属于类本身         |
| 成员函数    | 类范围   | -        | 不能访问非静态成员，没有this指针 |
| 普通函数    | 文件内部 | -        | 避免命名冲突                     |

`static` 关键字的主要作用是控制变量和函数的可见性和生命周期，合理使用可以提高代码的模块化和封装性。
