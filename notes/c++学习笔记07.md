C++ 学习笔记

# 全局变量

## 两个.cpp文件中的同名全局变量会报错

1. **编译阶段**：每个.cpp文件被单独编译成目标文件(.obj或.o)
2. **链接阶段**：所有目标文件被链接器合并成一个可执行文件

在编译器中，变量和函数名称都被称为"符号"。全局变量会生成一个全局符号。

- **强符号**：已初始化的全局变量（如 `int x = 5;`）
- **弱符号**：未初始化的全局变量（如 `int x;`）

**链接器的黄金规则**：不允许有多个同名的强符号。

```cpp
// file1.cpp
int globalVar = 42;  // 强符号

// file2.cpp  
int globalVar = 100; // 另一个强符号，同名！
```

当链接器尝试将两个目标文件合并时，它会发现两个同名的强符号，不知道应该使用哪一个，因此报错。

### 编译阶段（单独编译每个文件）

```bash
# 编译第一个文件（不会报错）
g++ -c file1.cpp -o file1.o

# 编译第二个文件（不会报错）  
g++ -c file2.cpp -o file2.o
```

在每个.cpp文件单独编译时，编译器并不知道其他文件的存在，所以不会报错。

### 链接阶段（合并所有目标文件）

```bash
# 链接时报错
g++ file1.o file2.o -o program
```

链接器会报错：`multiple definition of 'globalVar'`

### 解决方案1：使用 `extern` 关键字（最常用）

```cpp
// file1.cpp
int globalVar = 42;  // 定义（强符号）

// file2.cpp
extern int globalVar; // 声明（不是定义，不创建强符号）

void func() {
    globalVar = 100; // 使用 file1.cpp 中的定义
}
```

### 解决方案2：使用 `static` 关键字

```cpp
// file1.cpp
static int globalVar = 42;  // 只在 file1.cpp 中可见

// file2.cpp
static int globalVar = 100; // 只在 file2.cpp 中可见，不会冲突
```

`static` 使全局变量具有内部链接性，只在当前文件内有效。

### 解决方案3：使用匿名命名空间（现代C++）

```cpp
// file1.cpp
namespace {
    int globalVar = 42;  // 只在当前文件可见
}

// file2.cpp
namespace {
    int globalVar = 100; // 只在当前文件可见，不会冲突
}
```

## 特殊情况：const 全局变量

const 全局变量默认具有内部链接性（相当于隐式 static），所以不会冲突：

```cpp
// file1.cpp
const int MAX_SIZE = 100; // 不会冲突

// file2.cpp
const int MAX_SIZE = 200; // 不会冲突
```

如果想要 const 变量具有外部链接性，需要使用 extern：

```cpp
// file1.cpp
extern const int MAX_SIZE = 100; // 具有外部链接

// file2.cpp
extern const int MAX_SIZE; // 声明
```

# volatile

`volatile` 是 C++ 中的一个类型修饰符，它告诉编译器不要对标记为 `volatile` 的变量进行优化，因为这些变量可能会在程序之外被改变。

在没有 `volatile` 的情况下，编译器可能会对变量访问进行优化，例如：
1. 将变量值缓存到寄存器中，多次读取使用缓存值
2. 删除看似冗余的读写操作
3. 重新排序指令以提高效率

但对于某些特殊情况的变量，这些优化会导致问题，因为变量的值可能会在编译器不知情的情况下被改变。

```cpp
volatile int counter;
volatile float sensorValue;
volatile bool flag;
```

## 内存映射的硬件寄存器

在嵌入式系统中，硬件寄存器通常映射到特定的内存地址。这些寄存器的值可能会随时被硬件改变。

```cpp
#include <iostream>

// 假设这是一个硬件寄存器的内存映射地址
volatile unsigned int* const hardwareTimer = reinterpret_cast<volatile unsigned int*>(0x40001000);

int main() {
    unsigned int startTime = *hardwareTimer;
    
    // 执行一些操作...
    
    unsigned int endTime = *hardwareTimer;
    unsigned int elapsed = endTime - startTime;
    
    std::cout << "Elapsed time: " << elapsed << std::endl;
    
    return 0;
}
```

1. `unsigned int startTime = *hardwareTimer;` - 第一次读取
2. `unsigned int endTime = *hardwareTimer;` - 第二次读取

如果没有 `volatile` 关键字，编译器可能会进行优化，因为它认为：
1. 在两次读取之间，程序没有修改 `*hardwareTimer` 的值
2. 因此，第二次读取的值应该与第一次相同
3. 编译器可能会优化掉第二次读取，直接使用第一次读取的值

对于内存映射的硬件寄存器：
1. 这个地址不是普通的内存，而是映射到硬件设备
2. 硬件可能会在任何时候改变这个地址的值（例如，计时器寄存器会自动递增）
3. 编译器不知道这一点，它只看到代码中没有修改这个变量的操作

因此，如果没有 `volatile`：
1. 程序可能无法正确读取硬件寄存器的当前值
2. 计算的时间差总是为 0，因为两次读取得到的是相同的（缓存的）值

## 多线程编程中的共享变量

在多线程环境中，一个变量可能被多个线程访问，其中一些线程可能会修改它。

```cpp
#include <iostream>
#include <thread>
#include <chrono>

volatile bool stopRequested = false;

void workerThread() {
    while (!stopRequested) {
        // 执行工作
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "Worker thread stopped" << std::endl;
}

int main() {
    std::thread worker(workerThread);
    
    // 主线程运行一段时间
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // 请求工作线程停止
    stopRequested = true;
    
    worker.join();
    std::cout << "Main thread finished" << std::endl;
    
    return 0;
}
```

注意：虽然 `volatile` 可以用于多线程场景，但它不能替代适当的同步原语（如互斥锁）。`volatile` 只保证每次访问都从内存读取/写入，但不保证操作的原子性。

## 信号处理程序中的变量

当变量可能在信号处理程序中被修改时，需要使用 `volatile`。

```cpp
#include <iostream>
#include <csignal>
#include <unistd.h>

volatile sig_atomic_t signalReceived = 0;

void signalHandler(int signum) {
    signalReceived = signum;
}

int main() {
    // 设置信号处理程序
    signal(SIGINT, signalHandler);
    
    std::cout << "Waiting for signal (Ctrl+C)..." << std::endl;
    
    while (signalReceived == 0) {
        // 等待信号
        sleep(1);
    }
    
    std::cout << "Received signal: " << signalReceived << std::endl;
    
    return 0;
}
```

## volatile 的局限性

### volatile 不能保证原子性

```cpp
#include <iostream>
#include <thread>

volatile int counter = 0;

void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // 这不是原子操作！
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    
    t1.join();
    t2.join();
    
    std::cout << "Counter value: " << counter << std::endl;
    // 结果可能不是200000，因为counter++不是原子操作
    
    return 0;
}
```

### volatile 不能替代内存屏障

`volatile` 不能防止 CPU 重排指令，如果需要严格的执行顺序，应该使用内存屏障。

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<bool> ready(false);
volatile int data = 0;

void producer() {
    data = 42; // 步骤1
    ready.store(true, std::memory_order_release); // 步骤2
}

void consumer() {
    while (!ready.load(std::memory_order_acquire)) {
        // 等待
    }
    std::cout << "Data: " << data << std::endl; // 步骤3
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

在这个例子中，使用 `std::atomic` 和内存序保证了正确的执行顺序。

## volatile 与 const 的结合

`volatile` 可以和 `const` 一起使用，表示一个变量是只读的，但它的值可能会意外改变。

```cpp
// 只读的硬件寄存器
volatile const unsigned int* const hardwareStatusRegister = 
    reinterpret_cast<volatile const unsigned int*>(0x40002000);

int main() {
    // 可以读取但不能写入
    unsigned int status = *hardwareStatusRegister;
    
    // 以下代码会产生编译错误
    // *hardwareStatusRegister = 0;
    
    return 0;
}
```

## volatile 与指针

当使用指针时，需要注意 `volatile` 的位置：

```cpp
volatile int* p1;        // 指针指向的 int 是 volatile 的
int* volatile p2;        // 指针本身是 volatile 的
volatile int* volatile p3; // 指针和它指向的 int 都是 volatile 的
```

## 总结

1. **用途**：
   - 内存映射的硬件寄存器
   - 多线程环境中的共享变量（但需要额外同步）
   - 信号处理程序中的变量

2. **作用**：
   - 阻止编译器对变量访问进行优化
   - 确保每次访问都从内存读取/写入

3. **限制**：
   - 不保证操作的原子性
   - 不能防止 CPU 指令重排序
   - 不能替代适当的同步机制

4. **最佳实践**：
   - 在嵌入式系统和设备驱动开发中广泛使用
   - 在多线程编程中，结合适当的同步原语使用
   - 对于现代 C++ 多线程编程，优先考虑使用 `std::atomic`
   
# 匿名空间
> [Namespaces - cppreference.com](https://en.cppreference.com/w/cpp/language/namespace.html#Unnamed_namespaces) 

## 匿名命名空间的隔离机制

匿名命名空间能够有效隔离不同文件中的同名全局变量。

每个匿名命名空间实际上都有一个**唯一的、编译器生成的名称**。虽然在代码中写的是没有名称的命名空间：

```cpp
namespace {
    int globalVar = 42;
}
```

但编译器会为每个匿名命名空间生成一个唯一的内部名称，类似于：

```cpp
namespace __unique_name_12345 {
    int globalVar = 42;
}
using namespace __unique_name_12345; // 隐式的using指令
```

当你在两个不同的.cpp文件中使用匿名命名空间时：

```cpp
// file1.cpp
namespace { // 编译器生成唯一名称，比如 __file1_anon_ns
    int globalVar = 42;
}

// file2.cpp
namespace { // 编译器生成不同的唯一名称，比如 __file2_anon_ns
    int globalVar = 100;
}
```

实际上创建的是两个完全不同的命名空间，因此其中的 `globalVar` 也是完全不同的变量，不会产生命名冲突。

## 与static关键字的等效性

在C++中，匿名命名空间内的变量具有**内部链接性**，这与使用 `static` 关键字是等效的。C++标准明确规定：

> Unnamed namespace definition. Its members have potential scope from their point of declaration to the end of the translation unit, and have internal linkage.

这意味着匿名命名空间内的所有名称都具有内部链接性，只在其所在的翻译单元（.cpp文件）内可见。

## 匿名命名空间 vs static 关键字

虽然匿名命名空间和static关键字都能实现内部链接性，但它们有一些重要区别：

### 1. 模板友好性

匿名命名空间对模板更友好：

```cpp
// 使用static（有问题）
static template<typename T> 
class MyClass { /*...*/ }; // 错误: 不能将模板声明为static

// 使用匿名命名空间（正确）
namespace {
    template<typename T>
    class MyClass { /*...*/ }; // 正确
}
```

### 2. 类型定义

匿名命名空间可以包含类型定义，而static不能用于类型：

```cpp
// 使用static（有问题）
static struct Point { int x, y; }; // 不推荐，C++中很少这样用

// 使用匿名命名空间（正确）
namespace {
    struct Point { int x, y; }; // 正确
}
```

### 3. 一致性

匿名命名空间提供了一致的方式来限制所有名称的链接性：

```cpp
namespace {
    int variable;          // 内部链接
    void function() {}     // 内部链接
    class MyClass {};      // 内部链接
    typedef int Integer;   // 内部链接
}
```

## 匿名命名空间的注意事项

### 1. 头文件中的使用

不要在头文件中使用匿名命名空间：

```cpp
// myheader.h (不推荐!)
namespace {
    int sharedVar = 42; // 每个包含此头文件的.cpp都会得到自己的副本
}
```

这会导致每个包含该头文件的翻译单元都有一个独立的 `sharedVar` 副本，可能造成内存浪费和逻辑错误。

### 2. 与外部代码的交互

匿名命名空间中的名称无法从其他翻译单元访问：

```cpp
// file1.cpp
namespace {
    int helperVar = 42;
}

// file2.cpp
extern int helperVar; // 错误: 无法找到helperVar的定义
```

## 现代C++的最佳实践

### 1. 优先使用匿名命名空间

C++标准推荐使用匿名命名空间代替static关键字：

### 2. 结合constexpr使用

对于常量，优先使用constexpr：

```cpp
// 传统方式
namespace {
    const int MAX_SIZE = 100;
}

// 现代方式
constexpr int MAX_SIZE = 100; // 默认具有内部链接性
```

### 3. 使用命名空间组织代码

对于需要在多个文件中共享的代码，使用具名命名空间：

```cpp
// config.h
namespace AppConfig {
    extern const int MAX_USERS;
    extern const char* DB_NAME;
}

// config.cpp
namespace AppConfig {
    const int MAX_USERS = 1000;
    const char* DB_NAME = "my_app_db";
}
```