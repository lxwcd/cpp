C++ 学习笔记 —— 模板

# 万能引用 Universe Reference

万能引用是由 Scott Meyers 在他的著作《Effective Modern C++》中提出的概念。它指的是模板参数中的右值引用 `T&&`，这种引用可以绑定到左值或右值，具体取决于传入的参数类型。

1. **模板参数中的右值引用**：
   - 万能引用的形式是 `T&&`，其中 `T` 是一个模板参数。
   - 例如：
     ```cpp
     template <typename T>
     void func(T&& param);
     ```

2. **可以绑定到左值或右值**：
   - 如果传入的是左值，`T` 会被推导为左值引用类型（`const T&`）。
   - 如果传入的是右值，`T` 会被推导为右值类型（`T`）。

3. **需要使用 `std::forward` 进行完美转发**：
   - 为了保持传入参数的左值或右值特性，需要使用 `std::forward` 进行完美转发。
   - `std::forward<T>(param)` 会根据 `param` 的原始类型（左值或右值）进行转发。

## 示例 1：左值绑定

```cpp
#include <iostream>
#include <utility>

template <typename T>
void func(T&& param) {
    std::cout << "Type of param: " << typeid(param).name() << std::endl;
    std::cout << "Type of std::forward<T>(param): " << typeid(std::forward<T>(param)).name() << std::endl;
}

int main() {
    int a = 42; // a 是一个左值
    func(a);    // 调用 func<int&>(int&)
}
```

**输出**：
```
Type of param: int& (左值引用)
Type of std::forward<T>(param): int& (左值引用)
```

**解释**：
- `a` 是一个左值，`T` 被推导为 `int&`。
- `param` 是一个左值引用，`std::forward<int&>(param)` 会将 `param` 转换为左值引用。

## 示例 2：右值引用绑定

```cpp
#include <iostream>
#include <utility>

template <typename T>
void func(T&& param) {
    std::cout << "Type of param: " << typeid(param).name() << std::endl;
    std::cout << "Type of std::forward<T>(param): " << typeid(std::forward<T>(param)).name() << std::endl;
}

int main() {
    int&& b = 100; // b 是一个右值引用
    func(b);       // 调用 func<int&&>(int&&)
}
```

**输出**：
```
Type of param: int&& (右值引用)
Type of std::forward<T>(param): int&& (右值引用)
```

**解释**：
- `b` 是一个右值引用，`T` 被推导为 `int&&`。
- `param` 是一个右值引用，`std::forward<int&&>(param)` 会将 `param` 转换为右值引用。

## 示例 3：右值绑定

```cpp
#include <iostream>
#include <utility>

template <typename T>
void func(T&& param) {
    std::cout << "Type of param: " << typeid(param).name() << std::endl;
    std::cout << "Type of std::forward<T>(param): " << typeid(std::forward<T>(param)).name() << std::endl;
}

int main() {
    func(1000);    // 调用 func<int>(int&&)
}
```

**输出**：
```
Type of param: int (右值)
Type of std::forward<T>(param): int (右值)
```

**解释**：
- `1000` 是一个右值，`T` 被推导为 `int`。
- `param` 是一个右值引用，`std::forward<int>(param)` 会将 `param` 转换为右值。

## 示例4：自定义 `make_shared`

```cpp
#include <iostream>
#include <memory>
#include <utility>

template <typename T, typename... Args>
std::shared_ptr<T> make_shared(Args&&... args) {
    return std::shared_ptr<T>(new T(std::forward<Args>(args)...));
}

int main() {
    auto sp1 = make_shared<int>(42); // 传递右值
    auto sp2 = make_shared<std::string>("Hello, World!"); // 传递右值
    auto sp3 = make_shared<std::string>(std::string("Another string")); // 传递左值

    std::cout << *sp1 << std::endl;
    std::cout << *sp2 << std::endl;
    std::cout << *sp3 << std::endl;

    return 0;
}
```

**输出**：
```
42
Hello, World!
Another string
```

**解释**：
- `make_shared` 使用万能引用 `Args&&... args` 接收参数，并使用 `std::forward<Args>(args)...` 进行完美转发。
- 这样，`make_shared` 可以正确地将参数的左值或右值特性传递给 `T` 的构造函数。

# 模板元编程

**模板元编程（Template Metaprogramming, TMP）**是一种在编译时进行计算和生成代码的技术。它利用C++模板的特性，在编译时执行复杂的逻辑操作，生成优化的代码。模板元编程的核心思想是将计算和逻辑处理从运行时移到编译时，从而提高程序的性能和灵活性。

模板是C++中的一种机制，允许你定义通用的类和函数，这些类和函数可以接受不同类型或值作为参数。模板分为函数模板和类模板。

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```
这个函数模板可以处理任何类型 `T` 的加法操作。

```cpp
template <typename T>
class MyContainer {
    T value;
public:
    MyContainer(T val) : value(val) {}
    T getValue() const { return value; }
};
```
这个类模板可以处理任何类型 `T` 的数据。

## 编译时计算
模板元编程可以在编译时进行复杂的计算，生成优化的代码。

**示例：计算阶乘**
```cpp
template <int N>
struct Factorial {
    static constexpr int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static constexpr int value = 1;
};

int main() {
    std::cout << "Factorial<5>::value: " << Factorial<5>::value << std::endl; // 输出：120
    return 0;
}
```
在这个例子中，`Factorial` 是一个模板结构体，它在编译时计算阶乘。

## 类型检查和选择
模板元编程可以用于编译时的类型检查和选择，确保代码的正确性和灵活性。

**示例：检查类型是否为整数**
```cpp
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "is_integral<int>::value: " << std::is_integral<int>::value << std::endl; // 输出：true
    std::cout << "is_integral<double>::value: " << std::is_integral<double>::value << std::endl; // 输出：false

    return 0;
}
```
在这个例子中，`std::is_integral` 是一个类型特征，它在编译时检查类型是否为整数。

## 条件类型选择
模板元编程可以用于根据条件选择类型，实现更灵活的代码。

**示例：根据条件选择类型**
```cpp
#include <iostream>
#include <type_traits>

template <typename T>
using enable_if_integral = typename std::enable_if<std::is_integral<T>::value, T>::type;

int main() {
    enable_if_integral<int> x = 10; // 成功
    // enable_if_integral<double> y = 20.0; // 编译错误

    std::cout << "x: " << x << std::endl;

    return 0;
}
```
在这个例子中，`std::enable_if` 用于根据条件选择类型，确保只有整数类型可以被使用。

# Lockable

在 C++ 的模板中，模板参数可以分为两类：
1. **普通模板参数**：表示单个类型或值。
2. **参数包（Parameter Pack）**：表示一组类型或值，可以包含任意数量的元素。

`typename Lockable` 是一个普通模板参数，表示一个类型。这个类型通常用于表示某种特定的功能或接口。

`Lockable` 通常用于表示一个可以被锁定的对象，比如互斥锁（mutex）。在多线程编程中，互斥锁用于保护共享资源，防止多个线程同时访问。

一个类型满足 Lockable 概念必须实现以下成员函数：

| 方法         | 描述                             |
| ------------ | -------------------------------- |
| `lock()`     | 阻塞当前线程直到获得锁           |
| `unlock()`   | 释放锁                           |
| `try_lock()` | 尝试获取锁，立即返回成功与否结果 |

## C++ 标准中的 Lockable 类型

| 类型                   | 描述           | 头文件           |
| ---------------------- | -------------- | ---------------- |
| `std::mutex`           | 基本互斥锁     | `<mutex>`        |
| `std::recursive_mutex` | 可重入互斥锁   | `<mutex>`        |
| `std::timed_mutex`     | 带超时的互斥锁 | `<mutex>`        |
| `std::shared_mutex`    | 读写锁 (C++17) | `<shared_mutex>` |

## Lockable 在模板中的应用

### 基本模板结构

```cpp
#include <mutex>
#include <iostream>

// 线程安全操作模板
template <typename Lockable, typename... Args>
void thread_safe_operation(Lockable& lockable, Args&&... args) {
    // 1. 获取锁
    lockable.lock();
    
    // 2. 执行操作（需要锁保护的操作）
    // ... 操作代码 ...
    
    // 3. 释放锁
    lockable.unlock();
}
```

### 更安全的 RAII 实现

使用 `std::lock_guard` 确保异常安全：

```cpp
template <typename Lockable, typename Func, typename... Args>
auto safe_execute(Lockable& lockable, Func&& func, Args&&... args) 
    -> decltype(func(std::forward<Args>(args)...)) 
{
    // RAII 锁保护
    std::lock_guard<Lockable> lock(lockable);
    
    // 执行受保护的操作
    return func(std::forward<Args>(args)...);
}
```

## 示例 1

```cpp
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>

template <typename Lockable>
class ThreadSafeCounter {
public:
    ThreadSafeCounter() : count(0) {}
    
    void increment() {
        std::lock_guard<Lockable> lock(mutex);
        ++count;
    }
    
    int get() const {
        std::lock_guard<Lockable> lock(mutex);
        return count;
    }
    
private:
    mutable Lockable mutex; // mutable 允许在 const 方法中锁定
    int count;
};

int main() {
    // 使用 std::mutex 作为 Lockable
    ThreadSafeCounter<std::mutex> counter;
    
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([&] {
            for (int j = 0; j < 1000; ++j) {
                counter.increment();
            }
        });
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final count: " << counter.get() << std::endl;
    // 输出: Final count: 10000
    return 0;
}
```

## 示例2

假设有一个模板函数，它需要一个可锁定的对象（如互斥锁）来保护某些操作。

```cpp
#include <iostream>
#include <mutex>
#include <thread>

// 模板函数，接受一个可锁定的对象和任意数量的参数
template <typename Lockable, typename... T>
void safePrint(Lockable& lock, T... args) {
    std::lock_guard<Lockable> guard(lock); // 锁定对象
    (std::cout << ... << args) << std::endl; // 打印参数
}

int main() {
    std::mutex mtx; // 互斥锁
    safePrint(mtx, "Hello, ", "world!", 42); // 安全地打印
    return 0;
}
```

`std::lock_guard` 是一个 RAII（Resource Acquisition Is Initialization）风格的类，用于管理互斥锁的锁定和解锁。它在构造时锁定互斥锁，在析构时解锁互斥锁。

1. **模板参数**：
   - `typename Lockable`：表示一个可锁定的对象，通常是一个互斥锁。
   - `typename... T`：表示任意数量和类型的参数。

2. **函数定义**：
   - `safePrint(Lockable& lock, T... args)`：接受一个可锁定的对象 `lock` 和任意数量的参数 `args`。
   - `std::lock_guard<Lockable> guard(lock)`：使用 `std::lock_guard` 锁定 `lock`，确保在函数执行期间 `lock` 被锁定。
   - `(std::cout << ... << args) << std::endl`：使用 C++17 的折叠表达式展开参数包 `args`，将每个参数打印到 `std::cout`。

3. **调用示例**：
   - `std::mutex mtx`：定义一个互斥锁。
   - `safePrint(mtx, "Hello, ", "world!", 42)`：调用 `safePrint` 函数，传递互斥锁和要打印的参数。

# 类型特征
在C++中，**类型特征（Type Traits）** 是一种编译时检查和操作类型特性的机制。类型特征通常用于模板元编程，允许程序员在编译时根据类型的不同特性来编写条件代码。C++标准库提供了大量的类型特征，这些特征以模板类的形式存在，通常位于 `<type_traits>` 头文件中。

类型特征的主要作用包括：
- **检查类型特性**：例如，检查一个类型是否是整数类型、是否是浮点类型、是否是类类型等。
- **转换类型**：例如，将一个类型转换为它的引用类型、指针类型、常量类型等。
- **选择类型**：根据条件选择不同的类型。
- **操作类型**：例如，去除类型上的修饰符（如 `const`、`volatile` 等）。

## 检查类型特性
- **`std::is_integral<T>`**：检查类型 `T` 是否是整数类型（如 `int`、`char` 等）。
- **`std::is_floating_point<T>`**：检查类型 `T` 是否是浮点类型（如 `float`、`double` 等）。
- **`std::is_class<T>`**：检查类型 `T` 是否是类类型。
- **`std::is_pointer<T>`**：检查类型 `T` 是否是指针类型。
- **`std::is_reference<T>`**：检查类型 `T` 是否是引用类型。
- **`std::is_const<T>`**：检查类型 `T` 是否是常量类型。
- **`std::is_volatile<T>`**：检查类型 `T` 是否是易变类型。

## 转换类型
- **`std::add_const<T>`**：将类型 `T` 转换为常量类型。
- **`std::add_volatile<T>`**：将类型 `T` 转换为易变类型。
- **`std::add_pointer<T>`**：将类型 `T` 转换为指针类型。
- **`std::add_reference<T>`**：将类型 `T` 转换为引用类型。
- **`std::remove_const<T>`**：去除类型 `T` 的常量修饰符。
- **`std::remove_volatile<T>`**：去除类型 `T` 的易变修饰符。
- **`std::remove_pointer<T>`**：去除类型 `T` 的指针修饰符。
- **`std::remove_reference<T>`**：去除类型 `T` 的引用修饰符。

## 选择类型
- **`std::conditional<Cond, T, F>`**：根据条件 `Cond` 选择类型 `T` 或 `F`。
- **`std::enable_if<Cond, T>`**：如果条件 `Cond` 为 `true`，则提供类型 `T`；否则，不提供类型。

### std::enable_if 模板结构体

`std::enable_if` 是C++标准库中的一个模板结构体，用于根据条件 `Cond` 选择类型 `T`。它的定义如下：
```cpp
template <bool Cond, typename T = void>
struct enable_if;

template <typename T>
struct enable_if<true, T> { using type = T; };
```

- **模板参数**：
  - `bool Cond`：一个布尔值，表示条件。
  - `typename T = void`：一个类型，默认值为 `void`，表示如果条件为 `true` 时选择的类型。
  - 如果第二个参数没有，则为 void。

- **模板特化**：
  - `std::enable_if<true, T>`：当条件 `Cond` 为 `true` 时，`std::enable_if<true, T>` 提供一个类型别名 `type`，其类型为 `T`。
  - `std::enable_if<false, T>`：当条件 `Cond` 为 `false` 时，`std::enable_if<false, T>` 不提供 `type`，这会导致编译错误。

- **`std::enable_if<Cond, T>`**：这是一个模板结构体，根据条件 `Cond` 选择类型 `T`。
- **`::type`**：这是 `std::enable_if<Cond, T>` 内部定义的类型别名。
- **`typename`**：关键字 `typename` 用于告诉编译器，`std::enable_if<Cond, T>::type` 是一个类型。

## 示例：检查类型特性

```cpp
std::cout << "is_integral<int>::value: " << std::is_integral<int>::value << std::endl;
std::cout << "is_integral<double>::value: " << std::is_integral<double>::value << std::endl;
```

- 如果 `T` 是整数类型（如 `int`、`char`、`long` 等），`std::is_integral<T>::value` 的值为 `true`。
- 如果 `T` 不是整数类型（如 `float`、`double`、`std::string` 等），`std::is_integral<T>::value` 的值为 `false`。

`std::is_integral<T>` 是一个模板结构体，它继承自 `std::true_type` 或 `std::false_type`，具体取决于 `T` 是否是整数类型。`std::true_type` 和 `std::false_type` 是标准库中定义的两个模板结构体，分别表示布尔值 `true` 和 `false`。

假设有一个模板函数，需要根据输入类型是否是整数类型来选择不同的实现：
```cpp
#include <iostream>
#include <type_traits>

template <typename T>
void print_type_info() {
    if (std::is_integral<T>::value) {
        std::cout << "Type " << typeid(T).name() << " is an integral type." << std::endl;
    } else {
        std::cout << "Type " << typeid(T).name() << " is not an integral type." << std::endl;
    }
}

int main() {
    print_type_info<int>();      // 输出：Type i is an integral type.
    print_type_info<double>();   // 输出：Type d is not an integral type.
    return 0;
}
```

## 示例：转换类型
```cpp
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "remove_const<const int>::type: " << std::is_same<std::remove_const<const int>::type, int>::value << std::endl;
    std::cout << "add_const<int>::type: " << std::is_same<std::add_const<int>::type, const int>::value << std::endl;

    std::cout << "remove_pointer<int*>::type: " << std::is_same<std::remove_pointer<int*>::type, int>::value << std::endl;
    std::cout << "add_pointer<int>::type: " << std::is_same<std::add_pointer<int>::type, int*>::value << std::endl;

    return 0;
}
```

`std::remove_const<T>` 是一个类型特征，用于去除类型 `T` 的 `const` 修饰符。具体来说：
- 如果 `T` 是 `const` 类型，`std::remove_const<T>::type` 将去除 `const` 修饰符。
- 如果 `T` 不是 `const` 类型，`std::remove_const<T>::type` 保持原类型不变。

例如：
- `std::remove_const<const int>::type` 的结果是 `int`。
- `std::remove_const<int>::type` 的结果是 `int`。

`std::add_const<T>` 是一个类型特征，用于为类型 `T` 添加 `const` 修饰符。具体来说：
- 如果 `T` 不是 `const` 类型，`std::add_const<T>::type` 将添加 `const` 修饰符。
- 如果 `T` 已经是 `const` 类型，`std::add_const<T>::type` 保持原类型不变。

- `std::add_const<int>::type` 的结果是 `const int`。
- `std::add_const<const int>::type` 的结果是 `const int`。

`std::remove_pointer<T>` 是一个类型特征，用于去除类型 `T` 的指针修饰符。具体来说：
- 如果 `T` 是指针类型，`std::remove_pointer<T>::type` 将去除指针修饰符。
- 如果 `T` 不是指针类型，`std::remove_pointer<T>::type` 保持原类型不变。

例如：
- `std::remove_pointer<int*>::type` 的结果是 `int`。
- `std::remove_pointer<int>::type` 的结果是 `int`。

`std::add_pointer<T>` 是一个类型特征，用于为类型 `T` 添加指针修饰符。具体来说：
- 如果 `T` 不是指针类型，`std::add_pointer<T>::type` 将添加指针修饰符。
- 如果 `T` 已经是指针类型，`std::add_pointer<T>::type` 保持原类型不变。

例如：
- `std::add_pointer<int>::type` 的结果是 `int*`。
- `std::add_pointer<int*>::type` 的结果是 `int*`。

`std::is_same<T, U>` 是一个类型特征，用于检查两个类型 `T` 和 `U` 是否相同。具体来说：
- 如果 `T` 和 `U` 相同，`std::is_same<T, U>::value` 的值为 `true`。
- 如果 `T` 和 `U` 不相同，`std::is_same<T, U>::value` 的值为 `false`。

## 示例：选择类型
```cpp
#include <iostream>
#include <type_traits>

template <typename T>
using is_integral = std::is_integral<T>;

template <typename T>
using enable_if_integral = typename std::enable_if<is_integral<T>::value, T>::type;

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "is_integral<int>::value: " << is_integral<int>::value << std::endl;
    std::cout << "is_integral<double>::value: " << is_integral<double>::value << std::endl;

    // 使用 enable_if_integral
    enable_if_integral<int> x = 10; // 成功
    // enable_if_integral<double> y = 20.0; // 编译错误，因为 double 不是整数类型

    return 0;
}
```

`std::is_integral<T>` 是一个类型特征，用于检查类型 `T` 是否是整数类型。具体来说：
- 如果 `T` 是整数类型（如 `int`、`char`、`long` 等），`std::is_integral<T>::value` 的值为 `true`。
- 如果 `T` 不是整数类型（如 `float`、`double`、`std::string` 等），`std::is_integral<T>::value` 的值为 `false`。

```cpp
template <typename T>
using is_integral = std::is_integral<T>;
```
这行代码定义了一个类型别名 `is_integral`，它等价于 `std::is_integral<T>`。这样做的目的是为了简化代码，使代码更加易读。

`std::enable_if<Cond, T>` 是一个模板元编程工具，用于根据条件 `Cond` 选择类型 `T`。具体来说：
- 如果条件 `Cond` 为 `true`，`std::enable_if<Cond, T>::type` 的类型为 `T`。
- 如果条件 `Cond` 为 `false`，`std::enable_if<Cond, T>::type` 不存在，这会导致编译错误。

```cpp
template <typename T>
using enable_if_integral = typename std::enable_if<is_integral<T>::value, T>::type;
```
这行代码定义了一个类型别名 `enable_if_integral`，它使用 `std::enable_if` 来检查类型 `T` 是否是整数类型。如果 `T` 是整数类型，`enable_if_integral<T>` 的类型为 `T`；否则，编译器会报错。

```cpp
enable_if_integral<int> x = 10; // 成功
// enable_if_integral<double> y = 20.0; // 编译错误，因为 double 不是整数类型
```
- `enable_if_integral<int>` 的类型为 `int`，因此可以成功声明变量 `x`。
- `enable_if_integral<double>` 会导致编译错误，因为 `double` 不是整数类型，`std::enable_if<is_integral<double>::value, double>::type` 不存在。

当 `Cond` 为 `false` 时，`std::enable_if<Cond, T>::type` 不存在，这会导致编译器报错。这种设计的目的是为了在编译时强制类型检查，确保只有满足条件的类型可以被使用。如果 `Cond` 为 `false` 时不报错，那么就无法实现这种强制类型检查。

这种设计的意义在于：
- **编译时类型检查**：通过 `std::enable_if`，可以在编译时检查类型是否满足某些条件。如果类型不满足条件，编译器会报错，从而避免运行时错误。
- **模板特化**：`std::enable_if` 常用于模板特化，根据类型的不同特性选择不同的实现路径。如果 `Cond` 为 `false` 时不报错，那么就无法实现这种模板特化。
- **SFINAE（Substitution Failure Is Not An Error）**：`std::enable_if` 与SFINAE机制结合使用，可以实现模板的条件启用或禁用。如果 `Cond` 为 `false` 时不报错，那么就无法利用SFINAE机制。

SFINAE（Substitution Failure Is Not An Error）是C++模板元编程中的一个重要机制。它允许编译器在模板实例化时，如果某个模板参数的替换失败（例如类型不匹配），则忽略该模板，而不是报错。`std::enable_if` 与SFINAE机制结合使用，可以实现模板的条件启用或禁用。

- **编译时类型检查**：`std::enable_if<Cond, T>` 在 `Cond` 为 `false` 时报错，确保只有满足条件的类型可以被使用。
- **模板特化**：通过 `std::enable_if`，可以根据类型的不同特性选择不同的实现路径。
- **SFINAE机制**：`std::enable_if` 与SFINAE机制结合使用，可以实现模板的条件启用或禁用。

## 类型特征别名
类型特征别名是通过 `using` 关键字为标准库中的类型特征提供一个更简洁的别名。这使得代码更加简洁易读。

```cpp
#include <iostream>
#include <type_traits>

// 定义类型特征别名
template <typename T>
using is_integral = std::is_integral<T>;

template <typename T>
using is_floating_point = std::is_floating_point<T>;

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "is_integral<int>::value: " << is_integral<int>::value << std::endl;
    std::cout << "is_integral<double>::value: " << is_integral<double>::value << std::endl;

    std::cout << "is_floating_point<float>::value: " << is_floating_point<float>::value << std::endl;
    std::cout << "is_floating_point<int>::value: " << is_floating_point<int>::value << std::endl;

    return 0;
}
```

## ::value 和 ::type

### `::value`
`::value` 是一个静态成员变量，通常用于表示一个布尔值，用于检查某个条件是否为真。它通常用于类型特征（Type Traits）中。

```cpp
std::is_integral<T>::value
```
- `std::is_integral<T>` 是一个类型特征，用于检查类型 `T` 是否是整数类型。
- `std::is_integral<T>::value` 是一个布尔值，表示检查的结果：
  - 如果 `T` 是整数类型，`std::is_integral<T>::value` 的值为 `true`。
  - 如果 `T` 不是整数类型，`std::is_integral<T>::value` 的值为 `false`。

### `::type`
`::type` 是一个类型别名，通常用于表示一个类型，用于类型转换或选择。它通常用于 `std::enable_if` 和其他类型转换特征中。

```cpp
typename std::enable_if<Cond, T>::type
```
- `std::enable_if<Cond, T>` 是一个模板结构体，用于根据条件 `Cond` 选择类型 `T`。
- `typename std::enable_if<Cond, T>::type` 是一个类型别名，表示选择的类型：
  - 如果 `Cond` 为 `true`，`std::enable_if<Cond, T>::type` 的类型为 `T`。
  - 如果 `Cond` 为 `false`，`std::enable_if<Cond, T>::type` 不存在，这会导致编译错误。


# std::integral_constant
`std::integral_constant` 是C++标准库中的一个模板类，用于表示一个编译时常量值。它在模板元编程中非常有用，可以用来在编译时存储和操作常量值。

`std::integral_constant` 是C++标准库中的一个模板类，定义在 `<type_traits>` 头文件中。它的定义如下：
```cpp
template <typename T, T v>
struct integral_constant {
    static constexpr T value = v; // 提供一个静态常量成员变量 value
    using value_type = T;         // 提供一个类型别名 value_type
    using type = integral_constant<T, v>; // 提供一个类型别名 type

    constexpr operator value_type() const noexcept { return value; } // 提供一个转换运算符
    constexpr value_type operator()() const noexcept { return value; } // 提供一个函数调用运算符
};
```

- `value` 是一个静态常量成员变量，其类型为 `T`，值为 `v`。
- 它用于存储模板参数 `v` 的值。

- `value_type` 是一个类型别名，表示 `value` 的类型。
- 它提供了一种方式来访问 `value` 的类型。

- `type` 是一个类型别名，表示 `integral_constant` 本身的类型。
- 它提供了一种方式来访问 `integral_constant` 的类型。

`constexpr operator value_type() const noexcept { return value; }`
- 这是一个转换运算符，允许 `integral_constant` 的对象隐式转换为 `value_type`。
- 它使得 `integral_constant` 的对象可以像普通值一样使用。

`constexpr value_type operator()() const noexcept { return value; }`
- 这是一个函数调用运算符，允许通过函数调用的方式获取 `value` 的值。
- 它使得 `integral_constant` 的对象可以像函数一样调用。

## 作用
`std::integral_constant` 是 C++ 类型特征库中的基础构件，它提供了一种将编译期常量值包装为类型的方法。这个模板类是 C++ 模板元编程的基石，几乎所有标准库类型特征都直接或间接基于它。

1. **类型级别操作**：允许在模板参数中使用常量值
2. **接口统一**：标准化所有类型特征的返回值访问方式
3. **零开销抽象**：编译期计算，无运行时开销
4. **元编程组合**：可作为其他元函数的输入和输出
5. **SFINAE友好**：完美支持替换失败非错误机制

### 1. 编译期值包装
将编译期常量值（整数、布尔、枚举等）提升为类型级别实体，使其可在模板元编程中使用。

### 2. 类型特征基础
标准库中的布尔类型特征（如 `std::true_type` 和 `std::false_type`）都是 `integral_constant` 的特化：
```cpp
typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
```

### 3. 元函数返回值
提供标准化的接口来返回元函数结果：
- `::value` 获取值
- `::type` 获取类型本身

### 4. 值到类型的映射
实现编译期值到类型的映射，用于高级模板元编程模式。

| 别名         | 等价类型                         | 值      |
| ------------ | -------------------------------- | ------- |
| `true_type`  | `integral_constant<bool, true>`  | `true`  |
| `false_type` | `integral_constant<bool, false>` | `false` |

## 示例
假设 `detail::null_mutex` 是一个表示非线程安全的互斥锁类型，可以使用 `is_thread_safe` 来检查某个互斥锁类型是否是线程安全的。

```cpp
#include <iostream>
#include <type_traits>

namespace detail {
    struct null_mutex {}; // 非线程安全的互斥锁类型
}

template <typename L>
using is_thread_safe = std::integral_constant<bool, !std::is_same<L, detail::null_mutex>::value>;

struct my_mutex {}; // 自定义的线程安全的互斥锁类型

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "is_thread_safe<my_mutex>::value: " << is_thread_safe<my_mutex>::value << std::endl;
    std::cout << "is_thread_safe<detail::null_mutex>::value: " << is_thread_safe<detail::null_mutex>::value << std::endl;

    return 0;
}
```

输出结果：
```
is_thread_safe<my_mutex>::value: true
is_thread_safe<detail::null_mutex>::value: false
```

代码定义了一个模板别名 `is_thread_safe`，它利用了C++标准库中的 `std::integral_constant` 和 `std::is_same` 来实现一个类型特征，用于检查类型 `L` 是否与 `detail::null_mutex` 不同。如果不同，则表示类型 `L` 是线程安全的。

`template <typename L>`
这是模板参数的声明，表示 `is_thread_safe` 是一个模板别名，它接受一个类型参数 `L`。

`using is_thread_safe = ...`
这是C++11引入的模板别名声明语法，用于定义一个别名 `is_thread_safe`，它将复杂的表达式简化为一个更易读的形式。

`std::integral_constant<bool, ...>`
`std::integral_constant` 是C++标准库中的一个模板类，用于表示一个编译时常量值。它的定义如下：
- `T` 是常量的类型。
- `v` 是常量的值。
- `std::integral_constant<bool, ...>` 表示一个布尔类型的编译时常量。

`!std::is_same<L, detail::null_mutex>::value`
`std::is_same` 是C++标准库中的一个模板结构体，用于检查两个类型是否相同。它的定义如下：
```cpp
template <typename T, typename U>
struct is_same : std::false_type {}; // 默认情况下，两个类型不同

template <typename T>
struct is_same<T, T> : std::true_type {}; // 如果两个类型相同
```
- `std::is_same<T, U>::value` 是一个布尔值，表示类型 `T` 和 `U` 是否相同。
- `std::is_same<L, detail::null_mutex>::value` 检查类型 `L` 是否与 `detail::null_mutex` 相同。
- `!std::is_same<L, detail::null_mutex>::value` 取反，表示类型 `L` 是否与 `detail::null_mutex` 不同。

`std::integral_constant<bool, !std::is_same<L, detail::null_mutex>::value>`
这表示一个布尔类型的编译时常量，其值为 `!std::is_same<L, detail::null_mutex>::value`。也就是说，如果 `L` 与 `detail::null_mutex` 不同，这个常量的值为 `true`；否则为 `false`。

这行代码定义了一个类型特征 `is_thread_safe`，用于检查类型 `L` 是否与 `detail::null_mutex` 不同。如果不同，则表示类型 `L` 是线程安全的。这种类型特征在模板元编程中非常有用，可以帮助编写更加通用和灵活的代码。

# std::conditional_t
`std::conditional_t` 是C++17引入的一个模板别名，用于根据条件选择类型。它的定义如下：
```cpp
template <bool Cond, typename T, typename F>
using conditional_t = typename conditional<Cond, T, F>::type;
```
- `Cond` 是一个布尔值，表示条件。
- `T` 是条件为 `true` 时选择的类型。
- `F` 是条件为 `false` 时选择的类型。

假设 `detail::null_mutex` 是一个表示非线程安全的互斥锁类型，`detail::copy_on_write<U>` 是一个表示拷贝-on-写机制的类型。使用 `cow_type` 来选择合适的类型。

```cpp
#include <iostream>
#include <type_traits>

namespace detail {
    struct null_mutex {}; // 非线程安全的互斥锁类型

    template <typename U>
    struct copy_on_write {
        U value;
        // 其他实现细节
    };
}

template <typename L>
using is_thread_safe = std::integral_constant<bool, !std::is_same<L, detail::null_mutex>::value>;

template <typename U, typename L>
using cow_type = std::conditional_t<is_thread_safe<L>::value,
                                    detail::copy_on_write<U>, U>;

int main() {
    cow_type<int, detail::null_mutex> x = 10; // x 的类型为 int
    cow_type<int, std::mutex> y = {20};       // y 的类型为 detail::copy_on_write<int>

    std::cout << "x: " << x << std::endl;
    std::cout << "y.value: " << y.value << std::endl;

    return 0;
}
```

输出结果：
```
x: 10
y.value: 20
```

码定义了一个模板别名 `cow_type`，它使用 `std::conditional_t` 来根据条件选择类型。具体来说，它根据 `L` 是否是线程安全的，选择 `detail::copy_on_write<U>` 或 `U` 作为最终的类型。

```cpp
template <typename U, typename L>
```
- `U` 和 `L` 是两个模板参数，分别表示某种类型。

`using cow_type = ...`
这是C++11引入的模板别名声明语法，用于定义一个别名 `cow_type`，它将复杂的表达式简化为一个更易读的形式。

```cpp
template <typename L>
using is_thread_safe = std::integral_constant<bool, !std::is_same<L, detail::null_mutex>::value>;
```
- `is_thread_safe<L>::value` 是一个布尔值，表示类型 `L` 是否是线程安全的。
- 如果 `L` 与 `detail::null_mutex` 不同，则 `is_thread_safe<L>::value` 为 `true`，表示 `L` 是线程安全的。
- 如果 `L` 与 `detail::null_mutex` 相同，则 `is_thread_safe<L>::value` 为 `false`，表示 `L` 不是线程安全的。

`detail::copy_on_write<U>` 是一个类型，表示某种“拷贝-on-写”（Copy-on-Write, COW）机制。这种机制通常用于优化性能，避免不必要的拷贝操作。

# std::decay_t
`std::decay_t` 是C++17引入的一个模板别名，用于简化 `std::decay` 的使用。`std::decay` 是一个类型特征，用于去除类型的各种修饰符（如引用、`const`、`volatile` 等），并返回基础类型。`std::decay_t` 是 `std::decay` 的简化版本，使得代码更加简洁易读。

`std::decay` 是C++11引入的一个类型特征，用于去除类型的各种修饰符，并返回基础类型。它的定义如下：
```cpp
template <typename T>
struct decay {
    using type = /* 去除 T 的引用、const、volatile 等修饰符后的基础类型 */;
};
```

`std::decay_t` 是C++17引入的一个模板别名，用于简化 `std::decay` 的使用。它的定义如下：
```cpp
template <typename T>
using decay_t = typename decay<T>::type;
```

`std::decay` 和 `std::decay_t` 的作用是去除类型的各种修饰符，包括：
- 引用（`&` 和 `&&`）
- `const`
- `volatile`
- 数组类型转换为指针
- 函数类型转换为指针

## 去除引用
```cpp
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "decay_t<int&>: " << std::is_same<std::decay_t<int&>, int>::value << std::endl; // 输出：true
    std::cout << "decay_t<int&&>: " << std::is_same<std::decay_t<int&&>, int>::value << std::endl; // 输出：true

    return 0;
}
```

## 去除 `const` 和 `volatile`
```cpp
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "decay_t<const int>: " << std::is_same<std::decay_t<const int>, int>::value << std::endl; // 输出：true
    std::cout << "decay_t<volatile int>: " << std::is_same<std::decay_t<volatile int>, int>::value << std::endl; // 输出：true
    std::cout << "decay_t<const volatile int>: " << std::is_same<std::decay_t<const volatile int>, int>::value << std::endl; // 输出：true

    return 0;
}
```

## 数组类型转换为指针
```cpp
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "decay_t<int[10]>: " << std::is_same<std::decay_t<int[10]>, int*>::value << std::endl; // 输出：true

    return 0;
}
```

## 函数类型转换为指针
```cpp
#include <iostream>
#include <type_traits>
#include <functional>

int main() {
    std::cout << std::boolalpha; // 输出布尔值为 true 或 false

    std::cout << "decay_t<int()>: " << std::is_same<std::decay_t<int()>, int(*)()>::value << std::endl; // 输出：true

    return 0;
}
```

# 类型列表 typelist

```cpp
template <typename...> 
struct typelist {};
```

1. **`template <typename...>`**  
   - `template`：声明这是一个模板
   - `<typename...>`：声明一个**匿名类型参数包**（unnamed type parameter pack）
   - 匿名表示模板内部不需要直接引用这些类型参数

2. **`struct typelist {};`**  
   - 定义一个空结构体`typelist`
   - 大括号`{}`表示这是一个空结构体（不包含任何成员）

这个结构体唯一的作用是**将任意数量的类型打包成一个单一的类型实体**。可以把它看作编译期的"类型容器"。

## 示例
```cpp
// 空类型列表
using EmptyList = typelist<>; 

// 单类型列表
using IntList = typelist<int>; 

// 多类型列表
using NumberList = typelist<int, float, double>;
```

1. **不需要操作单个类型**  
   在基础定义中，我们只关心"打包类型"这个行为，不需要访问单个类型
   
2. **专注容器特性**  
   匿名参数包强调"这是一个可容纳任意类型组合的容器"
